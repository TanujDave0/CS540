[
  {
    "task_id": "ClassEval_14",
    "skeleton": "import sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        \"\"\"\n    \n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        \"\"\"\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        \"\"\"\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        \"\"\"\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        \"\"\"\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        \"\"\"",
    "test": "import unittest\nimport os\n\n\nclass BookManagementDBTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_create_table_1(self):\n        # Check if the table exists\n        self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='books'\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n\n    def test_create_table_2(self):\n        self.db.create_table()\n        # Check if the table has the correct columns\n        self.cursor.execute(\"PRAGMA table_info(books)\")\n        columns = self.cursor.fetchall()\n        column_names = [column[1] for column in columns]\n        expected_column_names = ['id', 'title', 'author', 'available']\n        self.assertEqual(column_names, expected_column_names)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestAddBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_add_book(self):\n        title = \"Introduction to Python\"\n        author = \"John Smith\"\n        self.db.add_book(title, author)\n\n        # Check if the book was added correctly\n        self.cursor.execute(\"SELECT title, author, available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], title)\n        self.assertEqual(result[1], author)\n        self.assertEqual(result[2], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestRemoveBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing removal\n        self.db.add_book(\"Book to Remove\", \"John Doe\")\n\n    def test_remove_book(self):\n        self.db.remove_book(1)\n\n        # Check if the book was removed correctly\n        self.cursor.execute(\"SELECT * FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNone(result)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestBorrowBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing borrowing\n        self.db.add_book(\"Book to Borrow\", \"Jane Smith\")\n\n    def test_borrow_book(self):\n        self.db.borrow_book(1)\n\n        # Check if the book was marked as unavailable\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 0)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestReturnBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing returning\n        self.db.add_book(\"Book to Return\", \"James Smith\")\n        self.db.borrow_book(1)  # Mark the book as borrowed\n\n    def test_return_book(self):\n        self.db.return_book(1)\n\n        # Check if the book was marked as available again\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestSearchBooks(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add some books for testing search\n        self.db.add_book(\"Book 1\", \"Author 1\")\n        self.db.add_book(\"Book 2\", \"Author 2\")\n        self.db.add_book(\"Book 3\", \"Author 3\")\n\n    def test_search_books(self):\n        books = self.db.search_books()\n\n        # Ensure that all books were retrieved\n        self.assertEqual(len(books), 3)\n\n        # Ensure that the correct book information is retrieved\n        self.assertEqual(books[0][1], \"Book 1\")\n        self.assertEqual(books[1][2], \"Author 2\")\n        self.assertEqual(books[2][3], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
    "solution_code": "import sqlite3\n\nclass BookManagementDB:\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        books = self.cursor.fetchall()\n        return books",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n",
    "class_name": "BookManagementDB",
    "test_classes": [
      "BookManagementDBTestCreateTable",
      "BookManagementDBTestAddBook",
      "BookManagementDBTestRemoveBook",
      "BookManagementDBTestBorrowBook",
      "BookManagementDBTestReturnBook",
      "BookManagementDBTestSearchBooks"
    ],
    "class_constructor": "class BookManagementDB: \n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n",
    "fields": [
      "self.connection",
      "self.cursor"
    ],
    "methods_info": [
      {
        "method_name": "create_table",
        "method_description": "def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        \"\"\"",
        "test_class": "BookManagementDBTestCreateTable",
        "test_code": "class BookManagementDBTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_create_table_1(self):\n        # Check if the table exists\n        self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='books'\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n\n    def test_create_table_2(self):\n        self.db.create_table()\n        # Check if the table has the correct columns\n        self.cursor.execute(\"PRAGMA table_info(books)\")\n        columns = self.cursor.fetchall()\n        column_names = [column[1] for column in columns]\n        expected_column_names = ['id', 'title', 'author', 'available']\n        self.assertEqual(column_names, expected_column_names)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "add_book",
        "method_description": "def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        \"\"\"",
        "test_class": "BookManagementDBTestAddBook",
        "test_code": "class BookManagementDBTestAddBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_add_book(self):\n        title = \"Introduction to Python\"\n        author = \"John Smith\"\n        self.db.add_book(title, author)\n\n        # Check if the book was added correctly\n        self.cursor.execute(\"SELECT title, author, available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], title)\n        self.assertEqual(result[1], author)\n        self.assertEqual(result[2], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def add_book(self, title, author):\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "remove_book",
        "method_description": "def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        \"\"\"",
        "test_class": "BookManagementDBTestRemoveBook",
        "test_code": "class BookManagementDBTestRemoveBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing removal\n        self.db.add_book(\"Book to Remove\", \"John Doe\")\n\n    def test_remove_book(self):\n        self.db.remove_book(1)\n\n        # Check if the book was removed correctly\n        self.cursor.execute(\"SELECT * FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNone(result)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def remove_book(self, book_id):\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "borrow_book",
        "method_description": "def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        \"\"\"",
        "test_class": "BookManagementDBTestBorrowBook",
        "test_code": "class BookManagementDBTestBorrowBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing borrowing\n        self.db.add_book(\"Book to Borrow\", \"Jane Smith\")\n\n    def test_borrow_book(self):\n        self.db.borrow_book(1)\n\n        # Check if the book was marked as unavailable\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 0)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def borrow_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "return_book",
        "method_description": "def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        \"\"\"",
        "test_class": "BookManagementDBTestReturnBook",
        "test_code": "class BookManagementDBTestReturnBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing returning\n        self.db.add_book(\"Book to Return\", \"James Smith\")\n        self.db.borrow_book(1)  # Mark the book as borrowed\n\n    def test_return_book(self):\n        self.db.return_book(1)\n\n        # Check if the book was marked as available again\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def return_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_books",
        "method_description": "def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        \"\"\"",
        "test_class": "BookManagementDBTestSearchBooks",
        "test_code": "class BookManagementDBTestSearchBooks(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add some books for testing search\n        self.db.add_book(\"Book 1\", \"Author 1\")\n        self.db.add_book(\"Book 2\", \"Author 2\")\n        self.db.add_book(\"Book 3\", \"Author 3\")\n\n    def test_search_books(self):\n        books = self.db.search_books()\n\n        # Ensure that all books were retrieved\n        self.assertEqual(len(books), 3)\n\n        # Ensure that the correct book information is retrieved\n        self.assertEqual(books[0][1], \"Book 1\")\n        self.assertEqual(books[1][2], \"Author 2\")\n        self.assertEqual(books[2][3], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def search_books(self):\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        books = self.cursor.fetchall()\n        return books",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.cursor"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "import sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations\n    of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO books (title, author, availability) VALUES (?, ?, ?)\",\n            (title, author, 1)\n        )\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM books WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET availability = 0 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET availability = 1 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT id, title, author, availability FROM books\"\n        )\n        return self.cursor.fetchall()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the object is destroyed.\n        \"\"\"\n        try:\n            self.connection.close()\n        except:\n            pass",
      "Here\u2019s a straightforward implementation completing all of the methods using SQLite and parameterized queries. You can drop this into your module and it will create a `books` table (if needed) and allow you to add, remove, borrow, return and list all books.\n\n```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations\n    of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                available INTEGER NOT NULL DEFAULT 1\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\",\n            (title, author)\n        )\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM books WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET available = 0 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET available = 1 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        \"\"\"\n        self.cursor.execute(\"SELECT id, title, author, available FROM books\")\n        return self.cursor.fetchall()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the object is destroyed.\n        \"\"\"\n        try:\n            self.connection.close()\n        except Exception:\n            pass\n```\n\nExample usage:\n\n```python\nif __name__ == \"__main__\":\n    db = BookManagementDB(\"library.db\")\n    db.add_book(\"1984\", \"George Orwell\")\n    db.add_book(\"Brave New World\", \"Aldous Huxley\")\n    print(db.search_books())\n    db.borrow_book(1)\n    print(db.search_books())\n    db.return_book(1)\n    db.remove_book(2)\n    print(db.search_books())\n```\n\nThis will:\n\n1. Create `library.db` (if not already present) and the `books` table.\n2. Add two books.\n3. List all books.\n4. Borrow and return a book.\n5. Remove a book.\n6. List again to show the final state.",
      "Here\u2019s a straightforward implementation filling in all of the methods you specified. It uses a single table named `book` with columns `(id, title, author, availability)`:\n\n```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations\n    of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS book (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL DEFAULT 1\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO book (title, author, availability) VALUES (?, ?, ?)\",\n            (title, author, 1)\n        )\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM book WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        # Only mark as borrowed if it is currently available\n        self.cursor.execute(\n            \"UPDATE book SET availability = 0 WHERE id = ? AND availability = 1\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        # Only mark as returned if it is currently borrowed\n        self.cursor.execute(\n            \"UPDATE book SET availability = 1 WHERE id = ? AND availability = 0\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT id, title, author, availability FROM book\"\n        )\n        return self.cursor.fetchall()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n```\n\nUsage example:\n\n```python\ndb = BookManagementDB(\"library.db\")\ndb.add_book(\"The Hobbit\", \"J.R.R. Tolkien\")\nprint(db.search_books())    # [(1, \"The Hobbit\", \"J.R.R. Tolkien\", 1)]\ndb.borrow_book(1)\nprint(db.search_books())    # availability changes to 0\ndb.return_book(1)\ndb.remove_book(1)\ndb.close()\n```",
      "Here\u2019s a straightforward implementation of `BookManagementDB` that fulfills all of the requirements:\n\n```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations\n    of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL DEFAULT 1\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO books (title, author, availability) VALUES (?, ?, 1)\",\n            (title, author)\n        )\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM books WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET availability = 0 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET availability = 1 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        \"\"\"\n        self.cursor.execute(\"SELECT id, title, author, availability FROM books\")\n        return self.cursor.fetchall()\n```\n\nUsage example:\n\n```python\nif __name__ == \"__main__\":\n    db = BookManagementDB(\"test.db\")\n    db.add_book(\"The Hobbit\", \"J.R.R. Tolkien\")\n    db.add_book(\"1984\", \"George Orwell\")\n    print(db.search_books())\n    db.borrow_book(1)\n    print(db.search_books())\n    db.return_book(1)\n    db.remove_book(2)\n    print(db.search_books())\n```\n\nThis will create (if needed) a `books` table, allow adding, removing, borrowing, returning, and listing all books.",
      "Here is a possible implementation of\u00a0BookManagementDB\u00a0with all methods filled in:\n\n```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of\n    adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist.\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL DEFAULT 1\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO books (title, author, availability) VALUES (?, ?, 1)\",\n            (title, author)\n        )\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM books WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed (availability = 0) in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET availability = 0 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned (availability = 1) in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\n            \"UPDATE books SET availability = 1 WHERE id = ?\",\n            (book_id,)\n        )\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return: list of tuples (id, title, author, availability)\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT id, title, author, availability FROM books\"\n        )\n        return self.cursor.fetchall()\n\n    def __del__(self):\n        \"\"\"\n        Ensure the database connection is closed when the object is destroyed.\n        \"\"\"\n        if hasattr(self, \"connection\"):\n            self.connection.close()\n```\n\nUsage example:\n\n```python\nif __name__ == \"__main__\":\n    db = BookManagementDB(\"library.db\")\n    db.add_book(\"1984\", \"George Orwell\")\n    db.add_book(\"Brave New World\", \"Aldous Huxley\")\n    print(db.search_books())         # [(1, '1984', 'George Orwell', 1), (2, 'Brave New World', ...)]\n    db.borrow_book(1)\n    print(db.search_books())         # availability for id=1 becomes 0\n    db.return_book(1)\n    db.remove_book(2)\n    print(db.search_books())         # only book id=1 remains\n```"
    ]
  },
  {
    "task_id": "ClassEval_28",
    "skeleton": "import sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"",
    "test": "import unittest\nimport sqlite3\n\n\nclass DatabaseProcessorTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_create_table_1(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_2(self):\n        table_name = \"test_table2\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_3(self):\n        table_name = \"test_table3\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_4(self):\n        table_name = \"test_table4\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_5(self):\n        table_name = \"test_table5\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n\nclass DatabaseProcessorTestInsertIntoDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_into_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n    def test_insert_into_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 15},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 15)\n\n    def test_insert_into_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 16},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 16)\n\n    def test_insert_into_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 17},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 17)\n\n    def test_insert_into_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 18},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 18)\n\n\nclass DatabaseProcessorTestSearchDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_search_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_search_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Alice')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_search_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Bob')\n        self.assertIsNone(result)\n\n    def test_search_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'aaa')\n        self.assertIsNone(result)\n\n    def test_search_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'bbb')\n        self.assertIsNone(result)\n\n\nclass DatabaseProcessorTestDeteleFromDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_from_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_delete_from_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_delete_from_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_from_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'aaa', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_delete_from_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'bbb', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'bbb')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n\nclass DatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_DatabaseProcessor(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')",
    "solution_code": "import sqlite3\nimport pandas as pd\n\n\nclass DatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        if result:\n            return result\n        else:\n            return None\n\n    def delete_from_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
    "import_statement": [
      "import sqlite3",
      "import pandas as pd"
    ],
    "class_description": "    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n",
    "class_name": "DatabaseProcessor",
    "test_classes": [
      "DatabaseProcessorTestCreateTable",
      "DatabaseProcessorTestInsertIntoDatabase",
      "DatabaseProcessorTestSearchDatabase",
      "DatabaseProcessorTestDeteleFromDatabase",
      "DatabaseProcessorTest"
    ],
    "class_constructor": "class DatabaseProcessor: \n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n",
    "fields": [
      "self.database_name"
    ],
    "methods_info": [
      {
        "method_name": "create_table",
        "method_description": "def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"",
        "test_class": "DatabaseProcessorTestCreateTable",
        "test_code": "class DatabaseProcessorTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_create_table_1(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_2(self):\n        table_name = \"test_table2\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_3(self):\n        table_name = \"test_table3\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_4(self):\n        table_name = \"test_table4\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_5(self):\n        table_name = \"test_table5\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)",
        "solution_code": "def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert_into_database",
        "method_description": "def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"",
        "test_class": "DatabaseProcessorTestInsertIntoDatabase",
        "test_code": "class DatabaseProcessorTestInsertIntoDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_into_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n    def test_insert_into_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 15},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 15)\n\n    def test_insert_into_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 16},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 16)\n\n    def test_insert_into_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 17},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 17)\n\n    def test_insert_into_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 18},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 18)",
        "solution_code": "def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_database",
        "method_description": "def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"",
        "test_class": "DatabaseProcessorTestSearchDatabase",
        "test_code": "class DatabaseProcessorTestSearchDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_search_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_search_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Alice')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_search_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Bob')\n        self.assertIsNone(result)\n\n    def test_search_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'aaa')\n        self.assertIsNone(result)\n\n    def test_search_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'bbb')\n        self.assertIsNone(result)",
        "solution_code": "def search_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        if result:\n            return result\n        else:\n            return None",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_from_database",
        "method_description": "def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"",
        "test_class": "DatabaseProcessorTestDeteleFromDatabase",
        "test_code": "class DatabaseProcessorTestDeteleFromDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_from_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_delete_from_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_delete_from_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_from_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'aaa', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_delete_from_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'bbb', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'bbb')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')",
        "solution_code": "def delete_from_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "Here is one possible implementation of the requested `DatabaseProcessor` class. It uses `sqlite3` under the hood to manage the database file, creates tables with an `id` primary key plus two user\u2011specified columns, allows bulk insertion of rows supplied as dictionaries, and provides simple \u201csearch by name\u201d and \u201cdelete by name\u201d methods. If no matching rows are found in `search_database`, it returns `None`.\n\n```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting creation of tables,\n    insertion of data, searching by name, and deletion by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize with the path/name of the SQLite database file.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        Columns:\n          - id     INTEGER PRIMARY KEY\n          - key1   TEXT\n          - key2   INTEGER\n\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column (TEXT).\n        :param key2: str, the name of the second column (INTEGER).\n        \"\"\"\n        create_stmt = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {table_name} (\n                id   INTEGER PRIMARY KEY,\n                {key1} TEXT,\n                {key2} INTEGER\n            );\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(create_stmt)\n            conn.commit()\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert multiple rows into a table.\n        :param table_name: str, table to insert into.\n        :param data: list of dicts, each dict maps column names to values.\n        \"\"\"\n        if not data:\n            return\n\n        # Derive column names and placeholders from the first dict\n        columns = list(data[0].keys())\n        placeholders = \", \".join(\"?\" for _ in columns)\n        cols_formatted = \", \".join(columns)\n        insert_stmt = f\"INSERT INTO {table_name} ({cols_formatted}) VALUES ({placeholders})\"\n\n        # Build list of tuples of values\n        values = [tuple(d[col] for col in columns) for d in data]\n\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.executemany(insert_stmt, values)\n            conn.commit()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search for rows where the `name` column matches the provided value.\n        Assumes the table has a TEXT column literally named \"name\".\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list of tuples for matching rows, or None if no matches.\n        \"\"\"\n        select_stmt = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(select_stmt, (name,))\n            rows = cursor.fetchall()\n        return rows if rows else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows where the `name` column matches the provided value.\n        Assumes the table has a TEXT column literally named \"name\".\n        :param table_name: str, the name of the table.\n        :param name: str, the name value to delete.\n        \"\"\"\n        delete_stmt = f\"DELETE FROM {table_name} WHERE name = ?\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(delete_stmt, (name,))\n            conn.commit()\n```\n\nExample usage:\n\n```python\ndb = DatabaseProcessor(\"mydb.sqlite\")\ndb.create_table(\"user\", \"name\", \"age\")\ndb.insert_into_database(\"user\", [\n    {\"name\": \"John\", \"age\": 25},\n    {\"name\": \"Alice\", \"age\": 30},\n])\nprint(db.search_database(\"user\", \"John\"))   # e.g. [(1, 'John', 25)]\ndb.delete_from_database(\"user\", \"John\")\nprint(db.search_database(\"user\", \"John\"))   # None\n```",
      "Here\u2019s one possible implementation that meets the requirements:\n\n```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables,\n    insert data into the database, search for data based on name,\n    and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n        # Keep track of what the \u201cname\u201d column is for each table\n        self._name_column = {}\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        sql = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {table_name} (\n                id INTEGER PRIMARY KEY,\n                {key1} TEXT,\n                {key2} INTEGER\n            )\n        \"\"\"\n        cur.execute(sql)\n        conn.commit()\n        conn.close()\n        # remember which column we\u2019ll search/delete by \u201cname\u201d\n        #   (so that search_database and delete_from_database know which column to use)\n        self._name_column[table_name] = key1\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        \"\"\"\n        if not data:\n            return\n\n        # assume all dicts have the same keys\n        columns = list(data[0].keys())\n        placeholders = \", \".join(\"?\" for _ in columns)\n        cols_sql = \", \".join(columns)\n\n        values = []\n        for row in data:\n            # ensure we pull values in the same order as columns\n            values.append(tuple(row[col] for col in columns))\n\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        sql = f\"INSERT INTO {table_name} ({cols_sql}) VALUES ({placeholders})\"\n        cur.executemany(sql, values)\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                 otherwise, returns None.\n        \"\"\"\n        # figure out which column is the \u201cname\u201d column for this table\n        name_col = self._name_column.get(table_name, \"name\")\n\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        sql = f\"SELECT * FROM {table_name} WHERE {name_col} = ?\"\n        cur.execute(sql, (name,))\n        rows = cur.fetchall()\n        conn.close()\n        return rows if rows else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        \"\"\"\n        name_col = self._name_column.get(table_name, \"name\")\n\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        sql = f\"DELETE FROM {table_name} WHERE {name_col} = ?\"\n        cur.execute(sql, (name,))\n        conn.commit()\n        conn.close()\n```\n\nExplanation\n\n\u2022 `create_table` builds and runs a `CREATE TABLE IF NOT EXISTS` statement, defines an integer primary key `id`, plus two user\u2011specified columns. It also records which column should be treated as the \u201cname\u201d column for later searches/deletes.  \n\u2022 `insert_into_database` dynamically infers columns from the keys of the first dictionary in the provided list, constructs a bulk\u2010insert statement with placeholders, and executes it via `executemany`.  \n\u2022 `search_database` looks up the recorded \u201cname\u201d column for the given table (defaulting to `\"name\"` if the table was pre\u2011existing), runs a `SELECT * \u2026 WHERE name_col = ?`, and returns a list of tuples or `None` if no match.  \n\u2022 `delete_from_database` does the analogous `DELETE \u2026 WHERE name_col = ?`.",
      "Here is a possible implementation of the four methods using sqlite3. We simply build and execute the appropriate SQL statements and return or commit as required.\n\n```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        \"\"\"\n        sql = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {table_name} (\n                id INTEGER PRIMARY KEY,\n                {key1} TEXT,\n                {key2} INTEGER\n            )\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(sql)\n            conn.commit()\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        \"\"\"\n        if not data:\n            return  # nothing to do\n\n        # We'll extract column names from the first dict\n        cols = list(data[0].keys())\n        cols_sql = \", \".join(cols)\n        placeholders = \", \".join(\"?\" for _ in cols)\n        sql = f\"INSERT INTO {table_name} ({cols_sql}) VALUES ({placeholders})\"\n\n        values = []\n        for row in data:\n            # ensure the same order\n            values.append(tuple(row[col] for col in cols))\n\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.executemany(sql, values)\n            conn.commit()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                 otherwise, returns None.\n        \"\"\"\n        sql = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(sql, (name,))\n            results = cursor.fetchall()\n        return results if results else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        \"\"\"\n        sql = f\"DELETE FROM {table_name} WHERE name = ?\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(sql, (name,))\n            conn.commit()\n```\n\nExplanation:\n\n- `create_table` builds a `CREATE TABLE IF NOT EXISTS` statement using the provided table name and column names, and executes it.\n- `insert_into_database` looks at the keys of the first dict in `data` to determine column names, builds an `INSERT` statement with placeholders, and then uses `executemany` to insert all rows in one go.\n- `search_database` selects all columns from rows where `name` matches, fetches all, and returns the list of tuples (or `None` if empty).\n- `delete_from_database` deletes all rows where `name` matches and commits the change.",
      "Here is a possible implementation of the `DatabaseProcessor` class completing all four methods:\n\n```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables,\n    insert data into the database, search for data based on name,\n    and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        stmt = f\"\"\"\n        CREATE TABLE IF NOT EXISTS {table_name} (\n            id INTEGER PRIMARY KEY,\n            {key1} TEXT,\n            {key2} INTEGER\n        )\n        \"\"\"\n        cur.execute(stmt)\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        \"\"\"\n        if not data:\n            return\n\n        # assume all dicts have the same keys\n        columns = list(data[0].keys())\n        cols_sql = \", \".join(columns)\n        placeholders = \", \".join(\"?\" for _ in columns)\n        values = [tuple(item[col] for col in columns) for item in data]\n\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        stmt = f\"INSERT INTO {table_name} ({cols_sql}) VALUES ({placeholders})\"\n        cur.executemany(stmt, values)\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                 otherwise, returns None.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        # we assume the first non-id column is called 'name'\n        stmt = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cur.execute(stmt, (name,))\n        rows = cur.fetchall()\n        conn.close()\n        return rows if rows else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cur = conn.cursor()\n        stmt = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cur.execute(stmt, (name,))\n        conn.commit()\n        conn.close()\n```\n\nExplanation:\n\n- `create_table` uses `CREATE TABLE IF NOT EXISTS` to only define the table once, with an `id` primary key and the two user\u2011specified columns.\n- `insert_into_database` builds its INSERT statement dynamically based on the keys in the first dictionary of `data` and then `executemany` for batch insertion.\n- `search_database` looks for rows where the column named `name` matches the provided `name` parameter, returning a list of tuples or `None` if no match.\n- `delete_from_database` deletes all rows where the `name` column matches the provided value.",
      "Here\u2019s a straightforward implementation of the four methods using sqlite3. It assumes that any table you create has a column named \u201cname\u201d (your key1) and one named as key2:\n\n```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, \n    search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            c = conn.cursor()\n            sql = f\"\"\"\n                CREATE TABLE IF NOT EXISTS {table_name} (\n                  id INTEGER PRIMARY KEY,\n                  {key1} TEXT,\n                  {key2} INTEGER\n                )\n            \"\"\"\n            c.execute(sql)\n            conn.commit()\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param data: list of dicts, each dict is a row\n        \"\"\"\n        if not data:\n            return\n        # assume all dicts have the same keys\n        cols = list(data[0].keys())\n        placeholders = \",\".join(\"?\" for _ in cols)\n        col_str = \",\".join(cols)\n        values = [tuple(d[col] for col in cols) for d in data]\n\n        with sqlite3.connect(self.database_name) as conn:\n            c = conn.cursor()\n            sql = f\"INSERT INTO {table_name} ({col_str}) VALUES ({placeholders})\"\n            c.executemany(sql, values)\n            conn.commit()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        Returns list of tuples or None if no match.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            c = conn.cursor()\n            sql = f\"SELECT * FROM {table_name} WHERE name = ?\"\n            c.execute(sql, (name,))\n            rows = c.fetchall()\n        return rows if rows else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            c = conn.cursor()\n            sql = f\"DELETE FROM {table_name} WHERE name = ?\"\n            c.execute(sql, (name,))\n            conn.commit()\n```\n\nUsage example:\n\n```python\ndb = DatabaseProcessor(\"test.db\")\ndb.create_table(\"user\", \"name\", \"age\")\ndb.insert_into_database(\"user\", [{\"name\": \"John\", \"age\": 25}, {\"name\": \"Alice\", \"age\": 30}])\nprint(db.search_database(\"user\", \"John\"))   # [(1, 'John', 25)]\ndb.delete_from_database(\"user\", \"John\")\nprint(db.search_database(\"user\", \"John\"))   # None\n```"
    ]
  },
  {
    "task_id": "ClassEval_60",
    "skeleton": "import sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"",
    "test": "import unittest\nimport os\n\n\nclass MovieTicketDBTestInsertTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_insert_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_insert_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_insert_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_insert_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_insert_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')\n\n\nclass MovieTicketDBTestSearchTicketsByCustomer(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_search_tickets_by_customer_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_search_tickets_by_customer_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_search_tickets_by_customer_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_search_tickets_by_customer_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_search_tickets_by_customer_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')\n\n\nclass MovieTicketDBTestDeleteTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_delete_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 0)\n\n\nclass MovieTicketDBTest(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_MovieTicketDB(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)",
    "solution_code": "import sqlite3\n\n\nclass MovieTicketDB:\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        ''')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n",
    "class_name": "MovieTicketDB",
    "test_classes": [
      "MovieTicketDBTestInsertTicket",
      "MovieTicketDBTestSearchTicketsByCustomer",
      "MovieTicketDBTestDeleteTicket",
      "MovieTicketDBTest"
    ],
    "class_constructor": "class MovieTicketDB: \n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n",
    "fields": [
      "self.connection",
      "self.cursor"
    ],
    "methods_info": [
      {
        "method_name": "create_table",
        "method_description": "def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"",
        "test_class": "MovieTicketDBTestInsertTicket",
        "test_code": "class MovieTicketDBTestInsertTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_insert_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_insert_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_insert_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_insert_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_insert_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')",
        "solution_code": "def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        ''')\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert_ticket",
        "method_description": "def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"",
        "test_class": "MovieTicketDBTestSearchTicketsByCustomer",
        "test_code": "class MovieTicketDBTestSearchTicketsByCustomer(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_search_tickets_by_customer_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_search_tickets_by_customer_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_search_tickets_by_customer_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_search_tickets_by_customer_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_search_tickets_by_customer_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')",
        "solution_code": "def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_tickets_by_customer",
        "method_description": "def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"",
        "test_class": "MovieTicketDBTestDeleteTicket",
        "test_code": "class MovieTicketDBTestDeleteTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_delete_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 0)",
        "solution_code": "def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_ticket",
        "method_description": "def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"",
        "test_class": "MovieTicketDBTest",
        "test_code": "class MovieTicketDBTest(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_MovieTicketDB(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)",
        "solution_code": "def delete_ticket(self, ticket_id):\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "Here is a possible implementation of the MovieTicketDB class with all methods completed:\n\n```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information,\n    searching for movie information by customer name, and deleting movie information by ID.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include:\n          - id INTEGER PRIMARY KEY AUTOINCREMENT\n          - movie_name TEXT\n          - theater_name TEXT\n          - seat_number TEXT\n          - customer_name TEXT\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            SELECT id, movie_name, theater_name, seat_number, customer_name\n            FROM tickets\n            WHERE customer_name = ?\n        \"\"\", (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets\n            WHERE id = ?\n        \"\"\", (ticket_id,))\n        self.connection.commit()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the object is destroyed.\n        \"\"\"\n        self.connection.close()\n```\n\nUsage example:\n\n```python\nif __name__ == \"__main__\":\n    db = MovieTicketDB(\"ticket_database.db\")\n    db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n    tickets = db.search_tickets_by_customer(\"John Doe\")\n    print(tickets)  # e.g. [(1, 'Movie A', 'Theater 1', 'A1', 'John Doe')]\n    db.delete_ticket(tickets[0][0])\n```",
      "Here is a possible implementation filling in the four methods you described:\n\n```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information,\n    searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include:\n          - id            INTEGER PRIMARY KEY AUTOINCREMENT\n          - movie_name    TEXT\n          - theater_name  TEXT\n          - seat_number   TEXT\n          - customer_name TEXT\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        Example:\n          >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n          >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n          >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n          >>> len(result)\n          1\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets\n            WHERE customer_name = ?\n        \"\"\", (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets\n            WHERE id = ?\n        \"\"\", (ticket_id,))\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        self.connection.close()\n```\n\nExplanation:\n\n\u2022 `create_table` ensures the `tickets` table exists with the appropriate schema.  \n\u2022 `insert_ticket` uses parameterized SQL to safely insert a new record, then commits.  \n\u2022 `search_tickets_by_customer` returns all rows where `customer_name` matches.  \n\u2022 `delete_ticket` removes the row with the given `id` and commits.  \n\u2022 `close` (optional) cleanly closes the underlying SQLite connection when you\u2019re done.",
      "Here is a completed version of\u00a0MovieTicketDB. All methods are implemented as described:\n\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information,\n    searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include ID of type int, movie name of type str, theater name of type str,\n        seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            );\n        \"\"\")\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?);\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets\n            WHERE customer_name = ?;\n        \"\"\", (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets\n            WHERE id = ?;\n        \"\"\", (ticket_id,))\n        self.connection.commit()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the object is destroyed.\n        \"\"\"\n        try:\n            self.connection.close()\n        except:\n            pass\n\n# Example usage:\n# ticket_db = MovieTicketDB(\"ticket_database.db\")\n# ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n# print(ticket_db.search_tickets_by_customer(\"John Doe\"))\n# ticket_db.delete_ticket(1)",
      "Here\u2019s a complete implementation of the `MovieTicketDB` class filling in all four methods:\n\n```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information,\n    searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include ID of type int, movie name of type str, theater name of type str,\n        seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        create_stmt = \"\"\"\n        CREATE TABLE IF NOT EXISTS tickets (\n            id           INTEGER PRIMARY KEY AUTOINCREMENT,\n            movie_name   TEXT NOT NULL,\n            theater_name TEXT NOT NULL,\n            seat_number  TEXT NOT NULL,\n            customer_name TEXT NOT NULL\n        );\n        \"\"\"\n        self.cursor.execute(create_stmt)\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        insert_stmt = \"\"\"\n        INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n        VALUES (?, ?, ?, ?);\n        \"\"\"\n        self.cursor.execute(insert_stmt, (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        query = \"SELECT * FROM tickets WHERE customer_name = ?;\"\n        self.cursor.execute(query, (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        delete_stmt = \"DELETE FROM tickets WHERE id = ?;\"\n        self.cursor.execute(delete_stmt, (ticket_id,))\n        self.connection.commit()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the instance is destroyed.\n        \"\"\"\n        try:\n            self.connection.close()\n        except:\n            pass\n```\n\nUsage example:\n\n```python\nif __name__ == \"__main__\":\n    db = MovieTicketDB(\"ticket_database.db\")\n    db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n    print(db.search_tickets_by_customer(\"John Doe\"))\n    # [(1, 'Movie A', 'Theater 1', 'A1', 'John Doe')]\n    db.delete_ticket(1)\n    print(db.search_tickets_by_customer(\"John Doe\"))\n    # []\n```",
      "import sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information,\n    searching for movie information by customer name, and deleting movie information by ID.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include:\n          - id              INTEGER PRIMARY KEY AUTOINCREMENT\n          - movie_name      TEXT\n          - theater_name    TEXT\n          - seat_number     TEXT\n          - customer_name   TEXT\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n            \"\"\"\n        )\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n            \"\"\",\n            (movie_name, theater_name, seat_number, customer_name)\n        )\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT * FROM tickets WHERE customer_name = ?\",\n            (customer_name,)\n        )\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM tickets WHERE id = ?\",\n            (ticket_id,)\n        )\n        self.connection.commit()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the instance is destroyed.\n        \"\"\"\n        try:\n            self.connection.close()\n        except:\n            pass"
    ]
  },
  {
    "task_id": "ClassEval_79",
    "skeleton": "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"",
    "test": "import unittest\n\nclass SQLGeneratorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1;\")\n\n    def test_select_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1', 'field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1, field4 = value2\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1, field4 = value2;\")\n\n    def test_select_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1, field3 = value2\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1, field3 = value2;\")\n\n    def test_select_6(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'])\n        self.assertEqual(result, \"SELECT field1 FROM table1;\")\n\n\n\nclass SQLGeneratorTestInsert(unittest.TestCase):\n    def test_insert(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2) VALUES ('value1', 'value2');\")\n\n    def test_insert_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2, field3) VALUES ('value1', 'value2', 'value3');\")\n\n    def test_insert_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4) VALUES ('value1', 'value2', 'value3', 'value4');\")\n\n    def test_insert_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5) VALUES ('value1', 'value2', 'value3', 'value4', 'value5');\")\n\n    def test_insert_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5', 'field6': 'value6'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5, field6) VALUES ('value1', 'value2', 'value3', 'value4', 'value5', 'value6');\")\n\nclass SQLGeneratorTestUpdate(unittest.TestCase):\n    def test_update(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\")\n\n    def test_update_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3'},\n                            \"field4 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3' WHERE field4 = value1;\")\n\n    def test_update_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4'}, \"field5 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4' WHERE field5 = value1;\")\n\n    def test_update_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5'}, \"field6 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5' WHERE field6 = value1;\")\n\n    def test_update_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5', 'field6': 'new_value6'},\n                            \"field7 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5', field6 = 'new_value6' WHERE field7 = value1;\")\n\nclass SQLGeneratorTestDelete(unittest.TestCase):\n    def test_delete(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1;\")\n\n    def test_delete_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2;\")\n\n    def test_delete_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3;\")\n\n    def test_delete_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4;\")\n\n    def test_delete_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5;\")\n\nclass SQLGeneratorTestSelectFemaleUnderAge(unittest.TestCase):\n    def test_select_female_under_age(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\")\n\n    def test_select_female_under_age_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(40)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 40 AND gender = 'female';\")\n\n    def test_select_female_under_age_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(20)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 20 AND gender = 'female';\")\n\n    def test_select_female_under_age_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(10)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 10 AND gender = 'female';\")\n\n    def test_select_female_under_age_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(50)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 50 AND gender = 'female';\")\n\nclass SQLGeneratorTestSelectByAgeRange(unittest.TestCase):\n    def test_select_by_age_range(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(20, 30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\")\n\n    def test_select_by_age_range_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(10, 20)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 10 AND 20;\")\n\n    def test_select_by_age_range_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(30, 40)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 30 AND 40;\")\n\n    def test_select_by_age_range_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(40, 50)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 40 AND 50;\")\n\n    def test_select_by_age_range_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(50, 60)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 50 AND 60;\")\n\n\nclass SQLGeneratorTestMain(unittest.TestCase):\n    def test_main(self):\n        sql = SQLGenerator('table1')\n        self.assertEqual(sql.select(['field1', 'field2'], \"field3 = value1\"),\n                         \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n        self.assertEqual(sql.insert({'field1': 'value1', 'field2': 'value2'}),\n                         \"INSERT INTO table1 (field1, field2) VALUES ('value1', 'value2');\")\n        self.assertEqual(sql.update({'field1': 'new_value1', 'field2': 'new_value2'},\n                                    \"field3 = value1\"),\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\")\n        self.assertEqual(sql.delete(\"field1 = value1\"),\n                         \"DELETE FROM table1 WHERE field1 = value1;\")\n        self.assertEqual(sql.select_female_under_age(30),\n                         \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\")\n        self.assertEqual(sql.select_by_age_range(20, 30),\n                         \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\")",
    "solution_code": "class SQLGenerator:\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition):\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n",
    "class_name": "SQLGenerator",
    "test_classes": [
      "SQLGeneratorTestSelect",
      "SQLGeneratorTestInsert",
      "SQLGeneratorTestUpdate",
      "SQLGeneratorTestDelete",
      "SQLGeneratorTestSelectFemaleUnderAge",
      "SQLGeneratorTestSelectByAgeRange",
      "SQLGeneratorTestMain"
    ],
    "class_constructor": "class SQLGenerator: \n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n",
    "fields": [
      "self.table_name"
    ],
    "methods_info": [
      {
        "method_name": "select",
        "method_description": "def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"",
        "test_class": "SQLGeneratorTestSelect",
        "test_code": "class SQLGeneratorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1;\")\n\n    def test_select_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1', 'field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1, field4 = value2\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1, field4 = value2;\")\n\n    def test_select_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1, field3 = value2\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1, field3 = value2;\")\n\n    def test_select_6(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'])\n        self.assertEqual(result, \"SELECT field1 FROM table1;\")",
        "solution_code": "def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert",
        "method_description": "def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"",
        "test_class": "SQLGeneratorTestInsert",
        "test_code": "class SQLGeneratorTestInsert(unittest.TestCase):\n    def test_insert(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2) VALUES ('value1', 'value2');\")\n\n    def test_insert_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2, field3) VALUES ('value1', 'value2', 'value3');\")\n\n    def test_insert_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4) VALUES ('value1', 'value2', 'value3', 'value4');\")\n\n    def test_insert_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5) VALUES ('value1', 'value2', 'value3', 'value4', 'value5');\")\n\n    def test_insert_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5', 'field6': 'value6'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5, field6) VALUES ('value1', 'value2', 'value3', 'value4', 'value5', 'value6');\")",
        "solution_code": "def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "update",
        "method_description": "def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"",
        "test_class": "SQLGeneratorTestUpdate",
        "test_code": "class SQLGeneratorTestUpdate(unittest.TestCase):\n    def test_update(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\")\n\n    def test_update_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3'},\n                            \"field4 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3' WHERE field4 = value1;\")\n\n    def test_update_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4'}, \"field5 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4' WHERE field5 = value1;\")\n\n    def test_update_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5'}, \"field6 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5' WHERE field6 = value1;\")\n\n    def test_update_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5', 'field6': 'new_value6'},\n                            \"field7 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5', field6 = 'new_value6' WHERE field7 = value1;\")",
        "solution_code": "def update(self, data, condition):\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete",
        "method_description": "def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"",
        "test_class": "SQLGeneratorTestDelete",
        "test_code": "class SQLGeneratorTestDelete(unittest.TestCase):\n    def test_delete(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1;\")\n\n    def test_delete_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2;\")\n\n    def test_delete_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3;\")\n\n    def test_delete_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4;\")\n\n    def test_delete_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5;\")",
        "solution_code": "def delete(self, condition):\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "select_female_under_age",
        "method_description": "def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"",
        "test_class": "SQLGeneratorTestSelectFemaleUnderAge",
        "test_code": "class SQLGeneratorTestSelectFemaleUnderAge(unittest.TestCase):\n    def test_select_female_under_age(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\")\n\n    def test_select_female_under_age_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(40)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 40 AND gender = 'female';\")\n\n    def test_select_female_under_age_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(20)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 20 AND gender = 'female';\")\n\n    def test_select_female_under_age_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(10)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 10 AND gender = 'female';\")\n\n    def test_select_female_under_age_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(50)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 50 AND gender = 'female';\")",
        "solution_code": "def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "select"
          ]
        }
      },
      {
        "method_name": "select_by_age_range",
        "method_description": "def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"",
        "test_class": "SQLGeneratorTestSelectByAgeRange",
        "test_code": "class SQLGeneratorTestSelectByAgeRange(unittest.TestCase):\n    def test_select_by_age_range(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(20, 30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\")\n\n    def test_select_by_age_range_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(10, 20)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 10 AND 20;\")\n\n    def test_select_by_age_range_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(30, 40)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 30 AND 40;\")\n\n    def test_select_by_age_range_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(40, 50)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 40 AND 50;\")\n\n    def test_select_by_age_range_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(50, 60)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 50 AND 60;\")",
        "solution_code": "def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "select"
          ]
        }
      }
    ],
    "predict": [
      "Here\u2019s a straightforward implementation of `SQLGenerator` that handles quoting of string values, supports optional fields/conditions, and implements the two special\u2010purpose selects:\n\n```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def _quote(self, value):\n        \"\"\"\n        Quote a value if it is a string, escaping internal single quotes.\n        Numbers and other types are converted to str unchanged.\n        \"\"\"\n        if isinstance(value, str):\n            # Escape any single quotes in the string\n            escaped = value.replace(\"'\", \"''\")\n            return f\"'{escaped}'\"\n        else:\n            return str(value)\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # fields\n        if fields:\n            field_list = \", \".join(fields)\n        else:\n            field_list = \"*\"\n        sql = f\"SELECT {field_list} FROM {self.table_name}\"\n        # condition\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        keys = list(data.keys())\n        vals = [self._quote(data[k]) for k in keys]\n        fields_part = \", \".join(keys)\n        values_part = \", \".join(vals)\n        sql = f\"INSERT INTO {self.table_name} ({fields_part}) VALUES ({values_part});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        assignments = []\n        for k, v in data.items():\n            assignments.append(f\"{k} = {self._quote(v)}\")\n        set_clause = \", \".join(assignments)\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = (\n            f\"SELECT * FROM {self.table_name} \"\n            f\"WHERE age < {int(age)} AND gender = 'female';\"\n        )\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = (\n            f\"SELECT * FROM {self.table_name} \"\n            f\"WHERE age BETWEEN {int(min_age)} AND {int(max_age)};\"\n        )\n        return sql\n```\n\nExample usage:\n\n```python\nsql = SQLGenerator('table1')\nprint(sql.select(['field1', 'field2'], 'field3 = value1'))\n# -> \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\"\n\nprint(sql.insert({'key1': 'value1', 'key2': \"O'Connor\"}))\n# -> \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'O''Connor');\"\n\nprint(sql.update({'field1': 'new_value1', 'field2': 42}, \"field3 = 'x'\"))\n# -> \"UPDATE table1 SET field1 = 'new_value1', field2 = 42 WHERE field3 = 'x';\"\n\nprint(sql.delete(\"field1 = 'value1'\"))\n# -> \"DELETE FROM table1 WHERE field1 = 'value1';\"\n\nprint(sql.select_female_under_age(30))\n# -> \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n\nprint(sql.select_by_age_range(20, 30))\n# -> \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\"\n```",
      "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if fields is None or len(fields) == 0:\n            fields_sql = \"*\"\n        else:\n            fields_sql = \", \".join(fields)\n        sql = f\"SELECT {fields_sql} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        keys = \", \".join(data.keys())\n        # wrap values in single quotes\n        values = \", \".join(f\"'{v}'\" for v in data.values())\n        sql = f\"INSERT INTO {self.table_name} ({keys}) VALUES ({values});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        set_clause = \", \".join(f\"{k} = '{v}'\" for k, v in data.items())\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = (f\"SELECT * FROM {self.table_name} \"\n               f\"WHERE age < {age} AND gender = 'female';\")\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = (f\"SELECT * FROM {self.table_name} \"\n               f\"WHERE age BETWEEN {min_age} AND {max_age};\")\n        return sql",
      "Here is a possible implementation of `SQLGenerator` that meets the requirements:\n\n```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if fields is None or len(fields) == 0:\n            fields_part = \"*\"\n        else:\n            fields_part = \", \".join(fields)\n        sql = f\"SELECT {fields_part} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        keys = list(data.keys())\n        values = []\n        for v in data.values():\n            if v is None:\n                values.append(\"NULL\")\n            elif isinstance(v, (int, float)):\n                values.append(str(v))\n            else:\n                # escape single quotes in strings\n                safe = str(v).replace(\"'\", \"''\")\n                values.append(f\"'{safe}'\")\n        fields_part = \", \".join(keys)\n        values_part = \", \".join(values)\n        return f\"INSERT INTO {self.table_name} ({fields_part}) VALUES ({values_part});\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sets = []\n        for k, v in data.items():\n            if v is None:\n                val = \"NULL\"\n            elif isinstance(v, (int, float)):\n                val = str(v)\n            else:\n                safe = str(v).replace(\"'\", \"''\")\n                val = f\"'{safe}'\"\n            sets.append(f\"{k} = {val}\")\n        set_part = \", \".join(sets)\n        return f\"UPDATE {self.table_name} SET {set_part} WHERE {condition};\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"DELETE FROM {self.table_name} WHERE {condition};\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return (\n            f\"SELECT * FROM {self.table_name} \"\n            f\"WHERE age < {age} AND gender = 'female';\"\n        )\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return (\n            f\"SELECT * FROM {self.table_name} \"\n            f\"WHERE age BETWEEN {min_age} AND {max_age};\"\n        )\n```\n\nThis implementation:\n\n\u2022 Wraps string values in single quotes (and escapes any internal single quotes)  \n\u2022 Renders numeric values unquoted and represents `None` as `NULL`  \n\u2022 Defaults `SELECT` to `*` when no fields are given  \n\u2022 Always appends a terminating semicolon to each statement.",
      "Here\u2019s a simple implementation of `SQLGenerator` that fulfills all of the requirements and examples given:\n\n```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def _format_value(self, value):\n        \"\"\"\n        Helper to format a Python value as an SQL literal.\n        Strings are single\u2010quoted (with internal quotes escaped by doubling).\n        None becomes NULL; numbers remain unquoted.\n        \"\"\"\n        if value is None:\n            return \"NULL\"\n        if isinstance(value, str):\n            # escape single quotes by doubling\n            v = value.replace(\"'\", \"''\")\n            return f\"'{v}'\"\n        # for int, float, bool, etc.\n        return str(value)\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        \"\"\"\n        if fields:\n            field_list = \", \".join(fields)\n        else:\n            field_list = \"*\"\n        sql = f\"SELECT {field_list} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data for INSERT cannot be empty\")\n        cols = \", \".join(data.keys())\n        vals = \", \".join(self._format_value(v) for v in data.values())\n        return f\"INSERT INTO {self.table_name} ({cols}) VALUES ({vals});\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data for UPDATE cannot be empty\")\n        assignments = \", \".join(f\"{col} = {self._format_value(val)}\"\n                                 for col, val in data.items())\n        sql = f\"UPDATE {self.table_name} SET {assignments}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        \"\"\"\n        return (f\"SELECT * FROM {self.table_name} \"\n                f\"WHERE age < {age} AND gender = 'female';\")\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        \"\"\"\n        return (f\"SELECT * FROM {self.table_name} \"\n                f\"WHERE age BETWEEN {min_age} AND {max_age};\")\n```\n\nExamples of use:\n\n```python\nsql = SQLGenerator('table1')\n\nprint(sql.select(['field1','field2'], \"field3 = 'value1'\"))\n# -> \"SELECT field1, field2 FROM table1 WHERE field3 = 'value1';\"\n\nprint(sql.insert({'key1':'value1','key2':'value2'}))\n# -> \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n\nprint(sql.update({'f1':'v1','f2':'v2'}, \"f3 = 3\"))\n# -> \"UPDATE table1 SET f1 = 'v1', f2 = 'v2' WHERE f3 = 3;\"\n\nprint(sql.delete(\"f1 = 'abc'\"))\n# -> \"DELETE FROM table1 WHERE f1 = 'abc';\"\n\nprint(sql.select_female_under_age(30))\n# -> \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n\nprint(sql.select_by_age_range(20, 30))\n# -> \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\"\n```",
      "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def _format_value(self, value):\n        \"\"\"\n        Internal helper to format a Python value into a SQL literal.\n        Strings are single-quoted with internal quotes escaped,\n        None becomes NULL, booleans become TRUE/FALSE, numbers unquoted.\n        \"\"\"\n        if value is None:\n            return \"NULL\"\n        if isinstance(value, bool):\n            return \"TRUE\" if value else \"FALSE\"\n        if isinstance(value, (int, float)):\n            return str(value)\n        # treat everything else as string\n        s = str(value).replace(\"'\", \"''\")\n        return f\"'{s}'\"\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if fields:\n            fields_part = \", \".join(fields)\n        else:\n            fields_part = \"*\"\n        sql = f\"SELECT {fields_part} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not data:\n            raise ValueError(\"No data provided for INSERT\")\n        columns = \", \".join(data.keys())\n        values = \", \".join(self._format_value(v) for v in data.values())\n        sql = f\"INSERT INTO {self.table_name} ({columns}) VALUES ({values});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not data:\n            raise ValueError(\"No data provided for UPDATE\")\n        set_parts = []\n        for key, val in data.items():\n            set_parts.append(f\"{key} = {self._format_value(val)}\")\n        set_clause = \", \".join(set_parts)\n        sql = f\"UPDATE {self.table_name} SET {set_clause}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = (\n            f\"SELECT * FROM {self.table_name} \"\n            f\"WHERE age < {int(age)} AND gender = 'female';\"\n        )\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = (\n            f\"SELECT * FROM {self.table_name} \"\n            f\"WHERE age BETWEEN {int(min_age)} AND {int(max_age)};\"\n        )\n        return sql"
    ]
  },
  {
    "task_id": "ClassEval_80",
    "skeleton": "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"",
    "test": "import unittest\n\n\nclass SQLQueryBuilderTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\", \"name\"], {'age': 30}),\n            \"SELECT id, name FROM users WHERE age='30'\"\n        )\n\n    def test_select_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('students', [\"id\", \"name\"], {'age': 18}),\n            \"SELECT id, name FROM students WHERE age='18'\"\n        )\n\n    def test_select_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('items', [\"id\", \"name\"], {'price': 1.0}),\n            \"SELECT id, name FROM items WHERE price='1.0'\"\n        )\n\n    def test_select_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\"], {'age': 30}),\n            \"SELECT id FROM users WHERE age='30'\"\n        )\n\n    def test_select_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"], {'age': 30}),\n            \"SELECT name FROM users WHERE age='30'\"\n        )\n\n    def test_select_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"]),\n            \"SELECT name FROM users\"\n        )\n\n    def test_select_7(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', \"*\"),\n            \"SELECT * FROM users\"\n        )\n\n\nclass SQLQueryBuilderTestInsert(unittest.TestCase):\n    def test_insert_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30}),\n            \"INSERT INTO users (name, age) VALUES ('Tom', '30')\"\n        )\n\n    def test_insert_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('students', {'name': 'Tom', 'age': 18}),\n            \"INSERT INTO students (name, age) VALUES ('Tom', '18')\"\n        )\n\n    def test_insert_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('items', {'name': 'apple', 'price': 1.0}),\n            \"INSERT INTO items (name, price) VALUES ('apple', '1.0')\"\n        )\n\n    def test_insert_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom'}),\n            \"INSERT INTO users (name) VALUES ('Tom')\"\n        )\n\n    def test_insert_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30, 'region': 'USA'}),\n            \"INSERT INTO users (name, age, region) VALUES ('Tom', '30', 'USA')\"\n        )\n\n\nclass SQLQueryBuilderTestDetele(unittest.TestCase):\n    def test_delete_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('users', {'name': 'Tom'}),\n            \"DELETE FROM users WHERE name='Tom'\"\n        )\n\n    def test_delete_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('students', {'name': 'Tom'}),\n            \"DELETE FROM students WHERE name='Tom'\"\n        )\n\n    def test_delete_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'apple'}),\n            \"DELETE FROM items WHERE name='apple'\"\n        )\n\n    def test_delete_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'aaa'}),\n            \"DELETE FROM items WHERE name='aaa'\"\n        )\n\n    def test_delete_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'bbb'}),\n            \"DELETE FROM items WHERE name='bbb'\"\n        )\n\n    def test_delete_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items'),\n            \"DELETE FROM items\"\n        )\n\n\nclass SQLQueryBuilderTestUpdate(unittest.TestCase):\n    def test_update_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('users', {'age': 35}, {'name': 'Tom'}),\n            \"UPDATE users SET age='35' WHERE name='Tom'\"\n        )\n\n    def test_update_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('students', {'age': 18}, {'name': 'Tom'}),\n            \"UPDATE students SET age='18' WHERE name='Tom'\"\n        )\n\n    def test_update_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'apple'}),\n            \"UPDATE items SET price='1.0' WHERE name='apple'\"\n        )\n\n    def test_update_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'aaa'}),\n            \"UPDATE items SET price='1.0' WHERE name='aaa'\"\n        )\n\n    def test_update_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'bbb'}),\n            \"UPDATE items SET price='1.0' WHERE name='bbb'\"\n        )\n\n    def test_update_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}),\n            \"UPDATE items SET price='1.0'\"\n        )\n\n\nclass SQLQueryBuilderTestMain(unittest.TestCase):\n    def test_main(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\", \"name\"], {'age': 30}),\n            \"SELECT id, name FROM users WHERE age='30'\"\n        )\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30}),\n            \"INSERT INTO users (name, age) VALUES ('Tom', '30')\"\n        )\n        self.assertEqual(\n            SQLQueryBuilder.delete('users', {'name': 'Tom'}),\n            \"DELETE FROM users WHERE name='Tom'\"\n        )\n        self.assertEqual(\n            SQLQueryBuilder.update('users', {'age': 35}, {'name': 'Tom'}),\n            \"UPDATE users SET age='35' WHERE name='Tom'\"\n        )",
    "solution_code": "class SQLQueryBuilder:\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        if columns != '*':\n            columns = ', '.join(columns)\n        query = f\"SELECT {columns} FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        query = f\"DELETE FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        query = f\"UPDATE {table} SET {update_str}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n",
    "class_name": "SQLQueryBuilder",
    "test_classes": [
      "SQLQueryBuilderTestSelect",
      "SQLQueryBuilderTestInsert",
      "SQLQueryBuilderTestDetele",
      "SQLQueryBuilderTestUpdate",
      "SQLQueryBuilderTestMain"
    ],
    "class_constructor": "class SQLQueryBuilder: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "select",
        "method_description": "def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestSelect",
        "test_code": "class SQLQueryBuilderTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\", \"name\"], {'age': 30}),\n            \"SELECT id, name FROM users WHERE age='30'\"\n        )\n\n    def test_select_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('students', [\"id\", \"name\"], {'age': 18}),\n            \"SELECT id, name FROM students WHERE age='18'\"\n        )\n\n    def test_select_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('items', [\"id\", \"name\"], {'price': 1.0}),\n            \"SELECT id, name FROM items WHERE price='1.0'\"\n        )\n\n    def test_select_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\"], {'age': 30}),\n            \"SELECT id FROM users WHERE age='30'\"\n        )\n\n    def test_select_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"], {'age': 30}),\n            \"SELECT name FROM users WHERE age='30'\"\n        )\n\n    def test_select_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"]),\n            \"SELECT name FROM users\"\n        )\n\n    def test_select_7(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', \"*\"),\n            \"SELECT * FROM users\"\n        )",
        "solution_code": "def select(table, columns='*', where=None):\n        if columns != '*':\n            columns = ', '.join(columns)\n        query = f\"SELECT {columns} FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert",
        "method_description": "@staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestInsert",
        "test_code": "class SQLQueryBuilderTestInsert(unittest.TestCase):\n    def test_insert_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30}),\n            \"INSERT INTO users (name, age) VALUES ('Tom', '30')\"\n        )\n\n    def test_insert_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('students', {'name': 'Tom', 'age': 18}),\n            \"INSERT INTO students (name, age) VALUES ('Tom', '18')\"\n        )\n\n    def test_insert_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('items', {'name': 'apple', 'price': 1.0}),\n            \"INSERT INTO items (name, price) VALUES ('apple', '1.0')\"\n        )\n\n    def test_insert_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom'}),\n            \"INSERT INTO users (name) VALUES ('Tom')\"\n        )\n\n    def test_insert_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30, 'region': 'USA'}),\n            \"INSERT INTO users (name, age, region) VALUES ('Tom', '30', 'USA')\"\n        )",
        "solution_code": "@staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete",
        "method_description": "@staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestDetele",
        "test_code": "class SQLQueryBuilderTestDetele(unittest.TestCase):\n    def test_delete_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('users', {'name': 'Tom'}),\n            \"DELETE FROM users WHERE name='Tom'\"\n        )\n\n    def test_delete_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('students', {'name': 'Tom'}),\n            \"DELETE FROM students WHERE name='Tom'\"\n        )\n\n    def test_delete_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'apple'}),\n            \"DELETE FROM items WHERE name='apple'\"\n        )\n\n    def test_delete_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'aaa'}),\n            \"DELETE FROM items WHERE name='aaa'\"\n        )\n\n    def test_delete_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'bbb'}),\n            \"DELETE FROM items WHERE name='bbb'\"\n        )\n\n    def test_delete_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items'),\n            \"DELETE FROM items\"\n        )",
        "solution_code": "@staticmethod\n    def delete(table, where=None):\n        query = f\"DELETE FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "update",
        "method_description": "@staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestUpdate",
        "test_code": "class SQLQueryBuilderTestUpdate(unittest.TestCase):\n    def test_update_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('users', {'age': 35}, {'name': 'Tom'}),\n            \"UPDATE users SET age='35' WHERE name='Tom'\"\n        )\n\n    def test_update_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('students', {'age': 18}, {'name': 'Tom'}),\n            \"UPDATE students SET age='18' WHERE name='Tom'\"\n        )\n\n    def test_update_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'apple'}),\n            \"UPDATE items SET price='1.0' WHERE name='apple'\"\n        )\n\n    def test_update_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'aaa'}),\n            \"UPDATE items SET price='1.0' WHERE name='aaa'\"\n        )\n\n    def test_update_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'bbb'}),\n            \"UPDATE items SET price='1.0' WHERE name='bbb'\"\n        )\n\n    def test_update_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}),\n            \"UPDATE items SET price='1.0'\"\n        )",
        "solution_code": "@staticmethod\n    def update(table, data, where=None):\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        query = f\"UPDATE {table} SET {update_str}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def _quote(value):\n        \"\"\"Helper to convert a value to its SQL literal with single quotes.\"\"\"\n        return f\"'{value}'\"\n\n    @staticmethod\n    def _format_where(where):\n        \"\"\"Helper to build a WHERE clause from a dict.\"\"\"\n        if not where:\n            return ''\n        parts = []\n        for key, val in where.items():\n            parts.append(f\"{key}={SQLQueryBuilder._quote(val)}\")\n        return ' WHERE ' + ' AND '.join(parts)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or '*', ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL query statement.\n        \"\"\"\n        if isinstance(columns, list):\n            cols = ', '.join(columns)\n        else:\n            cols = columns\n        query = f\"SELECT {cols} FROM {table}\"\n        query += SQLQueryBuilder._format_where(where)\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        \"\"\"\n        keys = []\n        vals = []\n        for key, val in data.items():\n            keys.append(key)\n            vals.append(SQLQueryBuilder._quote(val))\n        cols = ', '.join(keys)\n        vals_str = ', '.join(vals)\n        query = f\"INSERT INTO {table} ({cols}) VALUES ({vals_str})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in database.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        query += SQLQueryBuilder._format_where(where)\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in database.\n        :param data: dict, the key and value in SQL update statement.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL update statement.\n        \"\"\"\n        parts = []\n        for key, val in data.items():\n            parts.append(f\"{key}={SQLQueryBuilder._quote(val)}\")\n        set_clause = ', '.join(parts)\n        query = f\"UPDATE {table} SET {set_clause}\"\n        query += SQLQueryBuilder._format_where(where)\n        return query",
      "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or str. If list, e.g. ['col1', 'col2'], otherwise '*' or a single column name.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL query statement.\n        \"\"\"\n        # Columns\n        if isinstance(columns, (list, tuple)):\n            cols = ', '.join(columns)\n        else:\n            cols = columns\n\n        query = f\"SELECT {cols} FROM {table}\"\n\n        # WHERE clause\n        if where:\n            conditions = []\n            for key, value in where.items():\n                val = str(value).replace(\"'\", \"''\")\n                conditions.append(f\"{key}='{val}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement.\n        :return: str, the SQL insert statement.\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data for INSERT cannot be empty\")\n\n        keys = []\n        vals = []\n        for key, value in data.items():\n            keys.append(key)\n            v = str(value).replace(\"'\", \"''\")\n            vals.append(f\"'{v}'\")\n\n        cols_part = ', '.join(keys)\n        vals_part = ', '.join(vals)\n        query = f\"INSERT INTO {table} ({cols_part}) VALUES ({vals_part})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in database.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            conditions = []\n            for key, value in where.items():\n                val = str(value).replace(\"'\", \"''\")\n                conditions.append(f\"{key}='{val}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in database.\n        :param data: dict, the key and value in SQL update statement.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL update statement.\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data for UPDATE cannot be empty\")\n\n        # SET clause\n        assignments = []\n        for key, value in data.items():\n            v = str(value).replace(\"'\", \"''\")\n            assignments.append(f\"{key}='{v}'\")\n        set_part = ', '.join(assignments)\n\n        query = f\"UPDATE {table} SET {set_part}\"\n\n        # WHERE clause\n        if where:\n            conditions = []\n            for key, value in where.items():\n                val = str(value).replace(\"'\", \"''\")\n                conditions.append(f\"{key}='{val}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        return query\n```\n\nExplanation of key points:\n- Columns in `select` can be a list/tuple or a simple string.\n- All values are converted to strings and single quotes inside them are escaped by doubling (`''`).\n- `where` clauses are joined by `AND`.\n- Both `insert` and `update` raise an error if the provided data dictionary is empty, since these operations require data.",
      "Here\u2019s a straightforward implementation of the requested class. All values are cast to strings and wrapped in single quotes; dictionary-based clauses are joined with AND.\n\n```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement.\n        :param table: str, the table to query.\n        :param columns: list of str or str, columns to retrieve.\n        :param where: dict, column:value pairs for the WHERE clause.\n        :return: str, the SQL query.\n        \"\"\"\n        # Format columns\n        if isinstance(columns, (list, tuple)):\n            cols = ', '.join(columns)\n        else:\n            cols = columns\n\n        query = f\"SELECT {cols} FROM {table}\"\n\n        # Add WHERE clause if needed\n        if where:\n            conditions = []\n            for k, v in where.items():\n                conditions.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement.\n        :param table: str, the table to insert into.\n        :param data: dict, column:value pairs to insert.\n        :return: str, the SQL insert statement.\n        \"\"\"\n        cols = ', '.join(data.keys())\n        vals = ', '.join(f\"'{v}'\" for v in data.values())\n        return f\"INSERT INTO {table} ({cols}) VALUES ({vals})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement.\n        :param table: str, the table to delete from.\n        :param where: dict, column:value pairs for the WHERE clause.\n        :return: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            conditions = []\n            for k, v in where.items():\n                conditions.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement.\n        :param table: str, the table to update.\n        :param data: dict, column:value pairs for the SET clause.\n        :param where: dict, column:value pairs for the WHERE clause.\n        :return: str, the SQL update statement.\n        \"\"\"\n        set_parts = []\n        for k, v in data.items():\n            set_parts.append(f\"{k}='{v}'\")\n        query = f\"UPDATE {table} SET \" + \", \".join(set_parts)\n\n        if where:\n            conditions = []\n            for k, v in where.items():\n                conditions.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        return query\n```\n\nExamples:\n\n- SQLQueryBuilder.select('users', ['id','name'], {'active':1})  \n  \u2192 `\"SELECT id, name FROM users WHERE active='1'\"`\n\n- SQLQueryBuilder.insert('users', {'name':'Alice','age':30})  \n  \u2192 `\"INSERT INTO users (name, age) VALUES ('Alice', '30')\"`\n\n- SQLQueryBuilder.delete('users', {'id':5})  \n  \u2192 `\"DELETE FROM users WHERE id='5'\"`\n\n- SQLQueryBuilder.update('users', {'name':'Bob'}, {'id':5})  \n  \u2192 `\"UPDATE users SET name='Bob' WHERE id='5'\"`",
      "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        \"\"\"\n        # columns\n        if isinstance(columns, (list, tuple)):\n            cols = ', '.join(columns)\n        else:\n            cols = columns\n        query = f\"SELECT {cols} FROM {table}\"\n        # where clause\n        if where:\n            parts = []\n            for k, v in where.items():\n                parts.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(parts)\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        \"\"\"\n        keys = []\n        vals = []\n        for k, v in data.items():\n            keys.append(k)\n            vals.append(f\"'{v}'\")\n        cols_part = \", \".join(keys)\n        vals_part = \", \".join(vals)\n        query = f\"INSERT INTO {table} ({cols_part}) VALUES ({vals_part})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            parts = []\n            for k, v in where.items():\n                parts.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(parts)\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        \"\"\"\n        # set clause\n        sets = []\n        for k, v in data.items():\n            sets.append(f\"{k}='{v}'\")\n        query = f\"UPDATE {table} SET \" + \", \".join(sets)\n        # where clause\n        if where:\n            parts = []\n            for k, v in where.items():\n                parts.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(parts)\n        return query",
      "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or '*', e.g. ['col1', 'col2'] or '*'\n        :param where: dict, e.g. {'key1': value1, 'key2': value2}\n        :return: str, the SQL query statement.\n        \"\"\"\n        # Columns\n        if isinstance(columns, (list, tuple)):\n            cols = \", \".join(columns)\n        else:\n            cols = columns\n\n        # Base query\n        query = f\"SELECT {cols} FROM {table}\"\n\n        # WHERE clause\n        if where:\n            conditions = []\n            for k, v in where.items():\n                conditions.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to insert into.\n        :param data: dict, e.g. {'col1': val1, 'col2': val2}\n        :return: str, the SQL insert statement.\n        \"\"\"\n        cols = \", \".join(data.keys())\n        vals = \", \".join(f\"'{v}'\" for v in data.values())\n        query = f\"INSERT INTO {table} ({cols}) VALUES ({vals})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table to delete from.\n        :param where: dict, e.g. {'key1': value1, 'key2': value2}\n        :return: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            conditions = []\n            for k, v in where.items():\n                conditions.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table to update.\n        :param data: dict, e.g. {'col1': val1, 'col2': val2}\n        :param where: dict, e.g. {'key1': value1, 'key2': value2}\n        :return: str, the SQL update statement.\n        \"\"\"\n        set_clauses = \", \".join(f\"{k}='{v}'\" for k, v in data.items())\n        query = f\"UPDATE {table} SET {set_clauses}\"\n        if where:\n            conditions = []\n            for k, v in where.items():\n                conditions.append(f\"{k}='{v}'\")\n            query += \" WHERE \" + \" AND \".join(conditions)\n        return query\n```\n\nExample usages:\n\n- SQLQueryBuilder.select('table1', columns=['col1','col2'], where={'age':15})\n  returns `\"SELECT col1, col2 FROM table1 WHERE age='15'\"`\n\n- SQLQueryBuilder.insert('table1', {'name':'Test', 'age':14})\n  returns `\"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"`\n\n- SQLQueryBuilder.delete('table1', {'name':'Test', 'age':14})\n  returns `\"DELETE FROM table1 WHERE name='Test' AND age='14'\"`\n\n- SQLQueryBuilder.update('table1', {'name':'Test2','age':15}, where={'name':'Test'})\n  returns `\"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"`"
    ]
  },
  {
    "task_id": "ClassEval_83",
    "skeleton": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"",
    "test": "import unittest\n\n\nclass StudentDatabaseProcessorTestInsertStudent(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_student_1(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_insert_student_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_insert_student_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_insert_student_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_insert_student_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')\n\n\nclass StudentDatabaseProcessorTestSearchStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_search_student_by_name_1(self):\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n    def test_search_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('aaa')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_search_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('bbb')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_search_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ccc')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_search_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ddd')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')\n\n\nclass StudentDatabaseProcessorTestDeleteStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_student_by_name_1(self):\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('aaa')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('bbb')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ccc')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ddd')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n\nclass StudentDatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_StudentDatabaseProcessor(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
    "solution_code": "import sqlite3\n\n\nclass StudentDatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result\n\n    def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n",
    "class_name": "StudentDatabaseProcessor",
    "test_classes": [
      "StudentDatabaseProcessorTestInsertStudent",
      "StudentDatabaseProcessorTestSearchStudentByName",
      "StudentDatabaseProcessorTestDeleteStudentByName",
      "StudentDatabaseProcessorTest"
    ],
    "class_constructor": "class StudentDatabaseProcessor: \n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n",
    "fields": [
      "self.database_name"
    ],
    "methods_info": [
      {
        "method_name": "create_student_table",
        "method_description": "def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTestInsertStudent",
        "test_code": "class StudentDatabaseProcessorTestInsertStudent(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_student_1(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_insert_student_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_insert_student_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_insert_student_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_insert_student_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')",
        "solution_code": "def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert_student",
        "method_description": "def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTestSearchStudentByName",
        "test_code": "class StudentDatabaseProcessorTestSearchStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_search_student_by_name_1(self):\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n    def test_search_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('aaa')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_search_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('bbb')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_search_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ccc')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_search_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ddd')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')",
        "solution_code": "def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_student_by_name",
        "method_description": "def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTestDeleteStudentByName",
        "test_code": "class StudentDatabaseProcessorTestDeleteStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_student_by_name_1(self):\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('aaa')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('bbb')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ccc')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ddd')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
        "solution_code": "def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_student_by_name",
        "method_description": "def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTest",
        "test_code": "class StudentDatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_StudentDatabaseProcessor(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
        "solution_code": "def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "Here is a possible implementation of the requested class:\n\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, \n    searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include ID of type int, name of type str, age of type int,\n        gender of type str, and grade of type int.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id      INTEGER PRIMARY KEY AUTOINCREMENT,\n                name    TEXT NOT NULL,\n                age     INTEGER,\n                gender  TEXT,\n                grade   INTEGER\n            )\n        \"\"\")\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's\n                             information (name, age, gender, grade).\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (:name, :age, :gender, :grade)\n        \"\"\", {\n            'name':   student_data.get('name'),\n            'age':    student_data.get('age'),\n            'gender': student_data.get('gender'),\n            'grade':  student_data.get('grade')\n        })\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table\n                 that match the search criteria.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT id, name, age, gender, grade\n            FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        results = cursor.fetchall()\n        conn.close()\n        return results\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            DELETE FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        conn.commit()\n        conn.close()",
      "Here\u2019s a possible implementation filling out all four methods using the standard `sqlite3` module. It creates a simple \u201cstudents\u201d table with an auto\u2010incrementing integer primary key and provides insert, search and delete operations by name.\n\n```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operations, including inserting student information,\n    searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include ID (int, primary key), name (str), age (int), gender (str), and grade (int)\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                age INTEGER,\n                gender TEXT,\n                grade INTEGER\n            )\n        \"\"\")\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, containing 'name', 'age', 'gender', 'grade'.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (:name, :age, :gender, :grade)\n        \"\"\", student_data)\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, rows matching the search criteria.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT id, name, age, gender, grade\n            FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        results = cursor.fetchall()\n        conn.close()\n        return results\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            DELETE FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        conn.commit()\n        conn.close()\n```\n\nExplanation of key points:\n- We use `AUTOINCREMENT` on the `id` field so SQLite will assign unique IDs automatically.\n- Every modifying operation (`CREATE`, `INSERT`, `DELETE`) is followed by `conn.commit()`.\n- Connections are explicitly closed to free resources.\n- For parameter substitution we use `?`-style placeholders (or named placeholders) to safely interpolate user data.",
      "Here is a possible implementation filling in all four methods:\n\n```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, \n    searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include ID of type int, name of type str, age of type int, \n        gender of type str, and grade of type int\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                age INTEGER,\n                gender TEXT,\n                grade INTEGER\n            )\n        \"\"\")\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information\n                             (name, age, gender, grade).\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (:name, :age, :gender, :grade)\n        \"\"\", {\n            'name': student_data['name'],\n            'age': student_data['age'],\n            'gender': student_data['gender'],\n            'grade': student_data['grade']\n        })\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT id, name, age, gender, grade\n            FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        results = cursor.fetchall()\n        conn.close()\n        return results\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            DELETE FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        conn.commit()\n        conn.close()\n```\n\nExplanation:\n\n\u2022 In `create_student_table` we use `CREATE TABLE IF NOT EXISTS` to avoid errors if the table already exists.  \n\u2022 In `insert_student`, we use named parameters (`:name`, etc.) to safely bind values from the `student_data` dictionary.  \n\u2022 In `search_student_by_name`, we use a parameterized query `(?,)` to avoid SQL injection and return all matching rows as a list of tuples.  \n\u2022 In `delete_student_by_name`, likewise we parameterize the delete statement and commit the change.",
      "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operations, including inserting student information,\n    searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include id (INTEGER PRIMARY KEY AUTOINCREMENT), name (TEXT),\n        age (INTEGER), gender (TEXT), and grade (INTEGER).\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                age INTEGER,\n                gender TEXT,\n                grade INTEGER\n            )\n        \"\"\")\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information\n                             with keys 'name', 'age', 'gender', 'grade'.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (:name, :age, :gender, :grade)\n        \"\"\", {\n            'name': student_data['name'],\n            'age': student_data['age'],\n            'gender': student_data['gender'],\n            'grade': student_data['grade']\n        })\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT id, name, age, gender, grade\n            FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        results = cursor.fetchall()\n        conn.close()\n        return results\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            DELETE FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        conn.commit()\n        conn.close()",
      "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operations, including inserting student information,\n    searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include id of type int primary key, name of type str, age of type int,\n        gender of type str, and grade of type int.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                age INTEGER,\n                gender TEXT,\n                grade INTEGER\n            )\n        \"\"\")\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information\n                             (name, age, gender, grade).\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (:name, :age, :gender, :grade)\n        \"\"\", {\n            'name': student_data.get('name'),\n            'age': student_data.get('age'),\n            'gender': student_data.get('gender'),\n            'grade': student_data.get('grade')\n        })\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT id, name, age, gender, grade\n            FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        rows = cursor.fetchall()\n        conn.close()\n        return rows\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            DELETE FROM students\n            WHERE name = ?\n        \"\"\", (name,))\n        conn.commit()\n        conn.close()"
    ]
  },
  {
    "task_id": "ClassEval_92",
    "skeleton": "class UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"",
    "test": "import unittest\nimport os\nfrom tempfile import gettempdir\n\n\nclass UserLoginDBTestInsertUser(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_insert_user_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_insert_user_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_insert_user_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_insert_user_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_insert_user_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')\n\n\nclass UserLoginDBTestSearchUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_search_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_search_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_search_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_search_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_search_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')\n\n\nclass UserLoginDBTestDeleteUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_delete_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        self.db.delete_user_by_username('user1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        self.db.delete_user_by_username('user2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        self.db.delete_user_by_username('user3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        self.db.delete_user_by_username('user4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        self.db.delete_user_by_username('user5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNone(user)\n\n\nclass UserLoginDBTestValidateUserLogin(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_validate_user_login_1(self):\n        self.db.insert_user('user1', 'pass1')\n        valid = self.db.validate_user_login('user1', 'pass1')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_2(self):\n        self.db.insert_user('user1', 'pass1')\n        invalid = self.db.validate_user_login('user1', 'wrongpass')\n        self.assertFalse(invalid)\n\n    def test_validate_user_login_3(self):\n        valid = self.db.validate_user_login('nonexistentuser', 'somepass')\n        self.assertFalse(valid)\n\n    def test_validate_user_login_4(self):\n        self.db.insert_user('user2', 'pass2')\n        valid = self.db.validate_user_login('user2', 'pass2')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_5(self):\n        self.db.insert_user('user3', 'pass3')\n        valid = self.db.validate_user_login('user3', 'pass3')\n        self.assertTrue(valid)\n\n\nclass UserLoginDBTest(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_UserLoginDB(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n        self.db.delete_user_by_username('user1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNone(user)\n        self.db.insert_user('user1', 'pass1')\n        valid = self.db.validate_user_login('user1', 'pass1')\n        self.assertTrue(valid)",
    "solution_code": "import sqlite3\n\n\nclass UserLoginDB:\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        self.cursor.execute('''\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        ''', (username, password))\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        self.cursor.execute('''\n            SELECT * FROM users WHERE username = ?\n        ''', (username,))\n        user = self.cursor.fetchone()\n        return user\n\n    def delete_user_by_username(self, username):\n        self.cursor.execute('''\n            DELETE FROM users WHERE username = ?\n        ''', (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        if user is not None and user[1] == password:\n            return True\n        return False",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n",
    "class_name": "UserLoginDB",
    "test_classes": [
      "UserLoginDBTestInsertUser",
      "UserLoginDBTestSearchUserByUsername",
      "UserLoginDBTestDeleteUserByUsername",
      "UserLoginDBTestValidateUserLogin",
      "UserLoginDBTest"
    ],
    "class_constructor": "class UserLoginDB: \n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n",
    "fields": [
      "self.connection",
      "self.cursor"
    ],
    "methods_info": [
      {
        "method_name": "insert_user",
        "method_description": "def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"",
        "test_class": "UserLoginDBTestInsertUser",
        "test_code": "class UserLoginDBTestInsertUser(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_insert_user_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_insert_user_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_insert_user_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_insert_user_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_insert_user_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')",
        "solution_code": "def insert_user(self, username, password):\n        self.cursor.execute('''\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        ''', (username, password))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_user_by_username",
        "method_description": "def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"",
        "test_class": "UserLoginDBTestSearchUserByUsername",
        "test_code": "class UserLoginDBTestSearchUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_search_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_search_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_search_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_search_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_search_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')",
        "solution_code": "def search_user_by_username(self, username):\n        self.cursor.execute('''\n            SELECT * FROM users WHERE username = ?\n        ''', (username,))\n        user = self.cursor.fetchone()\n        return user",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_user_by_username",
        "method_description": "def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"",
        "test_class": "UserLoginDBTestDeleteUserByUsername",
        "test_code": "class UserLoginDBTestDeleteUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_delete_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        self.db.delete_user_by_username('user1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        self.db.delete_user_by_username('user2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        self.db.delete_user_by_username('user3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        self.db.delete_user_by_username('user4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        self.db.delete_user_by_username('user5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNone(user)",
        "solution_code": "def delete_user_by_username(self, username):\n        self.cursor.execute('''\n            DELETE FROM users WHERE username = ?\n        ''', (username,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "validate_user_login",
        "method_description": "def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"",
        "test_class": "UserLoginDBTestValidateUserLogin",
        "test_code": "class UserLoginDBTestValidateUserLogin(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_validate_user_login_1(self):\n        self.db.insert_user('user1', 'pass1')\n        valid = self.db.validate_user_login('user1', 'pass1')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_2(self):\n        self.db.insert_user('user1', 'pass1')\n        invalid = self.db.validate_user_login('user1', 'wrongpass')\n        self.assertFalse(invalid)\n\n    def test_validate_user_login_3(self):\n        valid = self.db.validate_user_login('nonexistentuser', 'somepass')\n        self.assertFalse(valid)\n\n    def test_validate_user_login_4(self):\n        self.db.insert_user('user2', 'pass2')\n        valid = self.db.validate_user_login('user2', 'pass2')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_5(self):\n        self.db.insert_user('user3', 'pass3')\n        valid = self.db.validate_user_login('user3', 'pass3')\n        self.assertTrue(valid)",
        "solution_code": "def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        if user is not None and user[1] == password:\n            return True\n        return False",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "search_user_by_username"
          ]
        }
      }
    ],
    "predict": [
      "import sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def create_table(self):\n        \"\"\"\n        Creates the \"users\" table if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                username TEXT UNIQUE NOT NULL,\n                password TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\n                \"INSERT INTO users (username, password) VALUES (?, ?)\",\n                (username, password)\n            )\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            # Username already exists; you could raise or ignore\n            pass\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT * FROM users WHERE username = ?\",\n            (username,)\n        )\n        return self.cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM users WHERE username = ?\",\n            (username,)\n        )\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT password FROM users WHERE username = ?\",\n            (username,)\n        )\n        row = self.cursor.fetchone()\n        if row is None:\n            return False\n        stored_password = row[0]\n        return stored_password == password\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()",
      "Here is a minimal working implementation. It includes a create_table method (since your examples use it) plus the four methods you specified:\n\n```python\nimport sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information,\n    searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def create_table(self):\n        \"\"\"\n        Creates the users table if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                username TEXT PRIMARY KEY,\n                password TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\n                \"INSERT INTO users (username, password) VALUES (?, ?)\",\n                (username, password)\n            )\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            # username already exists\n            pass\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT username, password FROM users WHERE username = ?\",\n            (username,)\n        )\n        return self.cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM users WHERE username = ?\",\n            (username,)\n        )\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT password FROM users WHERE username = ?\",\n            (username,)\n        )\n        row = self.cursor.fetchone()\n        if row is None:\n            return False\n        stored_password = row[0]\n        return stored_password == password\n\n    def __del__(self):\n        \"\"\"\n        Ensure the database connection is closed when the object is destroyed.\n        \"\"\"\n        try:\n            self.connection.close()\n        except:\n            pass\n```\n\nUsage example (matches your doctests):\n\n```python\nuser_db = UserLoginDB(\"user_database.db\")\nuser_db.create_table()\nuser_db.insert_user('user1', 'pass1')\nprint(user_db.search_user_by_username('user1'))  # [('user1', 'pass1')]\nprint(user_db.validate_user_login('user1', 'pass1'))  # True\nuser_db.delete_user_by_username('user1')\nprint(user_db.search_user_by_username('user1'))  # []\n```",
      "import sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information,\n    searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def create_table(self):\n        \"\"\"\n        Creates the \"users\" table if it does not already exist.\n        Columns:\n          - id: integer primary key autoincrement\n          - username: text, unique, not null\n          - password: text, not null\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                username TEXT UNIQUE NOT NULL,\n                password TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\n            (username, password)\n        )\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        1\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT id, username, password FROM users WHERE username = ?\",\n            (username,)\n        )\n        return self.cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM users WHERE username = ?\",\n            (username,)\n        )\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT password FROM users WHERE username = ?\",\n            (username,)\n        )\n        row = self.cursor.fetchone()\n        if row and row[0] == password:\n            return True\n        return False\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()",
      "Here\u2019s a possible full implementation, including a `create_table` method to match your examples:\n\n```python\nimport sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for\n    inserting user information, searching user information, deleting user information, and\n    validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def create_table(self):\n        \"\"\"\n        Creates the \"users\" table if it doesn't already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id       INTEGER PRIMARY KEY AUTOINCREMENT,\n                username TEXT    UNIQUE NOT NULL,\n                password TEXT    NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\n                \"INSERT INTO users (username, password) VALUES (?, ?)\",\n                (username, password)\n            )\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            # username already exists\n            pass\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT * FROM users WHERE username = ?\",\n            (username,)\n        )\n        return self.cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM users WHERE username = ?\",\n            (username,)\n        )\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and\n        the password is correct.\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT password FROM users WHERE username = ?\",\n            (username,)\n        )\n        row = self.cursor.fetchone()\n        if row and row[0] == password:\n            return True\n        return False\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n```\n\nUsage example:\n\n```python\nuser_db = UserLoginDB(\"user_database.db\")\nuser_db.create_table()\nuser_db.insert_user(\"user1\", \"pass1\")\nprint(user_db.search_user_by_username(\"user1\"))   # [(1, 'user1', 'pass1')]\nprint(user_db.validate_user_login(\"user1\", \"pass1\"))  # True\nuser_db.delete_user_by_username(\"user1\")\nprint(user_db.search_user_by_username(\"user1\"))   # []\nuser_db.close()\n```",
      "import sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions\n    for inserting user information, searching user information, deleting user information,\n    and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it does not already exist.\n        The table has two columns:\n          - username: TEXT, primary key\n          - password: TEXT\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                username TEXT PRIMARY KEY,\n                password TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\n                \"INSERT INTO users (username, password) VALUES (?, ?)\",\n                (username, password)\n            )\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            # Username already exists\n            pass\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT username, password FROM users WHERE username = ?\",\n            (username,)\n        )\n        return self.cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\n            \"DELETE FROM users WHERE username = ?\",\n            (username,)\n        )\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database\n        and the password is correct.\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly.\n        \"\"\"\n        self.cursor.execute(\n            \"SELECT password FROM users WHERE username = ?\",\n            (username,)\n        )\n        row = self.cursor.fetchone()\n        return (row is not None) and (row[0] == password)\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        self.connection.close()"
    ]
  }
]