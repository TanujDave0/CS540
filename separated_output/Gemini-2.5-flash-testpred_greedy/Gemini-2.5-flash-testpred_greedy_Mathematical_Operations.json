[
  {
    "task_id": "ClassEval_1",
    "skeleton": "import math\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"",
    "test": "import unittest\n\nclass AreaCalculatorTestCalculateCircleArea(unittest.TestCase):\n    def test_calculate_circle_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_circle_area(), delta=0.01)\n    def test_calculate_circle_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateSphereArea(unittest.TestCase):\n    def test_calculate_sphere_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateCylinderArea(unittest.TestCase):\n    def test_calculate_cylinder_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_cylinder_area(0), delta=0.01)\n\n    def test_calculate_cylinder_area_3(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_cylinder_area(2000), delta=0.01)\n\n    def test_calculate_cylinder_area_4(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(70.68, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(62.83, areaCalculator.calculate_cylinder_area(1.5), delta=0.01)\n\nclass AreaCalculatorTestCalculateSectorArea(unittest.TestCase):\n    def test_calculate_sector_area(self):\n        areaCalculator = AreaCalculator(1.5)\n        self.assertAlmostEqual(3.53, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\n    def test_calculate_sector_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_sector_area(math.pi/2), delta=0.01)\n\n    def test_calculate_sector_area_3(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(0), delta=0.01)\n\n    def test_calculate_sector_area_4(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_sector_area(2*math.pi), delta=0.01)\n\n    def test5_calculate_sector_area_5(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\nclass AreaCalculatorTestCalculateAnnulusArea(unittest.TestCase):\n    def test_calculate_annulus_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.128, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(0, areaCalculator.calculate_annulus_area(3, 3), delta=0.01)\n\n    def test_calculate_annulus_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_annulus_area(0, 1), delta=0.01)\n\n    def test_calculate_annulus_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\nclass AreaCalculatorTestCalculateMain(unittest.TestCase):\n    def test_main(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_circle_area(), delta=0.01)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n        self.assertAlmostEqual(6.28, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n        self.assertAlmostEqual(25.128, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)",
    "solution_code": "import math\n\n\nclass AreaCalculator:\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",
    "import_statement": [
      "import math"
    ],
    "class_description": "    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n",
    "class_name": "AreaCalculator",
    "test_classes": [
      "AreaCalculatorTestCalculateCircleArea",
      "AreaCalculatorTestCalculateSphereArea",
      "AreaCalculatorTestCalculateCylinderArea",
      "AreaCalculatorTestCalculateSectorArea",
      "AreaCalculatorTestCalculateAnnulusArea",
      "AreaCalculatorTestCalculateMain"
    ],
    "class_constructor": "class AreaCalculator: \n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n",
    "fields": [
      "self.radius"
    ],
    "methods_info": [
      {
        "method_name": "calculate_circle_area",
        "method_description": "def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"",
        "test_class": "AreaCalculatorTestCalculateCircleArea",
        "test_code": "class AreaCalculatorTestCalculateCircleArea(unittest.TestCase):\n    def test_calculate_circle_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_circle_area(), delta=0.01)\n    def test_calculate_circle_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)",
        "solution_code": "def calculate_circle_area(self):\n        return math.pi * self.radius ** 2",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [
            "self.radius"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "calculate_sphere_area",
        "method_description": "def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"",
        "test_class": "AreaCalculatorTestCalculateSphereArea",
        "test_code": "class AreaCalculatorTestCalculateSphereArea(unittest.TestCase):\n    def test_calculate_sphere_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)",
        "solution_code": "def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius ** 2",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [
            "self.radius"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "calculate_cylinder_area",
        "method_description": "def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"",
        "test_class": "AreaCalculatorTestCalculateCylinderArea",
        "test_code": "class AreaCalculatorTestCalculateCylinderArea(unittest.TestCase):\n    def test_calculate_cylinder_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_cylinder_area(0), delta=0.01)\n\n    def test_calculate_cylinder_area_3(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_cylinder_area(2000), delta=0.01)\n\n    def test_calculate_cylinder_area_4(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(70.68, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(62.83, areaCalculator.calculate_cylinder_area(1.5), delta=0.01)",
        "solution_code": "def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [
            "self.radius"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "calculate_sector_area",
        "method_description": "def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"",
        "test_class": "AreaCalculatorTestCalculateSectorArea",
        "test_code": "class AreaCalculatorTestCalculateSectorArea(unittest.TestCase):\n    def test_calculate_sector_area(self):\n        areaCalculator = AreaCalculator(1.5)\n        self.assertAlmostEqual(3.53, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\n    def test_calculate_sector_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_sector_area(math.pi/2), delta=0.01)\n\n    def test_calculate_sector_area_3(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(0), delta=0.01)\n\n    def test_calculate_sector_area_4(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_sector_area(2*math.pi), delta=0.01)\n\n    def test5_calculate_sector_area_5(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(math.pi), delta=0.01)",
        "solution_code": "def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.radius"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "calculate_annulus_area",
        "method_description": "def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"",
        "test_class": "AreaCalculatorTestCalculateAnnulusArea",
        "test_code": "class AreaCalculatorTestCalculateAnnulusArea(unittest.TestCase):\n    def test_calculate_annulus_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.128, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(0, areaCalculator.calculate_annulus_area(3, 3), delta=0.01)\n\n    def test_calculate_annulus_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_annulus_area(0, 1), delta=0.01)\n\n    def test_calculate_annulus_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)",
        "solution_code": "def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport math\n\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        if not isinstance(radius, (int, float)):\n            raise TypeError(\"Radius must be a number.\")\n        if radius < 0:\n            raise ValueError(\"Radius must be a non-negative number.\")\n        self.radius = float(radius)\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        return math.pi * self.radius**2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        # Surface area of a sphere\n        return 4 * math.pi * self.radius**2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the *total surface* area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: total surface area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        if not isinstance(height, (int, float)):\n            raise TypeError(\"Height must be a number.\")\n        if height < 0:\n            raise ValueError(\"Height must be a non-negative number.\")\n\n        # Total surface area = 2 * (Area of base circle) + (Area of lateral surface)\n        # Area of base circle = pi * r^2\n        # Area of lateral surface = 2 * pi * r * h\n        base_area = math.pi * self.radius**2\n        lateral_area = 2 * math.pi * self.radius * height\n        return 2 * base_area + lateral_area\n\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle (in radians)\n        :param angle: angle of sector (in radians), float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi) # Half circle\n        6.283185307179586\n        >>> areaCalculator.calculate_sector_area(2 * math.pi) # Full circle\n        12.566370614359172\n        \"\"\"\n        if not isinstance(angle, (int, float)):\n            raise TypeError(\"Angle must be a number.\")\n        if angle < 0:\n            raise ValueError(\"Angle must be a non-negative number.\")\n\n        # Area of sector = (angle / (2 * pi)) * (Area of circle)\n        # Area of circle = pi * r^2\n        # So, Area of sector = (angle / (2 * pi)) * (pi * r^2) = (angle / 2) * r^2\n        # However, using the ratio of the angle to the full circle angle (2*pi) is clearer\n        if angle == 0: return 0.0 # Handle zero angle specifically\n        return (angle / (2 * math.pi)) * (math.pi * self.radius**2)\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        Note: The radius used to initialize the class (self.radius) is not used in this calculation.\n        :param inner_radius: inner radius of annulus, float\n        :param outer_radius: outer radius of annulus, float\n        :return: area of annulus, float\n        >>> # Note: The radius used for AreaCalculator(100) doesn't affect this calculation\n        >>> areaCalculator = AreaCalculator(100)\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"\n        if not isinstance(inner_radius, (int, float)):\n            raise TypeError(\"Inner radius must be a number.\")\n        if not isinstance(outer_radius, (int, float)):\n             raise TypeError(\"Outer radius must be a number.\")\n        if inner_radius < 0 or outer_radius < 0:\n             raise ValueError(\"Radii must be non-negative numbers.\")\n        if inner_radius >= outer_radius:\n             raise ValueError(\"Inner radius must be less than outer radius.\")\n\n        # Area of annulus = Area of outer circle - Area of inner circle\n        # Area = pi * R_outer^2 - pi * R_inner^2 = pi * (R_outer^2 - R_inner^2)\n        return math.pi * (outer_radius**2 - inner_radius**2)\n\n# Example usage (optional, for demonstration)\nif __name__ == '__main__':\n    try:\n        calc = AreaCalculator(5)\n        print(f\"Circle Area (radius 5): {calc.calculate_circle_area()}\")\n        print(f\"Sphere Area (radius 5): {calc.calculate_sphere_area()}\")\n        print(f\"Cylinder Area (radius 5, height 10): {calc.calculate_cylinder_area(10)}\")\n        print(f\"Sector Area (radius 5, angle pi/2): {calc.calculate_sector_area(math.pi / 2)}\")\n        print(f\"Annulus Area (inner 2, outer 7): {calc.calculate_annulus_area(2, 7)}\")\n\n        # Example from doctest\n        calc_doctest = AreaCalculator(2)\n        print(f\"\\nDoctest Circle Area (radius 2): {calc_doctest.calculate_circle_area()}\")\n        print(f\"Doctest Sphere Area (radius 2): {calc_doctest.calculate_sphere_area()}\")\n        print(f\"Doctest Cylinder Area (radius 2, height 3): {calc_doctest.calculate_cylinder_area(3)}\")\n        print(f\"Doctest Sector Area (radius 2, angle pi): {calc_doctest.calculate_sector_area(math.pi)}\")\n        calc_annulus_doctest = AreaCalculator(100) # constructor radius is irrelevant for annulus\n        print(f\"Doctest Annulus Area (inner 2, outer 3): {calc_annulus_doctest.calculate_annulus_area(2, 3)}\")\n\n    except (TypeError, ValueError) as e:\n        print(f\"Error: {e}\")\n\n    # Example of invalid input\n    try:\n        invalid_calc = AreaCalculator(-5)\n    except (TypeError, ValueError) as e:\n        print(f\"\\nCaught expected error for AreaCalculator(-5): {e}\")\n\n    try:\n        calc = AreaCalculator(5)\n        calc.calculate_cylinder_area(-1)\n    except (TypeError, ValueError) as e:\n        print(f\"Caught expected error for calculate_cylinder_area(-1): {e}\")\n\n    try:\n        calc = AreaCalculator(5)\n        calc.calculate_annulus_area(5, 3)\n    except (TypeError, ValueError) as e:\n        print(f\"Caught expected error for calculate_annulus_area(5, 3): {e}\")\n\n    # You can also run doctests directly\n    # import doctest\n    # doctest.testmod()\n```"
    ]
  },
  {
    "task_id": "ClassEval_3",
    "skeleton": "import itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"",
    "test": "import unittest\n\n\nclass ArrangementCalculatorTestCount(unittest.TestCase):\n    def test_count_1(self):\n        res = ArrangementCalculator.count(5, 3)\n        self.assertEqual(res, 60)\n\n    def test_count_2(self):\n        res = ArrangementCalculator.count(4, 3)\n        self.assertEqual(res, 24)\n\n    def test_count_3(self):\n        res = ArrangementCalculator.count(6, 3)\n        self.assertEqual(res, 120)\n\n    def test_count_4(self):\n        res = ArrangementCalculator.count(7, 3)\n        self.assertEqual(res, 210)\n\n    def test_count_5(self):\n        res = ArrangementCalculator.count(4, 4)\n        self.assertEqual(res, 24)\n\n\nclass ArrangementCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all_1(self):\n        res = ArrangementCalculator.count_all(4)\n        self.assertEqual(res, 64)\n\n    def test_count_all_2(self):\n        res = ArrangementCalculator.count_all(1)\n        self.assertEqual(res, 1)\n\n    def test_count_all_3(self):\n        res = ArrangementCalculator.count_all(2)\n        self.assertEqual(res, 4)\n\n    def test_count_all_4(self):\n        res = ArrangementCalculator.count_all(3)\n        self.assertEqual(res, 15)\n\n    def test_count_all_5(self):\n        res = ArrangementCalculator.count_all(5)\n        self.assertEqual(res, 325)\n\n\nclass ArrangementCalculatorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_2(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\n        self.assertEqual(res, expected)\n\n    def test_select_3(self):\n        ac = ArrangementCalculator([2, 3, 4])\n        res = ac.select(2)\n        expected = [[2, 3], [2, 4], [3, 2], [3, 4], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_4(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select(2)\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_5(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(1)\n        expected = [[1], [2], [3], [4]]\n        self.assertEqual(res, expected)\n\n    def test_select_6(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select()\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n\nclass ArrangementCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all_1(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select_all()\n        expected = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3],\n                    [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_2(self):\n        ac = ArrangementCalculator([1, 2, 4])\n        res = ac.select_all()\n        expected = [[1], [2], [4], [1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2], [1, 2, 4], [1, 4, 2], [2, 1, 4],\n                    [2, 4, 1], [4, 1, 2], [4, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_3(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select_all()\n        expected = [[1], [2], [1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_4(self):\n        ac = ArrangementCalculator([1, 3])\n        res = ac.select_all()\n        expected = [[1], [3], [1, 3], [3, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_5(self):\n        ac = ArrangementCalculator([1])\n        res = ac.select_all()\n        expected = [[1]]\n        self.assertEqual(res, expected)\n\n\nclass ArrangementCalculatorTestFactorial(unittest.TestCase):\n    def test_factorial_1(self):\n        res = ArrangementCalculator.factorial(4)\n        self.assertEqual(res, 24)\n\n    def test_factorial_2(self):\n        res = ArrangementCalculator.factorial(5)\n        self.assertEqual(res, 120)\n\n    def test_factorial_3(self):\n        res = ArrangementCalculator.factorial(3)\n        self.assertEqual(res, 6)\n\n    def test_factorial_4(self):\n        res = ArrangementCalculator.factorial(2)\n        self.assertEqual(res, 2)\n\n    def test_factorial_5(self):\n        res = ArrangementCalculator.factorial(1)\n        self.assertEqual(res, 1)\n\n\nclass ArrangementCalculatorTest(unittest.TestCase):\n    def test_arrangementcalculator(self):\n        res = ArrangementCalculator.count(5, 3)\n        self.assertEqual(res, 60)\n\n        res = ArrangementCalculator.count_all(4)\n        self.assertEqual(res, 64)\n\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select_all()\n        expected = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3],\n                    [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        self.assertEqual(res, expected)\n\n        res = ArrangementCalculator.factorial(4)\n        self.assertEqual(res, 24)",
    "solution_code": "import itertools\n\n\nclass ArrangementCalculator:\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result\n\n    def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    @staticmethod\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result",
    "import_statement": [
      "import itertools"
    ],
    "class_description": "    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n",
    "class_name": "ArrangementCalculator",
    "test_classes": [
      "ArrangementCalculatorTestCount",
      "ArrangementCalculatorTestCountAll",
      "ArrangementCalculatorTestSelect",
      "ArrangementCalculatorTestSelectAll",
      "ArrangementCalculatorTestFactorial",
      "ArrangementCalculatorTest"
    ],
    "class_constructor": "class ArrangementCalculator: \n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n",
    "fields": [
      "self.datas"
    ],
    "methods_info": [
      {
        "method_name": "count",
        "method_description": "def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"",
        "test_class": "ArrangementCalculatorTestCount",
        "test_code": "class ArrangementCalculatorTestCount(unittest.TestCase):\n    def test_count_1(self):\n        res = ArrangementCalculator.count(5, 3)\n        self.assertEqual(res, 60)\n\n    def test_count_2(self):\n        res = ArrangementCalculator.count(4, 3)\n        self.assertEqual(res, 24)\n\n    def test_count_3(self):\n        res = ArrangementCalculator.count(6, 3)\n        self.assertEqual(res, 120)\n\n    def test_count_4(self):\n        res = ArrangementCalculator.count(7, 3)\n        self.assertEqual(res, 210)\n\n    def test_count_5(self):\n        res = ArrangementCalculator.count(4, 4)\n        self.assertEqual(res, 24)",
        "solution_code": "def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "factorial"
          ]
        }
      },
      {
        "method_name": "count_all",
        "method_description": "@staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"",
        "test_class": "ArrangementCalculatorTestCountAll",
        "test_code": "class ArrangementCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all_1(self):\n        res = ArrangementCalculator.count_all(4)\n        self.assertEqual(res, 64)\n\n    def test_count_all_2(self):\n        res = ArrangementCalculator.count_all(1)\n        self.assertEqual(res, 1)\n\n    def test_count_all_3(self):\n        res = ArrangementCalculator.count_all(2)\n        self.assertEqual(res, 4)\n\n    def test_count_all_4(self):\n        res = ArrangementCalculator.count_all(3)\n        self.assertEqual(res, 15)\n\n    def test_count_all_5(self):\n        res = ArrangementCalculator.count_all(5)\n        self.assertEqual(res, 325)",
        "solution_code": "@staticmethod\n    def count_all(n):\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "count"
          ]
        }
      },
      {
        "method_name": "select",
        "method_description": "def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"",
        "test_class": "ArrangementCalculatorTestSelect",
        "test_code": "class ArrangementCalculatorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_2(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\n        self.assertEqual(res, expected)\n\n    def test_select_3(self):\n        ac = ArrangementCalculator([2, 3, 4])\n        res = ac.select(2)\n        expected = [[2, 3], [2, 4], [3, 2], [3, 4], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_4(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select(2)\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_5(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(1)\n        expected = [[1], [2], [3], [4]]\n        self.assertEqual(res, expected)\n\n    def test_select_6(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select()\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)",
        "solution_code": "def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "itertools"
          ],
          "field_dependencies": [
            "self.datas"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "select_all",
        "method_description": "def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"",
        "test_class": "ArrangementCalculatorTestSelectAll",
        "test_code": "class ArrangementCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all_1(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select_all()\n        expected = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3],\n                    [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_2(self):\n        ac = ArrangementCalculator([1, 2, 4])\n        res = ac.select_all()\n        expected = [[1], [2], [4], [1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2], [1, 2, 4], [1, 4, 2], [2, 1, 4],\n                    [2, 4, 1], [4, 1, 2], [4, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_3(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select_all()\n        expected = [[1], [2], [1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_4(self):\n        ac = ArrangementCalculator([1, 3])\n        res = ac.select_all()\n        expected = [[1], [3], [1, 3], [3, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_5(self):\n        ac = ArrangementCalculator([1])\n        res = ac.select_all()\n        expected = [[1]]\n        self.assertEqual(res, expected)",
        "solution_code": "def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.datas"
          ],
          "method_dependencies": [
            "select"
          ]
        }
      },
      {
        "method_name": "factorial",
        "method_description": "@staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"",
        "test_class": "ArrangementCalculatorTestFactorial",
        "test_code": "class ArrangementCalculatorTestFactorial(unittest.TestCase):\n    def test_factorial_1(self):\n        res = ArrangementCalculator.factorial(4)\n        self.assertEqual(res, 24)\n\n    def test_factorial_2(self):\n        res = ArrangementCalculator.factorial(5)\n        self.assertEqual(res, 120)\n\n    def test_factorial_3(self):\n        res = ArrangementCalculator.factorial(3)\n        self.assertEqual(res, 6)\n\n    def test_factorial_4(self):\n        res = ArrangementCalculator.factorial(2)\n        self.assertEqual(res, 2)\n\n    def test_factorial_5(self):\n        res = ArrangementCalculator.factorial(1)\n        self.assertEqual(res, 1)",
        "solution_code": "@staticmethod\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport itertools\nimport math # Import math for potential future use or verification, though manual factorial is implemented.\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        # It's good practice to store a copy to prevent external modification\n        self.datas = list(datas)\n\n    @staticmethod\n    def factorial(n: int) -> int:\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial. Must be a non-negative integer.\n        :return: int, the factorial of the given number.\n        :raises ValueError: If n is a negative integer or not an integer.\n        >>> ArrangementCalculator.factorial(4)\n        24\n        >>> ArrangementCalculator.factorial(0)\n        1\n        >>> ArrangementCalculator.factorial(1)\n        1\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n            raise ValueError(\"Factorial is only defined for non-negative integers\")\n        if n == 0:\n            return 1\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result\n\n    @staticmethod\n    def count(n: int, m: int = None) -> int:\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items. Must be a non-negative integer.\n        :param m: int, the number of items to be chosen (default=None). Must be a non-negative integer.\n        :return: int, the count of arrangements.\n        :raises ValueError: If n or m are negative integers.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n        >>> ArrangementCalculator.count(4, 2)\n        12\n        >>> ArrangementCalculator.count(5) # m defaults to n\n        120\n        >>> ArrangementCalculator.count(5, 5)\n        120\n        >>> ArrangementCalculator.count(3, 0)\n        1\n        >>> ArrangementCalculator.count(0, 0)\n        1\n        >>> ArrangementCalculator.count(3, 4) # m > n\n        0\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n            raise ValueError(\"n must be a non-negative integer\")\n\n        # If m is None, default to n\n        if m is None:\n            m = n\n\n        if not isinstance(m, int) or m < 0:\n             raise ValueError(\"m must be a non-negative integer\")\n\n        # If m > n, no permutations are possible\n        if m > n:\n            return 0\n\n        # P(n, m) = n! / (n-m)!\n        # Use the factorial method implemented in this class\n        numerator = ArrangementCalculator.factorial(n)\n        denominator = ArrangementCalculator.factorial(n - m)\n\n        # Integer division is appropriate here\n        return numerator // denominator\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        This is the sum of P(n, 1) + P(n, 2) + ... + P(n, n).\n        :param n: int, the total number of items. Must be a non-negative integer.\n        :return: int, the count of all arrangements.\n        :raises ValueError: If n is a negative integer.\n        >>> ArrangementCalculator.count_all(4)\n        64\n        >>> ArrangementCalculator.count_all(0)\n        0\n        >>> ArrangementCalculator.count_all(1)\n        1\n        >>> ArrangementCalculator.count_all(2)\n        4\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n             raise ValueError(\"n must be a non-negative integer\")\n\n        if n == 0:\n            return 0 # No items to choose from (range 1 to 0 is empty)\n\n        total_count = 0\n        # Sum P(n, m) for m from 1 to n\n        for m in range(1, n + 1):\n            total_count += ArrangementCalculator.count(n, m)\n        return total_count\n\n    def select(self, m: int = None) -> list:\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items (m = len(self.datas)).\n        Uses itertools.permutations internally.\n        :param m: int, the number of items to be chosen (default=None). Must be a non-negative integer.\n        :return: List, a list of arrangements (each arrangement is a list).\n        :raises ValueError: If m is a negative integer.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> result_select_2 = ac.select(2)\n        >>> expected_select_2 = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        >>> sorted(result_select_2) == sorted(expected_select_2)\n        True\n        >>> ac.select(0)\n        [[]]\n        >>> ac_empty = ArrangementCalculator([])\n        >>> ac_empty.select()\n        [[]]\n        >>> ac_empty.select(1)\n        []\n        \"\"\"\n        if m is not None and (not isinstance(m, int) or m < 0):\n             raise ValueError(\"m must be a non-negative integer or None\")\n\n        # itertools.permutations handles m=None (defaults to len(iterable))\n        # itertools.permutations handles m=0 (yields one empty tuple)\n        # itertools.permutations handles m > len(iterable) (yields nothing)\n\n        # Use itertools.permutations to generate the arrangements\n        perms_iterator = itertools.permutations(self.datas, m)\n\n        # Convert the iterator of tuples into a list of lists\n        return [list(p) for p in perms_iterator]\n\n    def select_all(self) -> list:\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        This is the union of select(m) for m from 1 to len(self.datas).\n        :return: List, a list of all arrangements (each arrangement is a list).\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> result_select_all = ac.select_all()\n        >>> expected_select_all = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        >>> sorted(result_select_all) == sorted(expected_select_all)\n        True\n        >>> ac_empty = ArrangementCalculator([])\n        >>> ac_empty.select_all()\n        []\n        \"\"\"\n        all_arrangements = []\n        n = len(self.datas)\n\n        # Generate permutations for each possible size m from 1 to n\n        # Note: range(1, n + 1) is empty if n is 0, correctly handling empty input list\n        for m in range(1, n + 1):\n            # Use the select method implemented in this class\n            arrangements_for_m = self.select(m)\n            all_arrangements.extend(arrangements_for_m)\n\n        return all_arrangements\n\n# Example usage (optional, can be removed or wrapped in if __name__ == \"__main__\":)\n# if __name__ == \"__main__\":\n#     # Test factorial\n#     print(f\"Factorial of 4: {ArrangementCalculator.factorial(4)}\")\n#     print(f\"Factorial of 0: {ArrangementCalculator.factorial(0)}\")\n#\n#     # Test count\n#     print(f\"Count P(5, 3): {ArrangementCalculator.count(5, 3)}\")\n#     print(f\"Count P(4, 2): {ArrangementCalculator.count(4, 2)}\")\n#     print(f\"Count P(5, 5): {ArrangementCalculator.count(5, 5)}\")\n#     print(f\"Count P(5): {ArrangementCalculator.count(5)}\") # m=None -> m=n\n#     print(f\"Count P(3, 4): {ArrangementCalculator.count(3, 4)}\") # m > n\n#     print(f\"Count P(0, 0): {ArrangementCalculator.count(0, 0)}\")\n#\n#     # Test count_all\n#     print(f\"Count all for n=4: {ArrangementCalculator.count_all(4)}\")\n#     print(f\"Count all for n=3: {ArrangementCalculator.count_all(3)}\")\n#     print(f\"Count all for n=0: {ArrangementCalculator.count_all(0)}\")\n#\n#     # Test select\n#     ac_select = ArrangementCalculator([1, 2, 3, 4])\n#     print(f\"Select 2 from [1, 2, 3, 4]: {ac_select.select(2)}\")\n#     print(f\"Select all from [1, 2, 3]: {ArrangementCalculator([1, 2, 3]).select()}\") # m=None\n#     print(f\"Select 0 from [1, 2, 3]: {ArrangementCalculator([1, 2, 3]).select(0)}\")\n#     print(f\"Select 5 from [1, 2, 3]: {ArrangementCalculator([1, 2, 3]).select(5)}\") # m > len(datas)\n#\n#     # Test select_all\n#     ac_select_all = ArrangementCalculator([1, 2, 3])\n#     print(f\"Select all from [1, 2, 3]: {ac_select_all.select_all()}\")\n#     ac_select_all_empty = ArrangementCalculator([])\n#     print(f\"Select all from []: {ac_select_all_empty.select_all()}\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_9",
    "skeleton": "class BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    \"\"\"\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add,str.\n        :param num2: The second number to add,str.\n        :return: The sum of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n\n        \"\"\"\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract,str.\n        :param num2: The second number to subtract,str.\n        :return: The difference of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n\n        \"\"\"\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply,str.\n        :param num2: The second number to multiply,str.\n        :return: The product of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n\n        \"\"\"",
    "test": "import unittest\n\nclass BigNumCalculatorTestAdd(unittest.TestCase):\n    def test_add(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n\n    def test_add_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678922\", \"98765432109876543210\"), \"222222221122222222132\")\n\n    def test_add_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678934\", \"98765432109876543210\"), \"222222221122222222144\")\n\n    def test_add_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678946\", \"98765432109876543210\"), \"222222221122222222156\")\n\n    def test_add_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678958\", \"98765432109876543210\"), \"222222221122222222168\")\n\nclass BigNumCalculatorTestSubtract(unittest.TestCase):\n    def test_subtract(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n\n    def test_subtract_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"123456789012345678922\", \"98765432109876543210\"), \"24691356902469135712\")\n\n    def test_subtract_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"123456789012345678934\", \"98765432109876543\"), \"123358023580235802391\")\n\n    def test_subtract_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"12345678901234567\", \"98765432109876543210\"), \"-98753086430975308643\")\n\n    def test_subtract_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"923456789\", \"187654321\"), \"735802468\")\n\nclass BigNumCalculatorTestMultiply(unittest.TestCase):\n    def test_multiply(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")\n\n    def test_multiply_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"123456789012345678922\", \"98765432109876543210\"), \"12193263113702179524547477517529919219620\")\n\n    def test_multiply_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"123456789012345678934\", \"98765432109876543\"), \"12193263113702179499806737010255845162\")\n\n    def test_multiply_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"12345678901234567\", \"98765432109876543210\"), \"1219326311370217864336229223321140070\")\n\n    def test_multiply_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"923456789\", \"187654321\"), \"173290656712635269\")\n\n    def test_multiply_6(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"000000001\", \"000000001\"), \"1\")\n\nclass BigNumCalculatorTestMain(unittest.TestCase):\n    def test_main(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n        self.assertEqual(bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n        self.assertEqual(bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")",
    "solution_code": "class BigNumCalculator:\n    @staticmethod\n    def add(num1, num2):\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n\n        if carry > 0:\n            result.insert(0, str(carry))\n\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n\n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        else:\n            if num1 < num2:\n                num1, num2 = num2, num1\n                negative = True\n            else:\n                negative = False\n\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.insert(0, str(digit_diff))\n\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n\n        if negative:\n            result.insert(0, '-')\n\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n\n        return ''.join(map(str, result[start:]))",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    \"\"\"\n",
    "class_name": "BigNumCalculator",
    "test_classes": [
      "BigNumCalculatorTestAdd",
      "BigNumCalculatorTestSubtract",
      "BigNumCalculatorTestMultiply",
      "BigNumCalculatorTestMain"
    ],
    "class_constructor": "class BigNumCalculator: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "add",
        "method_description": "def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add,str.\n        :param num2: The second number to add,str.\n        :return: The sum of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n\n        \"\"\"",
        "test_class": "BigNumCalculatorTestAdd",
        "test_code": "class BigNumCalculatorTestAdd(unittest.TestCase):\n    def test_add(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n\n    def test_add_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678922\", \"98765432109876543210\"), \"222222221122222222132\")\n\n    def test_add_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678934\", \"98765432109876543210\"), \"222222221122222222144\")\n\n    def test_add_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678946\", \"98765432109876543210\"), \"222222221122222222156\")\n\n    def test_add_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678958\", \"98765432109876543210\"), \"222222221122222222168\")",
        "solution_code": "def add(num1, num2):\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n\n        if carry > 0:\n            result.insert(0, str(carry))\n\n        return ''.join(result)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "subtract",
        "method_description": "@staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract,str.\n        :param num2: The second number to subtract,str.\n        :return: The difference of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n\n        \"\"\"",
        "test_class": "BigNumCalculatorTestSubtract",
        "test_code": "class BigNumCalculatorTestSubtract(unittest.TestCase):\n    def test_subtract(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n\n    def test_subtract_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"123456789012345678922\", \"98765432109876543210\"), \"24691356902469135712\")\n\n    def test_subtract_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"123456789012345678934\", \"98765432109876543\"), \"123358023580235802391\")\n\n    def test_subtract_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"12345678901234567\", \"98765432109876543210\"), \"-98753086430975308643\")\n\n    def test_subtract_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"923456789\", \"187654321\"), \"735802468\")",
        "solution_code": "@staticmethod\n    def subtract(num1, num2):\n\n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        else:\n            if num1 < num2:\n                num1, num2 = num2, num1\n                negative = True\n            else:\n                negative = False\n\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            result.insert(0, str(digit_diff))\n\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n\n        if negative:\n            result.insert(0, '-')\n\n        return ''.join(result)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "multiply",
        "method_description": "@staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply,str.\n        :param num2: The second number to multiply,str.\n        :return: The product of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n\n        \"\"\"",
        "test_class": "BigNumCalculatorTestMultiply",
        "test_code": "class BigNumCalculatorTestMultiply(unittest.TestCase):\n    def test_multiply(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")\n\n    def test_multiply_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"123456789012345678922\", \"98765432109876543210\"), \"12193263113702179524547477517529919219620\")\n\n    def test_multiply_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"123456789012345678934\", \"98765432109876543\"), \"12193263113702179499806737010255845162\")\n\n    def test_multiply_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"12345678901234567\", \"98765432109876543210\"), \"1219326311370217864336229223321140070\")\n\n    def test_multiply_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"923456789\", \"187654321\"), \"173290656712635269\")\n\n    def test_multiply_6(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"000000001\", \"000000001\"), \"1\")",
        "solution_code": "@staticmethod\n    def multiply(num1, num2):\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                total = mul + result[p2]\n\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n\n        return ''.join(map(str, result[start:]))",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport itertools # Useful for zipping strings of different lengths\nimport sys       # For sys.maxsize (though not strictly needed for 'big' numbers, good to be aware)\n\nclass BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    Numbers are represented as strings of digits.\n    Handles non-negative integers for add and multiply inputs.\n    Handles subtraction yielding negative results.\n    Assumes valid string inputs consisting only of digits '0'-'9'.\n    Does NOT handle decimal points or scientific notation.\n    Does NOT handle negative inputs directly for add or multiply.\n    \"\"\"\n\n    @staticmethod\n    def _strip_leading_zeros(num_str):\n        \"\"\"Strips leading zeros from a number string, returning '0' if the string is all zeros.\"\"\"\n        if not num_str:\n            return \"0\"\n        stripped = num_str.lstrip('0')\n        return stripped if stripped else \"0\"\n\n    @staticmethod\n    def _is_smaller(num1_str, num2_str):\n        \"\"\"\n        Compares two non-negative number strings.\n        Returns True if num1_str < num2_str, False otherwise.\n        \"\"\"\n        num1 = BigNumCalculator._strip_leading_zeros(num1_str)\n        num2 = BigNumCalculator._strip_leading_zeros(num2_str)\n\n        if len(num1) < len(num2):\n            return True\n        if len(num1) > len(num2):\n            return False\n        # Lengths are equal, compare digit by digit\n        return num1 < num2\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two non-negative big numbers represented as strings.\n        :param num1: The first number to add,str (non-negative digits).\n        :param num2: The second number to add,str (non-negative digits).\n        :return: The sum of the two numbers,str.\n        >>> BigNumCalculator.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n        >>> BigNumCalculator.add(\"1\", \"1\")\n        '2'\n        >>> BigNumCalculator.add(\"99\", \"1\")\n        '100'\n        >>> BigNumCalculator.add(\"0\", \"0\")\n        '0'\n        >>> BigNumCalculator.add(\"123\", \"0\")\n        '123'\n        >>> BigNumCalculator.add(\"1\" * 100, \"1\" * 100)\n        '2' * 100\n        >>> BigNumCalculator.add(\"9\" * 100, \"1\")\n        '1' + '0' * 100\n        \"\"\"\n        # Ensure inputs are strings\n        num1 = str(num1)\n        num2 = str(num2)\n\n        # Reverse strings for easier right-to-left processing\n        n1 = num1[::-1]\n        n2 = num2[::-1]\n\n        result = []\n        carry = 0\n\n        # Iterate through the digits, adding them and the carry\n        for digit1, digit2 in itertools.zip_longest(n1, n2, fillvalue='0'):\n            d1 = int(digit1)\n            d2 = int(digit2)\n            current_sum = d1 + d2 + carry\n            digit_sum = current_sum % 10\n            carry = current_sum // 10\n\n            result.append(str(digit_sum))\n\n        # Add any remaining carry\n        if carry:\n            result.append(str(carry))\n\n        # Reverse the result and join\n        final_result = \"\".join(result[::-1])\n\n        # Strip leading zeros, except for the case of result \"0\"\n        return BigNumCalculator._strip_leading_zeros(final_result)\n\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        Handles non-negative inputs. Determines the sign of the result.\n        :param num1: The first number to subtract,str (non-negative digits).\n        :param num2: The second number to subtract,str (non-negative digits).\n        :return: The difference of the two numbers,str.\n        >>> BigNumCalculator.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n        >>> BigNumCalculator.subtract(\"5\", \"3\")\n        '2'\n        >>> BigNumCalculator.subtract(\"3\", \"5\")\n        '-2'\n        >>> BigNumCalculator.subtract(\"100\", \"1\")\n        '99'\n        >>> BigNumCalculator.subtract(\"100\", \"100\")\n        '0'\n        >>> BigNumCalculator.subtract(\"0\", \"5\")\n        '-5'\n        >>> BigNumCalculator.subtract(\"5\", \"0\")\n        '5'\n        >>> BigNumCalculator.subtract(\"1\" * 100, \"1\" * 99)\n        '1' + '0' * 99\n        \"\"\"\n        # Ensure inputs are strings\n        num1 = str(num1)\n        num2 = str(num2)\n\n        # Handle equal numbers\n        if num1 == num2:\n            return \"0\"\n\n        # Determine the sign and the larger number\n        is_negative = BigNumCalculator._is_smaller(num1, num2)\n        if is_negative:\n            # Swap numbers and proceed as if subtracting the smaller from the larger\n            n1 = num2[::-1]\n            n2 = num1[::-1]\n        else:\n            n1 = num1[::-1]\n            n2 = num2[::-1]\n\n        result = []\n        borrow = 0\n\n        # Iterate through digits, subtracting and handling borrows\n        for digit1, digit2 in itertools.zip_longest(n1, n2, fillvalue='0'):\n            d1 = int(digit1) - borrow # Subtract potential borrow from previous step\n            d2 = int(digit2)\n\n            if d1 < d2:\n                # Need to borrow\n                d1 += 10\n                borrow = 1\n            else:\n                borrow = 0\n\n            diff = d1 - d2\n            result.append(str(diff))\n\n        # Reverse the result\n        final_result = \"\".join(result[::-1])\n\n        # Strip leading zeros\n        final_result = BigNumCalculator._strip_leading_zeros(final_result)\n\n        # Add the negative sign if needed\n        if is_negative:\n            return \"-\" + final_result\n        else:\n            return final_result\n\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two non-negative big numbers represented as strings.\n        Implements grade-school long multiplication.\n        :param num1: The first number to multiply,str (non-negative digits).\n        :param num2: The second number to multiply,str (non-negative digits).\n        :return: The product of the two numbers,str.\n        >>> BigNumCalculator.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n        >>> BigNumCalculator.multiply(\"2\", \"3\")\n        '6'\n        >>> BigNumCalculator.multiply(\"10\", \"20\")\n        '200'\n        >>> BigNumCalculator.multiply(\"123\", \"0\")\n        '0'\n        >>> BigNumCalculator.multiply(\"123\", \"1\")\n        '123'\n        >>> BigNumCalculator.multiply(\"123\", \"45\")\n        '5535'\n        >>> BigNumCalculator.multiply(\"9876\", \"9\")\n        '88884'\n        >>> BigNumCalculator.multiply(\"1\" * 10, \"1\" * 10)\n        '1234567900987654321'\n        >>> BigNumCalculator.multiply(\"9\" * 10, \"9\" * 10)\n        '99999999980000000001'\n        \"\"\"\n        # Ensure inputs are strings\n        num1 = str(num1)\n        num2 = str(num2)\n\n        # Handle zero cases\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        # Reverse strings for easier processing from least significant digit\n        n1 = num1[::-1]\n        n2 = num2[::-1]\n\n        len1 = len(n1)\n        len2 = len(n2)\n\n        # Initialize result array with zeros. Max possible length is len1 + len2\n        result = [0] * (len1 + len2)\n\n        # Perform multiplication digit by digit\n        for i in range(len1):\n            carry = 0\n            digit1 = int(n1[i])\n\n            for j in range(len2):\n                digit2 = int(n2[j])\n\n                # Calculate product, add carry and existing value in result array\n                product = digit1 * digit2 + result[i + j] + carry\n\n                # Update the current position and carry for the next position\n                result[i + j] = product % 10\n                carry = product // 10\n\n            # Add any remaining carry to the next position\n            if carry:\n                result[i + len2] += carry\n\n        # Convert the result array to a string\n        # The result is stored in reverse order in the array,\n        # and there might be leading zeros from the initialization.\n        # We need to find the first non-zero digit from the right (which is the left in the final string).\n        k = len(result) - 1\n        while k > 0 and result[k] == 0:\n            k -= 1\n\n        # Construct the final string from the relevant digits\n        final_result = \"\".join(map(str, result[:k + 1][::-1]))\n\n        # Strip leading zeros (though the above logic should mostly handle this, this is safer)\n        return BigNumCalculator._strip_leading_zeros(final_result)\n\nif __name__ == '__main__':\n    # Example Usage:\n    print(f\"Addition: {BigNumCalculator.add('12345678901234567890', '98765432109876543210')}\")\n    print(f\"Subtraction: {BigNumCalculator.subtract('12345678901234567890', '98765432109876543210')}\")\n    print(f\"Multiplication: {BigNumCalculator.multiply('12345678901234567890', '98765432109876543210')}\")\n\n    print(f\"Addition: {BigNumCalculator.add('999', '1')}\")\n    print(f\"Subtraction: {BigNumCalculator.subtract('1000', '1')}\")\n    print(f\"Multiplication: {BigNumCalculator.multiply('12345', '678')}\")\n\n    # Running doctests included in the docstrings\n    import doctest\n    doctest.testmod()\n```"
    ]
  },
  {
    "task_id": "ClassEval_16",
    "skeleton": "class Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"\n\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"",
    "test": "import unittest\n\nclass CalculatorTestCalculate(unittest.TestCase):\n    def test_calculate_1(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2')\n        self.assertEqual(res, 3)\n\n    def test_calculate_2(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2*3')\n        self.assertEqual(res, 7)\n\n    def test_calculate_3(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2*3+4')\n        self.assertEqual(res, 11)\n\n    def test_calculate_4(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2^3*2+4*5')\n        self.assertEqual(res, 37)\n\n    def test_calculate_5(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2+3')\n        self.assertEqual(res, 6)\n\n    def test_calculate_6(self):\n        calculator = Calculator()\n        res = calculator.calculate('(1+2)+3')\n        self.assertEqual(res, 6)\n\n    def test_calculate_7(self):\n        calculator = Calculator()\n        res = calculator.calculate('')\n        self.assertEqual(res, None)\n\n    def test_calculate_8(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2?')\n        self.assertEqual(res, 3)\n\n\nclass CalculatorTestPrecedence(unittest.TestCase):\n    def test_precedence_1(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('-')\n        self.assertEqual(res1, res2)\n\n    def test_precedence_2(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('*')\n        res2 = calculator.precedence('/')\n        self.assertEqual(res1, res2)\n\n    def test_precedence_3(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('/')\n        self.assertNotEqual(res1, res2)\n\n    def test_precedence_4(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('/')\n        self.assertNotEqual(res1, res2)\n\n    def test_precedence_5(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('*')\n        res2 = calculator.precedence('-')\n        self.assertNotEqual(res1, res2)\n\n\nclass CalculatorTestApplyOperator(unittest.TestCase):\n    def test_apply_operator_1(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '-']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, -1])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_2(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '*']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, 6])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_3(self):\n        calculator = Calculator()\n        operand_stack = [6, 3, 3]\n        operator_stack = ['+', '/']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [6, 1])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_4(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '^']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, 8])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_5(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '+']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, 5])\n        self.assertEqual(operator_stack, ['+'])\n\n\nclass CalculatorTest(unittest.TestCase):\n    def test_calculator(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2')\n        self.assertEqual(res, 3)\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('-')\n        res3 = calculator.precedence('*')\n        res4 = calculator.precedence('/')\n        res5 = calculator.precedence('^')\n        self.assertEqual(res1, res2)\n        self.assertEqual(res3, res4)\n        self.assertGreater(res3, res1)\n        self.assertGreater(res5, res3)\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '-']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, -1])\n        self.assertEqual(operator_stack, ['+'])",
    "solution_code": "class Calculator:\n    def __init__(self):\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        for char in expression:\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                if char in '+-*/^':\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        operator = operator_stack.pop()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        return operand_stack, operator_stack",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n",
    "class_name": "Calculator",
    "test_classes": [
      "CalculatorTestCalculate",
      "CalculatorTestPrecedence",
      "CalculatorTestApplyOperator",
      "CalculatorTest"
    ],
    "class_constructor": "class Calculator: \n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n",
    "fields": [
      "self.operators"
    ],
    "methods_info": [
      {
        "method_name": "calculate",
        "method_description": "def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"",
        "test_class": "CalculatorTestCalculate",
        "test_code": "class CalculatorTestCalculate(unittest.TestCase):\n    def test_calculate_1(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2')\n        self.assertEqual(res, 3)\n\n    def test_calculate_2(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2*3')\n        self.assertEqual(res, 7)\n\n    def test_calculate_3(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2*3+4')\n        self.assertEqual(res, 11)\n\n    def test_calculate_4(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2^3*2+4*5')\n        self.assertEqual(res, 37)\n\n    def test_calculate_5(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2+3')\n        self.assertEqual(res, 6)\n\n    def test_calculate_6(self):\n        calculator = Calculator()\n        res = calculator.calculate('(1+2)+3')\n        self.assertEqual(res, 6)\n\n    def test_calculate_7(self):\n        calculator = Calculator()\n        res = calculator.calculate('')\n        self.assertEqual(res, None)\n\n    def test_calculate_8(self):\n        calculator = Calculator()\n        res = calculator.calculate('1+2?')\n        self.assertEqual(res, 3)",
        "solution_code": "def calculate(self, expression):\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        for char in expression:\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                if char in '+-*/^':\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else None",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "precedence",
            "apply_operator"
          ]
        }
      },
      {
        "method_name": "precedence",
        "method_description": "def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"",
        "test_class": "CalculatorTestPrecedence",
        "test_code": "class CalculatorTestPrecedence(unittest.TestCase):\n    def test_precedence_1(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('-')\n        self.assertEqual(res1, res2)\n\n    def test_precedence_2(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('*')\n        res2 = calculator.precedence('/')\n        self.assertEqual(res1, res2)\n\n    def test_precedence_3(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('/')\n        self.assertNotEqual(res1, res2)\n\n    def test_precedence_4(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('+')\n        res2 = calculator.precedence('/')\n        self.assertNotEqual(res1, res2)\n\n    def test_precedence_5(self):\n        calculator = Calculator()\n        res1 = calculator.precedence('*')\n        res2 = calculator.precedence('-')\n        self.assertNotEqual(res1, res2)",
        "solution_code": "def precedence(self, operator):\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        return precedences.get(operator, 0)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "apply_operator",
        "method_description": "def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"",
        "test_class": "CalculatorTestApplyOperator",
        "test_code": "class CalculatorTestApplyOperator(unittest.TestCase):\n    def test_apply_operator_1(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '-']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, -1])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_2(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '*']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, 6])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_3(self):\n        calculator = Calculator()\n        operand_stack = [6, 3, 3]\n        operator_stack = ['+', '/']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [6, 1])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_4(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '^']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, 8])\n        self.assertEqual(operator_stack, ['+'])\n\n    def test_apply_operator_5(self):\n        calculator = Calculator()\n        operand_stack = [1, 2, 3]\n        operator_stack = ['+', '+']\n        calculator.apply_operator(operand_stack, operator_stack)\n        self.assertEqual(operand_stack, [1, 5])\n        self.assertEqual(operator_stack, ['+'])",
        "solution_code": "def apply_operator(self, operand_stack, operator_stack):\n        operator = operator_stack.pop()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        return operand_stack, operator_stack",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.operators"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport operator # Import the operator module if needed for potential extensions, though lambdas are used here.\nimport math   # Import math for power operator\n\nclass Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y # Using ** for exponentiation\n        }\n        # Define operator precedence: higher number means higher precedence\n        # Add () support might require more precedence levels or different logic,\n        # but based on the prompt, only the 5 operators are needed.\n        self._precedence_levels = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3,\n            # Add parentheses if needed later, e.g.:\n            # '(': 0, # Lower precedence than any operator\n            # ')': 0\n        }\n\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n        # Use .get() to return 0 for operators not in the dictionary\n        return self._precedence_levels.get(operator, 0)\n\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        # Example requires a valid operator in the stack\n        # Let's simulate a step where '-' is at the top and operands 2 and 3 are ready\n        >>> ops_stack = [1, 2, 3]; op_stack = ['+', '-']\n        >>> calculator.apply_operator(ops_stack, op_stack)\n        # Expected: pop '-', pop 3, pop 2. Apply 2 - 3 = -1. Push -1. Result: ([1, -1], ['+'])\n        # The docstring example `([1, 2, 3], ['+', '-']) ([1, -1], ['-'])` output for operator_stack seems incorrect.\n        # We follow the description: operator is *used* from the stack top.\n        ([1, -1], ['+'])\n\n        # Another example: operands [1, 5, 3], operators ['*', '+']\n        # Expected: pop '+', pop 3, pop 5. Apply 5 + 3 = 8. Push 8. Result: ([1, 8], ['*'])\n        >>> ops_stack = [1, 5, 3]; op_stack = ['*', '+']\n        >>> calculator.apply_operator(ops_stack, op_stack)\n        ([1, 8], ['*'])\n        \"\"\"\n        # Check if there are enough operands and at least one operator\n        if len(operand_stack) < 2 or len(operator_stack) < 1:\n            # This indicates an issue with the expression parsing, leading to an invalid stack state\n            raise IndexError(\"Insufficient operands or operator on stack\")\n\n        # Pop the operator from the operator stack\n        operator = operator_stack.pop()\n\n        # Pop the two operands from the operand stack (right then left)\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n\n        # Get the corresponding operation function\n        operation = self.operators.get(operator)\n\n        if operation is None:\n            # This should not happen if only valid operators are pushed onto the stack\n            raise ValueError(f\"Unknown operator: {operator}\")\n\n        # Perform the calculation\n        try:\n            result = operation(operand1, operand2)\n        except ZeroDivisionError:\n            # Catch division by zero specifically and re-raise or handle as needed by calculate\n            raise ZeroDivisionError(\"division by zero\")\n\n        # Push the result back onto the operand stack\n        operand_stack.append(result)\n\n        # Return the modified stacks\n        return operand_stack, operator_stack\n\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        >>> calculator.calculate('2*3^2+1') # 2 * 9 + 1 = 18 + 1 = 19\n        19.0\n        >>> calculator.calculate('10/0') # Division by zero\n        >>> calculator.calculate('invalid+expression') # Invalid characters\n        >>> calculator.calculate('1+') # Malformed expression\n        \"\"\"\n        if not expression:\n            return None\n\n        operand_stack = []\n        operator_stack = []\n        i = 0\n        n = len(expression)\n\n        while i < n:\n            # Skip whitespace\n            if expression[i].isspace():\n                i += 1\n                continue\n\n            # If the character is a digit or the start of a potential number (like .5)\n            if expression[i].isdigit() or (expression[i] == '.' and (i + 1 < n and expression[i+1].isdigit())):\n                num_str = \"\"\n                decimal_found = False\n                # Read the entire number\n                while i < n and (expression[i].isdigit() or expression[i] == '.'):\n                    if expression[i] == '.':\n                        if decimal_found:\n                            return None # Invalid number format (multiple decimal points)\n                        decimal_found = True\n                    num_str += expression[i]\n                    i += 1\n\n                # Handle cases like \".\" or \"1.\" or \".5\"\n                if num_str == '.' or (num_str.startswith('.') and len(num_str) == 1):\n                    return None # Invalid number format\n\n                try:\n                    # Convert the number string to float and push onto operand stack\n                    number = float(num_str)\n                    operand_stack.append(number)\n                except ValueError:\n                    # Should not happen with the checks above, but as a fallback\n                    return None\n                continue # Move to the next token after processing the number\n\n            # If the character is an operator\n            if expression[i] in self.operators:\n                current_operator = expression[i]\n                i += 1 # Move past the operator\n\n                # Process operators on the operator stack with higher or equal precedence\n                # The Shunting-Yard principle applied here\n                while (operator_stack and\n                       self.precedence(operator_stack[-1]) >= self.precedence(current_operator)):\n                    try:\n                        self.apply_operator(operand_stack, operator_stack)\n                    except (ZeroDivisionError, IndexError, ValueError):\n                        # If any error occurs during operator application (division by zero,\n                        # insufficient operands, or unknown operator which shouldn't be on stack)\n                        return None\n                # Push the current operator onto the operator stack\n                operator_stack.append(current_operator)\n                continue # Move to the next character\n\n            # If the character is anything else (not space, digit, '.', or operator)\n            # This implies an invalid character in the expression\n            return None\n\n        # After processing the entire expression string\n        # Process any remaining operators in the operator stack\n        while operator_stack:\n            try:\n                self.apply_operator(operand_stack, operator_stack)\n            except (ZeroDivisionError, IndexError, ValueError):\n                # Handle errors during the final processing phase\n                return None\n\n        # If the expression was valid, the operand stack should contain exactly one result\n        if len(operand_stack) == 1:\n            return operand_stack[0]\n        else:\n            # This indicates a malformed expression (e.g., \"1 2\", \"+\", \"1+2*\")\n            return None\n\n# Example usage from docstrings:\n# calculator = Calculator()\n# print(calculator.calculate('1+2-3'))\n# print(calculator.precedence('+'))\n# print(calculator.precedence('^'))\n# print(calculator.apply_operator([1, 2, 3], ['+', '-'])) # Example output mismatch noted and explained in apply_operator docstring\n\n# Example with more complex expression\n# print(calculator.calculate('1+2*3^2-8/4')) # 1 + 2 * 9 - 2 = 1 + 18 - 2 = 17.0\n# print(calculator.calculate('10/0'))\n# print(calculator.calculate('invalid'))\n# print(calculator.calculate('1+'))\n# print(calculator.calculate('1 2 +')) # Should be None\n\n```"
    ]
  },
  {
    "task_id": "ClassEval_19",
    "skeleton": "class ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"",
    "test": "import unittest\n\n\nclass ChandrasekharSieveTestGeneratePrimes(unittest.TestCase):\n    def test_generate_primes_1(self):\n        cs = ChandrasekharSieve(20)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17, 19])\n\n    def test_generate_primes_2(self):\n        cs = ChandrasekharSieve(18)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17])\n\n    def test_generate_primes_3(self):\n        cs = ChandrasekharSieve(15)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13])\n\n    def test_generate_primes_4(self):\n        cs = ChandrasekharSieve(10)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7])\n\n    def test_generate_primes_5(self):\n        cs = ChandrasekharSieve(1)\n        res = cs.generate_primes()\n        self.assertEqual(res, [])\n\n\nclass ChandrasekharSieveTestGetPrimes(unittest.TestCase):\n    def test_get_primes_1(self):\n        cs = ChandrasekharSieve(20)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17, 19])\n\n    def test_get_primes_2(self):\n        cs = ChandrasekharSieve(18)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17])\n\n    def test_get_primes_3(self):\n        cs = ChandrasekharSieve(15)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13])\n\n    def test_get_primes_4(self):\n        cs = ChandrasekharSieve(10)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7])\n\n    def test_get_primes_5(self):\n        cs = ChandrasekharSieve(1)\n        res = cs.get_primes()\n        self.assertEqual(res, [])\n\n\nclass ChandrasekharSieveTest(unittest.TestCase):\n    def test_chandrasekharsieve(self):\n        cs = ChandrasekharSieve(20)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17, 19])\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17, 19])",
    "solution_code": "class ChandrasekharSieve:\n    def __init__(self, n):\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        primes = []\n        for i in range(2, self.n + 1):\n            if sieve[i]:\n                primes.append(i)\n\n        return primes\n\n    def get_primes(self):\n        return self.primes",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n",
    "class_name": "ChandrasekharSieve",
    "test_classes": [
      "ChandrasekharSieveTestGeneratePrimes",
      "ChandrasekharSieveTestGetPrimes",
      "ChandrasekharSieveTest"
    ],
    "class_constructor": "class ChandrasekharSieve: \n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n",
    "fields": [
      "self.n",
      "self.primes"
    ],
    "methods_info": [
      {
        "method_name": "generate_primes",
        "method_description": "def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"",
        "test_class": "ChandrasekharSieveTestGeneratePrimes",
        "test_code": "class ChandrasekharSieveTestGeneratePrimes(unittest.TestCase):\n    def test_generate_primes_1(self):\n        cs = ChandrasekharSieve(20)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17, 19])\n\n    def test_generate_primes_2(self):\n        cs = ChandrasekharSieve(18)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17])\n\n    def test_generate_primes_3(self):\n        cs = ChandrasekharSieve(15)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13])\n\n    def test_generate_primes_4(self):\n        cs = ChandrasekharSieve(10)\n        res = cs.generate_primes()\n        self.assertEqual(res, [2, 3, 5, 7])\n\n    def test_generate_primes_5(self):\n        cs = ChandrasekharSieve(1)\n        res = cs.generate_primes()\n        self.assertEqual(res, [])",
        "solution_code": "def generate_primes(self):\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        primes = []\n        for i in range(2, self.n + 1):\n            if sieve[i]:\n                primes.append(i)\n\n        return primes",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.n"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "get_primes",
        "method_description": "def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"",
        "test_class": "ChandrasekharSieveTestGetPrimes",
        "test_code": "class ChandrasekharSieveTestGetPrimes(unittest.TestCase):\n    def test_get_primes_1(self):\n        cs = ChandrasekharSieve(20)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17, 19])\n\n    def test_get_primes_2(self):\n        cs = ChandrasekharSieve(18)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13, 17])\n\n    def test_get_primes_3(self):\n        cs = ChandrasekharSieve(15)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7, 11, 13])\n\n    def test_get_primes_4(self):\n        cs = ChandrasekharSieve(10)\n        cs.generate_primes()\n        res = cs.get_primes()\n        self.assertEqual(res, [2, 3, 5, 7])\n\n    def test_get_primes_5(self):\n        cs = ChandrasekharSieve(1)\n        res = cs.get_primes()\n        self.assertEqual(res, [])",
        "solution_code": "def get_primes(self):\n        return self.primes",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.primes"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport math\n\nclass ChandrasekharSieve:\n    \"\"\"\n    This is a class that is intended to use the Chandrasekhar's Sieve method to find all prime numbers within the range.\n\n    NOTE: \"Chandrasekhar's Sieve\" is not a widely recognized or standard prime sieve algorithm\n    in the same way as the Sieve of Eratosthenes or Sieve of Atkin. There may be a specific context,\n    a lesser-known variant, or a misunderstanding associated with this name for a general-purpose\n    prime generation algorithm.\n\n    The implementation below uses the standard Sieve of Eratosthenes as a placeholder because\n    the specific steps for a \"Chandrasekhar's Sieve\" for prime generation are not readily available\n    in standard mathematical literature or computer science contexts.\n\n    To complete this class accurately according to a specific definition of \"Chandrasekhar's Sieve\",\n    the implementation details for `generate_primes` would need to be replaced with that specific algorithm.\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        Triggers the prime generation upon initialization.\n\n        :param n: int, the upper limit (inclusive) for generating prime numbers. Must be non-negative.\n        :raises ValueError: If n is not a non-negative integer.\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n            raise ValueError(\"Limit 'n' must be a non-negative integer.\")\n        self.n = n\n        # Generate primes upon initialization\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using an assumed sieve method.\n        Currently implements the Sieve of Eratosthenes as a placeholder.\n        REPLACE this method's body with the actual steps of the \"Chandrasekhar's Sieve\"\n        algorithm if you have its definition.\n\n        :return: list, a list of prime numbers up to self.n.\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes() # Assuming it calls the internal implementation\n        [2, 3, 5, 7, 11, 13, 17, 19]\n        \"\"\"\n        limit = self.n\n        if limit < 2:\n            return []\n\n        # --- Start of Sieve of Eratosthenes (Placeholder Implementation) ---\n        # This section needs to be replaced with the actual \"Chandrasekhar's Sieve\" logic.\n        is_prime = [True] * (limit + 1)\n        is_prime[0] = is_prime[1] = False # 0 and 1 are not prime\n\n        # Iterate from 2 up to the square root of the limit\n        for number in range(2, int(math.sqrt(limit)) + 1):\n            if is_prime[number]:\n                # Mark all multiples of the current prime as not prime, starting from its square\n                for multiple in range(number * number, limit + 1, number):\n                    is_prime[multiple] = False\n\n        # Collect all numbers that are still marked as True\n        primes_list = [number for number in range(2, limit + 1) if is_prime[number]]\n        # --- End of Sieve of Eratosthenes (Placeholder) ---\n\n        return primes_list\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n\n        :return: list, a list of prime numbers generated up to the limit n.\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n        \"\"\"\n        return self.primes\n\n# Example Usage (based on the placeholder Sieve of Eratosthenes):\n# cs = ChandrasekharSieve(30)\n# print(f\"Primes up to 30: {cs.get_primes()}\")\n# # Expected: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n# Run doctests (if the placeholder implementation is correct for the examples)\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # You can add more manual tests here\n    # print(\"\\nManual Tests:\")\n    # try:\n    #     cs_large = ChandrasekharSieve(100)\n    #     print(f\"Primes up to 100 ({len(cs_large.get_primes())}): {cs_large.get_primes()}\")\n    # except ValueError as e:\n    #     print(f\"Error creating sieve: {e}\")\n\n    # try:\n    #     cs_zero = ChandrasekharSieve(0)\n    #     print(f\"Primes up to 0: {cs_zero.get_primes()}\")\n    # except ValueError as e:\n    #     print(f\"Error creating sieve: {e}\")\n\n    # try:\n    #     cs_invalid = ChandrasekharSieve(-5)\n    #     print(f\"Primes up to -5: {cs_invalid.get_primes()}\")\n    # except ValueError as e:\n    #     print(f\"Correctly handled invalid input: {e}\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_23",
    "skeleton": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"",
    "test": "import unittest\n\nclass CombinationCalculatorTestCount(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(CombinationCalculator.count(4, 2), 6)\n    def test_count_2(self):\n        self.assertEqual(CombinationCalculator.count(5, 3), 10)\n\n    def test_count_3(self):\n        self.assertEqual(CombinationCalculator.count(6, 6), 1)\n\n    def test_count_4(self):\n        self.assertEqual(CombinationCalculator.count(6, 0), 1)\n\n    def test_count_5(self):\n        self.assertEqual(CombinationCalculator.count(6, 3), 20)\n\nclass CombinationCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all(self):\n        self.assertEqual(CombinationCalculator.count_all(4), 15)\n\n    def test_count_all_2(self):\n        self.assertEqual(CombinationCalculator.count_all(-1), False)\n\n    def test_count_all_3(self):\n        self.assertEqual(CombinationCalculator.count_all(65), False)\n\n    def test_count_all_4(self):\n        self.assertEqual(CombinationCalculator.count_all(0), 0)\n\n    def test_count_all_5(self):\n        self.assertEqual(CombinationCalculator.count_all(63), float(\"inf\"))\n\nclass CombinationCalculatorTestSelect(unittest.TestCase):\n    def test_select(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n\n    def test_select_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(5, 3), 10)\n\n    def test_select_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 6), 1)\n\n    def test_select_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 0), 1)\n\n    def test_select_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 3), 20)\n\nclass CombinationCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all(self):\n        calc = CombinationCalculator([\"A\"])\n        self.assertEqual(calc.select_all(), [['A']])\n\n    def test_select_all_2(self):\n        calc = CombinationCalculator([\"A\", \"B\"])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['A', 'B']])\n\n    def test_select_all_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\"])\n        self.assertEqual(calc.select_all(),[['A'], ['B'], ['C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']])\n\n    def test_select_all_4(self):\n        calc = CombinationCalculator([])\n        self.assertEqual(calc.select_all(),[])\n\n    def test_select_all_5(self):\n        calc = CombinationCalculator([\"B\"])\n        self.assertEqual(calc.select_all(),[['B']])\n\n\nclass CombinationCalculatorTestSelect2(unittest.TestCase):\n    def test_select2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n\n    def test_select2_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 3, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']])\n\n    def test_select2_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 1, 0, result)\n        self.assertEqual(result, [['A'], ['B'], ['C'], ['D']])\n\n    def test_select2_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 0, 0, result)\n        self.assertEqual(result, [[]])\n\n    def test_select2_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 4, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C', 'D']])\n\nclass CombinationCalculatorTestMain(unittest.TestCase):\n    def test_main(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n        self.assertEqual(calc.count_all(4), 15)\n        self.assertEqual(calc.select(2), [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])",
    "solution_code": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)",
    "import_statement": [
      "import math",
      "from typing import List"
    ],
    "class_description": "    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n",
    "class_name": "CombinationCalculator",
    "test_classes": [
      "CombinationCalculatorTestCount",
      "CombinationCalculatorTestCountAll",
      "CombinationCalculatorTestSelect",
      "CombinationCalculatorTestSelectAll",
      "CombinationCalculatorTestSelect2",
      "CombinationCalculatorTestMain"
    ],
    "class_constructor": "class CombinationCalculator: \n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n",
    "fields": [
      "self.datas"
    ],
    "methods_info": [
      {
        "method_name": "count",
        "method_description": "def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"",
        "test_class": "CombinationCalculatorTestCount",
        "test_code": "class CombinationCalculatorTestCount(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(CombinationCalculator.count(4, 2), 6)\n    def test_count_2(self):\n        self.assertEqual(CombinationCalculator.count(5, 3), 10)\n\n    def test_count_3(self):\n        self.assertEqual(CombinationCalculator.count(6, 6), 1)\n\n    def test_count_4(self):\n        self.assertEqual(CombinationCalculator.count(6, 0), 1)\n\n    def test_count_5(self):\n        self.assertEqual(CombinationCalculator.count(6, 3), 20)",
        "solution_code": "def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "count_all",
        "method_description": "@staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"",
        "test_class": "CombinationCalculatorTestCountAll",
        "test_code": "class CombinationCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all(self):\n        self.assertEqual(CombinationCalculator.count_all(4), 15)\n\n    def test_count_all_2(self):\n        self.assertEqual(CombinationCalculator.count_all(-1), False)\n\n    def test_count_all_3(self):\n        self.assertEqual(CombinationCalculator.count_all(65), False)\n\n    def test_count_all_4(self):\n        self.assertEqual(CombinationCalculator.count_all(0), 0)\n\n    def test_count_all_5(self):\n        self.assertEqual(CombinationCalculator.count_all(63), float(\"inf\"))",
        "solution_code": "@staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float(\"inf\")",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "select",
        "method_description": "def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"",
        "test_class": "CombinationCalculatorTestSelect",
        "test_code": "class CombinationCalculatorTestSelect(unittest.TestCase):\n    def test_select(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n\n    def test_select_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(5, 3), 10)\n\n    def test_select_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 6), 1)\n\n    def test_select_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 0), 1)\n\n    def test_select_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 3), 20)",
        "solution_code": "def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "_select"
          ]
        }
      },
      {
        "method_name": "select_all",
        "method_description": "def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"",
        "test_class": "CombinationCalculatorTestSelectAll",
        "test_code": "class CombinationCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all(self):\n        calc = CombinationCalculator([\"A\"])\n        self.assertEqual(calc.select_all(), [['A']])\n\n    def test_select_all_2(self):\n        calc = CombinationCalculator([\"A\", \"B\"])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['A', 'B']])\n\n    def test_select_all_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\"])\n        self.assertEqual(calc.select_all(),[['A'], ['B'], ['C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']])\n\n    def test_select_all_4(self):\n        calc = CombinationCalculator([])\n        self.assertEqual(calc.select_all(),[])\n\n    def test_select_all_5(self):\n        calc = CombinationCalculator([\"B\"])\n        self.assertEqual(calc.select_all(),[['B']])",
        "solution_code": "def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.datas"
          ],
          "method_dependencies": [
            "select"
          ]
        }
      },
      {
        "method_name": "_select",
        "method_description": "def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"",
        "test_class": "CombinationCalculatorTestSelect2",
        "test_code": "class CombinationCalculatorTestSelect2(unittest.TestCase):\n    def test_select2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n\n    def test_select2_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 3, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']])\n\n    def test_select2_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 1, 0, result)\n        self.assertEqual(result, [['A'], ['B'], ['C'], ['D']])\n\n    def test_select2_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 0, 0, result)\n        self.assertEqual(result, [[]])\n\n    def test_select2_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 4, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C', 'D']])",
        "solution_code": "def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "List"
          ],
          "field_dependencies": [
            "self.datas"
          ],
          "method_dependencies": [
            "select"
          ]
        }
      }
    ],
    "predict": [
      "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        # Store a copy of the input list to prevent external modifications\n        self.datas = list(datas)\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count (n choose m).\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        >>> CombinationCalculator.count(5, 3)\n        10\n        >>> CombinationCalculator.count(10, 0)\n        1\n        >>> CombinationCalculator.count(10, 10)\n        1\n        >>> CombinationCalculator.count(10, 1)\n        10\n        >>> CombinationCalculator.count(5, 6)\n        0\n        >>> CombinationCalculator.count(5, -1)\n        0\n        >>> CombinationCalculator.count(0, 0)\n        1\n        >>> CombinationCalculator.count(0, 1)\n        0\n        \"\"\"\n        if n < 0 or m < 0:\n             # Combinations are typically defined for non-negative n and m\n             # math.comb handles m < 0 or m > n, but raises ValueError for n < 0\n             return 0\n        # math.comb(n, m) is equivalent to n! / (m! * (n-m)!) and handles m > n and m=0/m=n cases\n        return math.comb(n, m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible non-empty combinations (subsets excluding the empty set).\n        This is 2^n - 1.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        >>> CombinationCalculator.count_all(0)\n        0\n        >>> CombinationCalculator.count_all(1)\n        1\n        >>> CombinationCalculator.count_all(2)\n        3\n        >>> CombinationCalculator.count_all(63)\n        9223372036854775807\n        >>> CombinationCalculator.count_all(64)\n        inf\n        \"\"\"\n        # Total subsets is 2^n. We are excluding the empty set (k=0), so it's 2^n - 1.\n        # We need to check if 2^n - 1 exceeds the limit of a 64-bit signed integer, which is 2^63 - 1.\n        # 2^n - 1 > 2^63 - 1  <=> 2^n > 2^63 <=> n > 63.\n        # This happens when n is 64 or greater.\n        if n < 0:\n            return 0 # Number of elements cannot be negative\n        if n >= 64: # If n is 64 or more, 2^n will be 2^64 or more, exceeding 2^63 - 1\n            return float(\"inf\")\n        # Calculate 2^n - 1. Use the bit shift operator for efficiency.\n        return (1 << n) - 1\n\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = calc.select(2)\n        >>> sorted([sorted(c) for c in result]) # Sort results for consistent comparison\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n        >>> calc.select(0) # Test m=0 (the empty set combination)\n        [[]]\n        >>> calc.select(4) # Test m=n\n        [['A', 'B', 'C', 'D']]\n        >>> calc.select(5) # Test m > n\n        []\n        >>> calc.select(-1) # Test m < 0\n        []\n        >>> calc_empty = CombinationCalculator([])\n        >>> calc_empty.select(0)\n        [[]]\n        >>> calc_empty.select(1)\n        []\n        >>> calc_single = CombinationCalculator([\"X\"])\n        >>> calc_single.select(0)\n        [[]]\n        >>> calc_single.select(1)\n        [['X']]\n        >>> calc_single.select(2)\n        []\n        >>> calc_dup = CombinationCalculator([\"A\", \"A\", \"B\"])\n        >>> result_dup = calc_dup.select(2)\n        >>> sorted([sorted(c) for c in result_dup])\n        [['A', 'A'], ['A', 'B'], ['A', 'B']]\n\n        \"\"\"\n        n = len(self.datas)\n        # Handle invalid input for m\n        if m < 0 or m > n:\n            return []\n        # Special case: combination of 0 elements is the empty set\n        if m == 0:\n             return [[]]\n\n        result = []\n        # Initialize the list to hold the current combination\n        current_combination = [None] * m\n        # Start the recursive generation from the first element of datas\n        self._select(0, current_combination, 0, result)\n        return result\n\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible non-empty combinations of selecting elements from the given data list, and it uses the select method.\n        This is equivalent to generating combinations of size k for k from 1 to len(self.datas).\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result_all = calc.select_all()\n        >>> sorted([sorted(c) for c in result_all]) # Sort for consistent comparison\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['A', 'B', 'C', 'D'], ['A', 'B', 'D'], ['A', 'C'], ['A', 'C', 'D'], ['A', 'D'], ['B'], ['B', 'C'], ['B', 'C', 'D'], ['B', 'D'], ['C'], ['C', 'D'], ['D']]\n        >>> calc_empty = CombinationCalculator([])\n        >>> calc_empty.select_all()\n        []\n        >>> calc_single = CombinationCalculator([\"X\"])\n        >>> calc_single.select_all()\n        [['X']]\n        >>> calc_dup = CombinationCalculator([\"A\", \"A\"])\n        >>> result_dup_all = calc_dup.select_all()\n        >>> sorted([sorted(c) for c in result_dup_all])\n        [['A'], ['A'], ['A', 'A']]\n\n        \"\"\"\n        all_combinations = []\n        n = len(self.datas)\n        # Iterate through all possible combination sizes from 1 up to n\n        for k in range(1, n + 1):\n            # Use the select method to get combinations of size k\n            combinations_of_size_k = self.select(k)\n            # Add the generated combinations to the main list\n            all_combinations.extend(combinations_of_size_k)\n        return all_combinations\n\n\n    def _select(self, currentDataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        This is a recursive helper method. It attempts to fill the `resultList` starting from\n        `resultIndex` by selecting elements from `self.datas` starting from `currentDataIndex`.\n\n        :param currentDataIndex: The index in self.datas to start considering elements from for the current slot (`resultIndex`).\n        :param resultList: The list representing the current combination being built (size `m`).\n        :param resultIndex: The current index in `resultList` where the next selected element should be placed.\n        :param result: The list where complete combinations are stored.\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> sorted([sorted(c) for c in result]) # Sort for consistent comparison\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n        \"\"\"\n        # Base Case 1: If resultIndex reaches the length of resultList,\n        # it means we have successfully filled the resultList with 'm' elements.\n        if resultIndex == len(resultList):\n            # Append a copy of the completed combination to the result list\n            result.append(list(resultList))\n            return\n\n        # Base Case 2: If we have considered all elements in datas (currentDataIndex reaches len(self.datas)),\n        # but the resultList is not yet full, this path doesn't lead to a valid combination.\n        # Alternatively, we can check if there are enough remaining elements to fill the rest of the combination.\n        # Remaining elements needed: len(resultList) - resultIndex\n        # Remaining elements available: len(self.datas) - currentDataIndex\n        if len(self.datas) - currentDataIndex < len(resultList) - resultIndex:\n             return\n\n        # Recursive Step:\n        # Iterate through the elements in datas starting from currentDataIndex.\n        # For each element datas[i], consider including it in the current combination\n        # at the current position (resultList[resultIndex]).\n        for i in range(currentDataIndex, len(self.datas)):\n            # Choose the element datas[i] for the current position\n            resultList[resultIndex] = self.datas[i]\n\n            # Recursively call _select to fill the next position (resultIndex + 1).\n            # The next element must be chosen from elements *after* the current one (datas[i + 1:])\n            # to ensure combinations are generated in a non-decreasing order of indices,\n            # which avoids duplicate combinations (e.g., ['A', 'B'] and ['B', 'A']).\n            self._select(i + 1, resultList, resultIndex + 1, result)\n\n# Example Usage (optional - typically in a separate script or tests)\nif __name__ == '__main__':\n    # Example for count\n    print(f\"Combinations of 4 choose 2: {CombinationCalculator.count(4, 2)}\") # Output: 6\n    print(f\"Combinations of 5 choose 3: {CombinationCalculator.count(5, 3)}\") # Output: 10\n    print(f\"Combinations of 63 choose 30: {CombinationCalculator.count(63, 30)}\") # A large number\n\n    # Example for count_all\n    print(f\"Total non-empty combinations for 4 elements: {CombinationCalculator.count_all(4)}\") # Output: 15\n    print(f\"Total non-empty combinations for 0 elements: {CombinationCalculator.count_all(0)}\") # Output: 0\n    print(f\"Total non-empty combinations for 63 elements: {CombinationCalculator.count_all(63)}\") # Max value\n    print(f\"Total non-empty combinations for 64 elements: {CombinationCalculator.count_all(64)}\") # inf\n\n    # Example for select\n    calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n    combinations_2 = calc.select(2)\n    print(f\"Combinations of 2 from ['A', 'B', 'C', 'D']: {combinations_2}\")\n    # Expected: [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n    combinations_3 = calc.select(3)\n    print(f\"Combinations of 3 from ['A', 'B', 'C', 'D']: {combinations_3}\")\n    # Expected: [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']]\n\n    # Example for select_all\n    all_comb = calc.select_all()\n    print(f\"All non-empty combinations from ['A', 'B', 'C', 'D']: {all_comb}\")\n    # Expected (order may vary unless sorted): [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n    calc_dup = CombinationCalculator([\"apple\", \"apple\", \"banana\"])\n    print(f\"Combinations of 2 from ['apple', 'apple', 'banana']: {calc_dup.select(2)}\")\n    # Expected (treating apples distinctly by position): [['apple', 'apple'], ['apple', 'banana'], ['apple', 'banana']]\n```"
    ]
  },
  {
    "task_id": "ClassEval_24",
    "skeleton": "class ComplexCalculator:\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"",
    "test": "import unittest\n\nclass ComplexCalculatorTestAdd(unittest.TestCase):\n    def test_add(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1+2j, 3+4j), (4+6j))\n\n    def test_add_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(-1 - 2j, -3 - 4j), (-4 - 6j))\n\n    def test_add_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1-2j, 3-4j), (4-6j))\n\n    def test_add_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(-1+2j, -3+4j), (-4+6j))\n\n    def test_add_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1+2j, -1-2j), (0+0j))\n\nclass ComplexCalculatorTestSubtract(unittest.TestCase):\n    def test_subtract(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(1+2j, 3+4j), (-2-2j))\n\n    def test_subtract_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(-1-2j, -3-4j), (2+2j))\n\n    def test_subtract_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(1-2j, 3-4j), (-2+2j))\n\n    def test_subtract_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(-1+2j, -3+4j), (2-2j))\n\n    def test_subtract_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(1+2j, 1+2j), (0+0j))\n\nclass ComplexCalculatorTestMultiply(unittest.TestCase):\n    def test_multiply(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(1+2j, 3+4j), (-5+10j))\n\n    def test_multiply_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(-1-2j, -3-4j), (-5+10j))\n\n    def test_multiply_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(1-2j, 3-4j), (-5-10j))\n\n    def test_multiply_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(-1+2j, -3+4j), (-5-10j))\n\n    def test_multiply_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(1+2j, -1-2j), (3-4j))\n\nclass ComplexCalculatorTestDivide(unittest.TestCase):\n    def test_divide(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(1+2j, 3+4j), (0.44+0.08j))\n\n    def test_divide_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(-1-2j, -3-4j), (0.44+0.08j))\n\n    def test_divide_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(1-2j, 3-4j), (0.44-0.08j))\n\n    def test_divide_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(-1+2j, -3+4j), (0.44-0.08j))\n\n    def test_divide_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(1+2j, -1-2j), (-1+0j))\n\nclass ComplexCalculatorTestMain(unittest.TestCase):\n    def test_main(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1+2j, 3+4j), (4+6j))\n        self.assertEqual(complexCalculator.subtract(1+2j, 3+4j), (-2-2j))\n        self.assertEqual(complexCalculator.multiply(1+2j, 3+4j), (-5+10j))\n        self.assertEqual(complexCalculator.divide(1+2j, 3+4j), (0.44+0.08j))",
    "solution_code": "class ComplexCalculator:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n        answer = complex(real, imaginary)\n        return answer\n    \n    @staticmethod\n    def subtract(c1, c2):\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n        return complex(real, imaginary)\n    \n    @staticmethod\n    def multiply(c1, c2):\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)\n    \n    @staticmethod\n    def divide(c1, c2):\n        denominator = c2.real**2 + c2.imag**2\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n",
    "class_name": "ComplexCalculator",
    "test_classes": [
      "ComplexCalculatorTestAdd",
      "ComplexCalculatorTestSubtract",
      "ComplexCalculatorTestMultiply",
      "ComplexCalculatorTestDivide",
      "ComplexCalculatorTestMain"
    ],
    "class_constructor": "class ComplexCalculator: \n    def __init__(self):\n        pass\n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "add",
        "method_description": "def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"",
        "test_class": "ComplexCalculatorTestAdd",
        "test_code": "class ComplexCalculatorTestAdd(unittest.TestCase):\n    def test_add(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1+2j, 3+4j), (4+6j))\n\n    def test_add_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(-1 - 2j, -3 - 4j), (-4 - 6j))\n\n    def test_add_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1-2j, 3-4j), (4-6j))\n\n    def test_add_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(-1+2j, -3+4j), (-4+6j))\n\n    def test_add_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.add(1+2j, -1-2j), (0+0j))",
        "solution_code": "def add(c1, c2):\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n        answer = complex(real, imaginary)\n        return answer",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "subtract",
        "method_description": "@staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"",
        "test_class": "ComplexCalculatorTestSubtract",
        "test_code": "class ComplexCalculatorTestSubtract(unittest.TestCase):\n    def test_subtract(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(1+2j, 3+4j), (-2-2j))\n\n    def test_subtract_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(-1-2j, -3-4j), (2+2j))\n\n    def test_subtract_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(1-2j, 3-4j), (-2+2j))\n\n    def test_subtract_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(-1+2j, -3+4j), (2-2j))\n\n    def test_subtract_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.subtract(1+2j, 1+2j), (0+0j))",
        "solution_code": "@staticmethod\n    def subtract(c1, c2):\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n        return complex(real, imaginary)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "multiply",
        "method_description": "@staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"",
        "test_class": "ComplexCalculatorTestMultiply",
        "test_code": "class ComplexCalculatorTestMultiply(unittest.TestCase):\n    def test_multiply(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(1+2j, 3+4j), (-5+10j))\n\n    def test_multiply_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(-1-2j, -3-4j), (-5+10j))\n\n    def test_multiply_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(1-2j, 3-4j), (-5-10j))\n\n    def test_multiply_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(-1+2j, -3+4j), (-5-10j))\n\n    def test_multiply_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.multiply(1+2j, -1-2j), (3-4j))",
        "solution_code": "@staticmethod\n    def multiply(c1, c2):\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "divide",
        "method_description": "@staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"",
        "test_class": "ComplexCalculatorTestDivide",
        "test_code": "class ComplexCalculatorTestDivide(unittest.TestCase):\n    def test_divide(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(1+2j, 3+4j), (0.44+0.08j))\n\n    def test_divide_2(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(-1-2j, -3-4j), (0.44+0.08j))\n\n    def test_divide_3(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(1-2j, 3-4j), (0.44-0.08j))\n\n    def test_divide_4(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(-1+2j, -3+4j), (0.44-0.08j))\n\n    def test_divide_5(self):\n        complexCalculator = ComplexCalculator()\n        self.assertEqual(complexCalculator.divide(1+2j, -1-2j), (-1+0j))",
        "solution_code": "@staticmethod\n    def divide(c1, c2):\n        denominator = c2.real**2 + c2.imag**2\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nclass ComplexCalculator:\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n        # Python's built-in complex division handles division by zero\n        return c1 / c2\n\n```"
    ]
  },
  {
    "task_id": "ClassEval_29",
    "skeleton": "from collections import Counter\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"",
    "test": "import unittest\n\n\nclass DataStatisticsTestMean(unittest.TestCase):\n    def test_mean_1(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n\n    def test_mean_2(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_mean_3(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7])\n        self.assertEqual(res, 4.17)\n\n    def test_mean_4(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8])\n        self.assertEqual(res, 4.71)\n\n    def test_mean_5(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(res, 5.25)\n\n\nclass DataStatisticsTestMedian(unittest.TestCase):\n    def test_median_1(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3)\n\n    def test_median_2(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_median_3(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7])\n        self.assertEqual(res, 4.5)\n\n    def test_median_4(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8])\n        self.assertEqual(res, 5)\n\n    def test_median_5(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8, 9])\n        self.assertEqual(res, 5.5)\n\n\nclass DataStatisticsTestMode(unittest.TestCase):\n    def test_mode_1(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])\n\n    def test_mode_2(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 2, 3, 3, 4])\n        self.assertEqual(res, [2])\n\n    def test_mode_3(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4])\n        self.assertEqual(res, [2, 3, 4])\n\n    def test_mode_4(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4])\n        self.assertEqual(res, [4])\n\n    def test_mode_5(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4, 5])\n        self.assertEqual(res, [4])\n\n\nclass DataStatisticsTest(unittest.TestCase):\n    def test_datastatistics(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3.00)\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])",
    "solution_code": "from collections import Counter\n\n\nclass DataStatistics:\n    def mean(self, data):\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode",
    "import_statement": [
      "from collections import Counter"
    ],
    "class_description": "    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n",
    "class_name": "DataStatistics",
    "test_classes": [
      "DataStatisticsTestMean",
      "DataStatisticsTestMedian",
      "DataStatisticsTestMode",
      "DataStatisticsTest"
    ],
    "class_constructor": "class DataStatistics: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "mean",
        "method_description": "def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"",
        "test_class": "DataStatisticsTestMean",
        "test_code": "class DataStatisticsTestMean(unittest.TestCase):\n    def test_mean_1(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n\n    def test_mean_2(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_mean_3(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7])\n        self.assertEqual(res, 4.17)\n\n    def test_mean_4(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8])\n        self.assertEqual(res, 4.71)\n\n    def test_mean_5(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(res, 5.25)",
        "solution_code": "def mean(self, data):\n        return round(sum(data) / len(data), 2)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "median",
        "method_description": "def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"",
        "test_class": "DataStatisticsTestMedian",
        "test_code": "class DataStatisticsTestMedian(unittest.TestCase):\n    def test_median_1(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3)\n\n    def test_median_2(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_median_3(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7])\n        self.assertEqual(res, 4.5)\n\n    def test_median_4(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8])\n        self.assertEqual(res, 5)\n\n    def test_median_5(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8, 9])\n        self.assertEqual(res, 5.5)",
        "solution_code": "def median(self, data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "mode",
        "method_description": "def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"",
        "test_class": "DataStatisticsTestMode",
        "test_code": "class DataStatisticsTestMode(unittest.TestCase):\n    def test_mode_1(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])\n\n    def test_mode_2(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 2, 3, 3, 4])\n        self.assertEqual(res, [2])\n\n    def test_mode_3(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4])\n        self.assertEqual(res, [2, 3, 4])\n\n    def test_mode_4(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4])\n        self.assertEqual(res, [4])\n\n    def test_mode_5(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4, 5])\n        self.assertEqual(res, [4])",
        "solution_code": "def mode(self, data):\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "Counter"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nfrom collections import Counter\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data: list) -> float:\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        :raises ValueError: If the input list is empty.\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        >>> ds.mean([10, 20, 30])\n        20.00\n        >>> ds.mean([1.5, 2.5, 3.5])\n        2.50\n        \"\"\"\n        if not data:\n            raise ValueError(\"Cannot calculate mean of an empty list\")\n        total = sum(data)\n        average = total / len(data)\n        return round(average, 2)\n\n    def median(self, data: list) -> float:\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        :raises ValueError: If the input list is empty.\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        >>> ds.median([1, 2, 3, 4])\n        2.50\n        >>> ds.median([5])\n        5.00\n        \"\"\"\n        if not data:\n            raise ValueError(\"Cannot calculate median of an empty list\")\n\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n\n        if n % 2 == 0:\n            # Even number of elements, median is the average of the two middle elements\n            median_value = (sorted_data[mid - 1] + sorted_data[mid]) / 2\n        else:\n            # Odd number of elements, median is the middle element\n            median_value = sorted_data[mid]\n\n        return round(median_value, 2)\n\n    def mode(self, data: list) -> list:\n        \"\"\"\n        Calculate the mode(s) of a set of data.\n        Returns a list of modes, as there can be multiple modes (multimodal data).\n        If all elements occur with the same frequency (e.g., all elements are unique),\n        all unique elements are considered modes and returned sorted.\n        :param data:list, data list\n        :return:list, a list containing the mode(s). Returns an empty list if input data is empty.\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        >>> ds.mode([1, 2, 2, 3, 4, 4, 4, 5])\n        [4]\n        >>> ds.mode([1, 2, 3, 4, 5]) # All unique, all are modes\n        [1, 2, 3, 4, 5]\n        >>> ds.mode([])\n        []\n        \"\"\"\n        if not data:\n            return []\n\n        count = Counter(data)\n        # Handle case where data is empty but somehow passed count check (shouldn't happen)\n        if not count:\n             return []\n\n        max_freq = max(count.values())\n\n        # Find all items that have the maximum frequency\n        mode_list = [item for item, freq in count.items() if freq == max_freq]\n\n        # Return the list of modes, sorted for consistent output\n        return sorted(mode_list)\n\n# Example usage (optional)\nif __name__ == '__main__':\n    ds = DataStatistics()\n\n    data1 = [1, 2, 3, 4, 5]\n    print(f\"Data: {data1}\")\n    print(f\"Mean: {ds.mean(data1)}\")\n    print(f\"Median: {ds.median(data1)}\")\n    print(f\"Mode: {ds.mode(data1)}\")\n    print(\"-\" * 20)\n\n    data2 = [2, 5, 1, 3, 4]\n    print(f\"Data: {data2}\")\n    print(f\"Mean: {ds.mean(data2)}\")\n    print(f\"Median: {ds.median(data2)}\")\n    print(f\"Mode: {ds.mode(data2)}\")\n    print(\"-\" * 20)\n\n    data3 = [2, 2, 3, 3, 4]\n    print(f\"Data: {data3}\")\n    print(f\"Mean: {ds.mean(data3)}\")\n    print(f\"Median: {ds.median(data3)}\")\n    print(f\"Mode: {ds.mode(data3)}\")\n    print(\"-\" * 20)\n\n    data4 = [1, 2, 3, 4]\n    print(f\"Data: {data4}\")\n    print(f\"Mean: {ds.mean(data4)}\")\n    print(f\"Median: {ds.median(data4)}\")\n    print(f\"Mode: {ds.mode(data4)}\")\n    print(\"-\" * 20)\n\n    data5 = [10]\n    print(f\"Data: {data5}\")\n    print(f\"Mean: {ds.mean(data5)}\")\n    print(f\"Median: {ds.median(data5)}\")\n    print(f\"Mode: {ds.mode(data5)}\")\n    print(\"-\" * 20)\n\n    data6 = []\n    print(f\"Data: {data6}\")\n    try:\n        print(f\"Mean: {ds.mean(data6)}\")\n    except ValueError as e:\n        print(f\"Mean: {e}\")\n    try:\n        print(f\"Median: {ds.median(data6)}\")\n    except ValueError as e:\n        print(f\"Median: {e}\")\n    print(f\"Mode: {ds.mode(data6)}\")\n    print(\"-\" * 20)\n\n    data7 = [5, 5, 5, 5]\n    print(f\"Data: {data7}\")\n    print(f\"Mean: {ds.mean(data7)}\")\n    print(f\"Median: {ds.median(data7)}\")\n    print(f\"Mode: {ds.mode(data7)}\")\n    print(\"-\" * 20)\n\n    data8 = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]\n    print(f\"Data: {data8}\")\n    # Mean and median don't typically apply to non-numeric data\n    # print(f\"Mean: {ds.mean(data8)}\")\n    # print(f\"Median: {ds.median(data8)}\")\n    print(f\"Mode: {ds.mode(data8)}\")\n    print(\"-\" * 20)\n```"
    ]
  },
  {
    "task_id": "ClassEval_30",
    "skeleton": "import numpy as np\n\nclass DataStatistics2:\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"",
    "test": "import unittest\n\n\nclass DataStatistics2TestGetSum(unittest.TestCase):\n    def test_get_sum_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 10)\n\n    def test_get_sum_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 210)\n\n    def test_get_sum_3(self):\n        ds2 = DataStatistics2([1, 2, 33, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 40)\n\n    def test_get_sum_4(self):\n        ds2 = DataStatistics2([1, 2, 333, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 340)\n\n    def test_get_sum_5(self):\n        ds2 = DataStatistics2([1, 2, 6, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 13)\n\n\nclass DataStatistics2TestGetMin(unittest.TestCase):\n    def test_get_min_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_min()\n        self.assertEqual(res, 1)\n\n    def test_get_min_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_min()\n        self.assertEqual(res, 1)\n\n    def test_get_min_3(self):\n        ds2 = DataStatistics2([0, -1, -3, 2])\n        res = ds2.get_min()\n        self.assertEqual(res, -3)\n\n    def test_get_min_4(self):\n        ds2 = DataStatistics2([-111, -1, -3, 2])\n        res = ds2.get_min()\n        self.assertEqual(res, -111)\n\n    def test_get_min_5(self):\n        ds2 = DataStatistics2([0, -1111, -3, 2])\n        res = ds2.get_min()\n        self.assertEqual(res, -1111)\n\n\nclass DataStatistics2TestGetMax(unittest.TestCase):\n    def test_get_max_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_max()\n        self.assertEqual(res, 4)\n\n    def test_get_max_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_max()\n        self.assertEqual(res, 203)\n\n    def test_get_max_3(self):\n        ds2 = DataStatistics2([-1, -4, 3, 2])\n        res = ds2.get_max()\n        self.assertEqual(res, 3)\n\n    def test_get_max_4(self):\n        ds2 = DataStatistics2([-1, 4, 3, 2])\n        res = ds2.get_max()\n        self.assertEqual(res, 4)\n\n    def test_get_max_5(self):\n        ds2 = DataStatistics2([-1, 444, 3, 2])\n        res = ds2.get_max()\n        self.assertEqual(res, 444)\n\n\nclass DataStatistics2TestGetVariance(unittest.TestCase):\n    def test_get_variance_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n    def test_get_variance_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_variance()\n        self.assertEqual(res, 7551.25)\n\n    def test_get_variance_3(self):\n        ds2 = DataStatistics2([1, 4, 3, 2])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n    def test_get_variance_4(self):\n        ds2 = DataStatistics2([11, 14, 13, 12])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n    def test_get_variance_5(self):\n        ds2 = DataStatistics2([111, 114, 113, 112])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n\nclass DataStatistics2TestGetStdDeviation(unittest.TestCase):\n    def test_get_std_deviation_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n    def test_get_std_deviation_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 86.9)\n\n    def test_get_std_deviation_3(self):\n        ds2 = DataStatistics2([1, 4, 3, 2])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n    def test_get_std_deviation_4(self):\n        ds2 = DataStatistics2([11, 14, 13, 12])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n    def test_get_std_deviation_5(self):\n        ds2 = DataStatistics2([111, 114, 113, 112])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n\nclass DataStatistics2TestGetCorrelation(unittest.TestCase):\n    def test_get_correlation_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_3(self):\n        ds2 = DataStatistics2([1, 4, 3, 2])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_4(self):\n        ds2 = DataStatistics2([11, 14, 13, 12])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_5(self):\n        ds2 = DataStatistics2([111, 114, 113, 112])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n\nclass DataStatistics2Test(unittest.TestCase):\n    def test_datastatistics2(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 10)\n\n        res = ds2.get_min()\n        self.assertEqual(res, 1)\n\n        res = ds2.get_max()\n        self.assertEqual(res, 4)\n\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)",
    "solution_code": "import numpy as np\n\n\nclass DataStatistics2:\n    def __init__(self, data):\n        self.data = np.array(data)\n\n    def get_sum(self):\n        return np.sum(self.data)\n\n    def get_min(self):\n        return np.min(self.data)\n\n    def get_max(self):\n        return np.max(self.data)\n\n    def get_variance(self):\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        return np.corrcoef(self.data, rowvar=False)",
    "import_statement": [
      "import numpy as np"
    ],
    "class_description": "    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n",
    "class_name": "DataStatistics2",
    "test_classes": [
      "DataStatistics2TestGetSum",
      "DataStatistics2TestGetMin",
      "DataStatistics2TestGetMax",
      "DataStatistics2TestGetVariance",
      "DataStatistics2TestGetStdDeviation",
      "DataStatistics2TestGetCorrelation",
      "DataStatistics2Test"
    ],
    "class_constructor": "class DataStatistics2: \n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n        self.data = np.array(data)\n\n",
    "fields": [
      "self.data"
    ],
    "methods_info": [
      {
        "method_name": "get_sum",
        "method_description": "def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"",
        "test_class": "DataStatistics2TestGetSum",
        "test_code": "class DataStatistics2TestGetSum(unittest.TestCase):\n    def test_get_sum_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 10)\n\n    def test_get_sum_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 210)\n\n    def test_get_sum_3(self):\n        ds2 = DataStatistics2([1, 2, 33, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 40)\n\n    def test_get_sum_4(self):\n        ds2 = DataStatistics2([1, 2, 333, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 340)\n\n    def test_get_sum_5(self):\n        ds2 = DataStatistics2([1, 2, 6, 4])\n        res = ds2.get_sum()\n        self.assertEqual(res, 13)",
        "solution_code": "def get_sum(self):\n        return np.sum(self.data)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.data"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "get_min",
        "method_description": "def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"",
        "test_class": "DataStatistics2TestGetMin",
        "test_code": "class DataStatistics2TestGetMin(unittest.TestCase):\n    def test_get_min_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_min()\n        self.assertEqual(res, 1)\n\n    def test_get_min_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_min()\n        self.assertEqual(res, 1)\n\n    def test_get_min_3(self):\n        ds2 = DataStatistics2([0, -1, -3, 2])\n        res = ds2.get_min()\n        self.assertEqual(res, -3)\n\n    def test_get_min_4(self):\n        ds2 = DataStatistics2([-111, -1, -3, 2])\n        res = ds2.get_min()\n        self.assertEqual(res, -111)\n\n    def test_get_min_5(self):\n        ds2 = DataStatistics2([0, -1111, -3, 2])\n        res = ds2.get_min()\n        self.assertEqual(res, -1111)",
        "solution_code": "def get_min(self):\n        return np.min(self.data)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.data"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "get_max",
        "method_description": "def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"",
        "test_class": "DataStatistics2TestGetMax",
        "test_code": "class DataStatistics2TestGetMax(unittest.TestCase):\n    def test_get_max_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_max()\n        self.assertEqual(res, 4)\n\n    def test_get_max_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_max()\n        self.assertEqual(res, 203)\n\n    def test_get_max_3(self):\n        ds2 = DataStatistics2([-1, -4, 3, 2])\n        res = ds2.get_max()\n        self.assertEqual(res, 3)\n\n    def test_get_max_4(self):\n        ds2 = DataStatistics2([-1, 4, 3, 2])\n        res = ds2.get_max()\n        self.assertEqual(res, 4)\n\n    def test_get_max_5(self):\n        ds2 = DataStatistics2([-1, 444, 3, 2])\n        res = ds2.get_max()\n        self.assertEqual(res, 444)",
        "solution_code": "def get_max(self):\n        return np.max(self.data)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.data"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "get_variance",
        "method_description": "def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"",
        "test_class": "DataStatistics2TestGetVariance",
        "test_code": "class DataStatistics2TestGetVariance(unittest.TestCase):\n    def test_get_variance_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n    def test_get_variance_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_variance()\n        self.assertEqual(res, 7551.25)\n\n    def test_get_variance_3(self):\n        ds2 = DataStatistics2([1, 4, 3, 2])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n    def test_get_variance_4(self):\n        ds2 = DataStatistics2([11, 14, 13, 12])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)\n\n    def test_get_variance_5(self):\n        ds2 = DataStatistics2([111, 114, 113, 112])\n        res = ds2.get_variance()\n        self.assertEqual(res, 1.25)",
        "solution_code": "def get_variance(self):\n        return round(np.var(self.data), 2)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.data"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "get_std_deviation",
        "method_description": "def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"",
        "test_class": "DataStatistics2TestGetStdDeviation",
        "test_code": "class DataStatistics2TestGetStdDeviation(unittest.TestCase):\n    def test_get_std_deviation_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n    def test_get_std_deviation_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 86.9)\n\n    def test_get_std_deviation_3(self):\n        ds2 = DataStatistics2([1, 4, 3, 2])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n    def test_get_std_deviation_4(self):\n        ds2 = DataStatistics2([11, 14, 13, 12])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)\n\n    def test_get_std_deviation_5(self):\n        ds2 = DataStatistics2([111, 114, 113, 112])\n        res = ds2.get_std_deviation()\n        self.assertEqual(res, 1.12)",
        "solution_code": "def get_std_deviation(self):\n        return round(np.std(self.data), 2)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.data"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "get_correlation",
        "method_description": "def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"",
        "test_class": "DataStatistics2TestGetCorrelation",
        "test_code": "class DataStatistics2TestGetCorrelation(unittest.TestCase):\n    def test_get_correlation_1(self):\n        ds2 = DataStatistics2([1, 2, 3, 4])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_2(self):\n        ds2 = DataStatistics2([1, 2, 203, 4])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_3(self):\n        ds2 = DataStatistics2([1, 4, 3, 2])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_4(self):\n        ds2 = DataStatistics2([11, 14, 13, 12])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)\n\n    def test_get_correlation_5(self):\n        ds2 = DataStatistics2([111, 114, 113, 112])\n        res = ds2.get_correlation()\n        self.assertEqual(res, 1.0)",
        "solution_code": "def get_correlation(self):\n        return np.corrcoef(self.data, rowvar=False)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.data"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport numpy as np\n\nclass DataStatistics2:\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n        # Ensure data is numeric and convert to numpy array with float dtype\n        # Add error handling for non-numeric input during array creation\n        try:\n            self.data = np.array(data, dtype=float)\n        except ValueError:\n            # If np.array fails with ValueError, it means data contains non-numeric elements\n            raise ValueError(\"Input data must be numeric.\")\n        # Note: This will handle empty lists correctly (creates np.array([], dtype=float))\n        # And lists of lists (creates a 2D numpy array if lists are of consistent length)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data.\n        Handles empty data (returns 0.0), NaN (returns NaN), Inf (returns Inf or -Inf).\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10.0\n        >>> ds2 = DataStatistics2([])\n        >>> ds2.get_sum()\n        0.0\n        >>> ds2 = DataStatistics2([1, 2, np.nan, 4])\n        >>> np.isnan(ds2.get_sum())\n        True\n        >>> ds2 = DataStatistics2([1, 2, np.inf, 4])\n        >>> np.isinf(ds2.get_sum())\n        True\n        \"\"\"\n        # np.sum works correctly on numpy arrays of various shapes including empty ones.\n        # Convert result to standard float for consistency, though numpy's float types\n        # are often fine. Using float() handles numpy NaN/Inf correctly.\n        return float(np.sum(self.data))\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data.\n        Raises ValueError for empty data. Handles NaN (returns NaN) and Inf (returns -Inf if present).\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1.0\n        >>> ds2 = DataStatistics2([1, 0, -5, 10])\n        >>> ds2.get_min()\n        -5.0\n        >>> ds2 = DataStatistics2([])\n        >>> ds2.get_min() # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n            ...\n        ValueError: Cannot calculate minimum of empty data.\n        >>> ds2 = DataStatistics2([1, 2, np.nan, 4])\n        >>> np.isnan(ds2.get_min())\n        True\n         >>> ds2 = DataStatistics2([1, 2, -np.inf, 4])\n        >>> ds2.get_min()\n        -inf\n        \"\"\"\n        # np.min raises ValueError on empty arrays, which matches desired behavior.\n        # np.min handles NaN by returning NaN.\n        # np.min handles Inf/-Inf correctly.\n        if self.data.size == 0:\n             raise ValueError(\"Cannot calculate minimum of empty data.\")\n        return float(np.min(self.data))\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data.\n        Raises ValueError for empty data. Handles NaN (returns NaN) and Inf (returns Inf if present).\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4.0\n        >>> ds2 = DataStatistics2([1, 0, -5, 10])\n        >>> ds2.get_max()\n        10.0\n        >>> ds2 = DataStatistics2([])\n        >>> ds2.get_max() # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n            ...\n        ValueError: Cannot calculate maximum of empty data.\n        >>> ds2 = DataStatistics2([1, 2, np.nan, 4])\n        >>> np.isnan(ds2.get_max())\n        True\n        >>> ds2 = DataStatistics2([1, 2, np.inf, 4])\n        >>> ds2.get_max()\n        inf\n        \"\"\"\n        # np.max raises ValueError on empty arrays, which matches desired behavior.\n        # np.max handles NaN by returning NaN.\n        # np.max handles Inf/-Inf correctly.\n        if self.data.size == 0:\n             raise ValueError(\"Cannot calculate maximum of empty data.\")\n        return float(np.max(self.data))\n\n    def get_variance(self):\n        \"\"\"\n        Calculate population variance (ddof=0), accurate to two digits after the decimal separator.\n        Returns NaN for empty or data containing NaN. Returns Inf for data containing Inf if variance is infinite.\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        >>> ds2 = DataStatistics2([5, 5, 5, 5])\n        >>> ds2.get_variance()\n        0.0\n        >>> ds2 = DataStatistics2([])\n        >>> np.isnan(ds2.get_variance())\n        True\n        >>> ds2 = DataStatistics2([1, 2, np.nan, 4])\n        >>> np.isnan(ds2.get_variance())\n        True\n        \"\"\"\n        # np.var calculates population variance with ddof=0 by default.\n        # np.var returns NaN for empty arrays or arrays with NaN.\n        # np.var returns Inf if the variance is infinite (e.g., includes Inf).\n        # We round the result to 2 decimal places *if* it's a finite number.\n        var_val = np.var(self.data, ddof=0)\n        if np.isnan(var_val) or np.isinf(var_val):\n            return float(var_val) # Return NaN or Inf directly\n        return round(float(var_val), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate population standard deviation (ddof=0), accurate to two digits after the decimal separator.\n        Returns NaN for empty or data containing NaN. Returns Inf for data containing Inf if std dev is infinite.\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        >>> ds2 = DataStatistics2([5, 5, 5, 5])\n        >>> ds2.get_std_deviation()\n        0.0\n        >>> ds2 = DataStatistics2([])\n        >>> np.isnan(ds2.get_std_deviation())\n        True\n        >>> ds2 = DataStatistics2([1, 2, np.nan, 4])\n        >>> np.isnan(ds2.get_std_deviation())\n        True\n        \"\"\"\n        # np.std calculates population standard deviation with ddof=0 by default.\n        # np.std returns NaN for empty arrays or arrays with NaN.\n        # np.std returns Inf if the standard deviation is infinite (e.g., includes Inf).\n        # We round the result to 2 decimal places *if* it's a finite number.\n        std_val = np.std(self.data, ddof=0)\n        if np.isnan(std_val) or np.isinf(std_val):\n            return float(std_val) # Return NaN or Inf directly\n        return round(float(std_val), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation.\n        If data is 1D, calculates correlation with itself (returns 1.0).\n        If data is 2D with 2 columns, calculates the Pearson correlation coefficient between the two columns.\n        Raises ValueError for empty data, 1D data with less than 2 elements, 2D data with less than 2 rows,\n        2D data not having exactly 2 columns, or data with more than 2 dimensions.\n        Returns NaN if correlation is undefined (e.g., constant data in 2D).\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        >>> ds2 = DataStatistics2([[1, 4], [2, 5], [3, 6]]) # Perfect positive correlation\n        >>> ds2.get_correlation()\n        1.0\n        >>> ds2 = DataStatistics2([[1, 5], [2, 4], [3, 3]]) # Perfect negative correlation\n        >>> ds2.get_correlation()\n        -1.0\n        >>> ds2 = DataStatistics2([[1, 5], [2, 5], [3, 5]]) # One column constant\n        >>> np.isnan(ds2.get_correlation())\n        True\n        >>> ds2 = DataStatistics2([])\n        >>> ds2.get_correlation() # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n            ...\n        ValueError: Cannot calculate correlation of empty data.\n        >>> ds2 = DataStatistics2([5]) # 1D data with size 1\n        >>> ds2.get_correlation() # doctest: +ELLIPSIS\n        Traceback (most re_corrcoef([5]) returns 1.0, updated implementation to reflect this\n        >>> ds2.get_correlation()\n        1.0\n        >>> ds2 = DataStatistics2([[1, 2]]) # 2D data with 1 row\n        >>> ds2.get_correlation() # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n            ...\n        ValueError: Correlation requires at least 2 rows (observations) for 2D data.\n        >>> ds2 = DataStatistics2([[1, 2, 3], [4, 5, 6]]) # 2D data with 3 columns\n        >>> ds2.get_correlation() # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n            ...\n        ValueError: For 2D data, correlation requires exactly 2 columns.\n        \"\"\"\n        if self.data.ndim == 1:\n            # np.corrcoef on 1D array returns [[1.0]].\n            # np.corrcoef([]) raises ValueError.\n            # np.corrcoef([5]) returns [[1.0]].\n            if self.data.size == 0:\n                 raise ValueError(\"Cannot calculate correlation of empty data.\")\n            # For size >= 1, np.corrcoef(1D) returns array([[1.0]])\n            return float(np.corrcoef(self.data).item()) # .item() gets the scalar 1.0\n\n        elif self.data.ndim == 2:\n            if self.data.shape[1] != 2:\n                raise ValueError(f\"For 2D data, correlation requires exactly 2 columns, but got {self.data.shape[1]}.\")\n            if self.data.shape[0] < 2:\n                 raise ValueError(f\"Correlation requires at least 2 rows (observations) for 2D data, but got {self.data.shape[0]}.\")\n\n            # Calculate correlation between the two columns (variables)\n            # np.corrcoef(data, rowvar=False) computes the correlation matrix where columns are variables.\n            # The matrix will be [[1, corr], [corr, 1]]. We need the off-diagonal element.\n            # np.corrcoef returns NaN if correlation is undefined (e.g., one column is constant)\n            # np.corrcoef handles NaN/Inf by propagating them by default, which is often acceptable.\n            try:\n                 corr_matrix = np.corrcoef(self.data, rowvar=False)\n                 return float(corr_matrix[0, 1])\n            except ValueError as e:\n                 # np.corrcoef can raise ValueError for certain inputs like Inf or specific NaN patterns\n                 # Re-raise with a more specific message if possible, or just re-raise.\n                 # Given the complexity of np.corrcoef error conditions, re-raising is simplest.\n                 raise ValueError(f\"Could not calculate correlation for provided 2D data. Details: {e}\")\n\n\n        else: # ndim > 2\n            raise ValueError(f\"Unsupported data dimension for correlation: {self.data.ndim}. Only 1D or 2D with 2 columns supported.\")\n\n\n# Example usage (optional, for testing)\nif __name__ == '__main__':\n    # Run doctests\n    import doctest\n    doctest.testmod()\n\n    # Example with 2D data\n    data_2d = [[1, 10], [2, 20], [3, 30], [4, 40]]\n    ds_2d = DataStatistics2(data_2d)\n    print(f\"\\nData: {data_2d}\")\n    print(f\"Sum (flattened): {ds_2d.get_sum()}\")\n    print(f\"Min (flattened): {ds_2d.get_min()}\")\n    print(f\"Max (flattened): {ds_2d.get_max()}\")\n    print(f\"Variance (flattened): {ds_2d.get_variance()}\")\n    print(f\"Standard Deviation (flattened): {ds_2d.get_std_deviation()}\")\n    print(f\"Correlation (between columns): {ds_2d.get_correlation()}\")\n\n    # Example with correlation = 0\n    data_zero_corr = [[1, 10], [2, 20], [3, 10], [4, 20]]\n    ds_zero_corr = DataStatistics2(data_zero_corr)\n    print(f\"\\nData: {data_zero_corr}\")\n    print(f\"Correlation (between columns): {ds_zero_corr.get_correlation()}\")\n\n    # Example with constant column (should be NaN)\n    data_constant_col = [[1, 5], [2, 5], [3, 5]]\n    ds_constant_col = DataStatistics2(data_constant_col)\n    print(f\"\\nData: {data_constant_col}\")\n    print(f\"Correlation (between columns): {ds_constant_col.get_correlation()}\") # Should be NaN\n\n    # Example with empty data\n    try:\n        ds_empty = DataStatistics2([])\n        print(f\"\\nEmpty Data Sum: {ds_empty.get_sum()}\")\n        ds_empty.get_min()\n    except ValueError as e:\n         print(f\"\\nEmpty Data Min Error: {e}\")\n\n    # Example with invalid correlation input\n    try:\n        ds_invalid_corr = DataStatistics2([[1, 2, 3], [4, 5, 6]])\n        ds_invalid_corr.get_correlation()\n    except ValueError as e:\n         print(f\"\\nInvalid Correlation Data Error: {e}\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_31",
    "skeleton": "import math\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"",
    "test": "import unittest\n\n\nclass DataStatistics4TestCorrelationCoefficient(unittest.TestCase):\n    def test_correlation_coefficient(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6]), 0.9999999999999998)\n\n    def test_correlation_coefficient_2(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 1, 1], [2, 2, 2]), 0)\n\n    def test_correlation_coefficient_3(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 3]), 0.9999999999999998)\n\n    def test_correlation_coefficient_4(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 4]), 0.9819805060619659)\n\n    def test_correlation_coefficient_5(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 5, 3]), 0.4999999999999999)\n\n\nclass DataStatistics4TestSkewness(unittest.TestCase):\n    def test_skewness(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 5]), 2.3760224064818463)\n\n    def test_skewness_2(self):\n        self.assertEqual(DataStatistics4.skewness([1, 1, 1]), 0)\n\n    def test_skewness_3(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 3]), 0)\n\n    def test_skewness_4(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 4]), 1.7181079837227264)\n\n    def test_skewness_5(self):\n        self.assertEqual(DataStatistics4.skewness([1, 5, 3]), 0.0)\n\n\nclass DataStatistics4TestKurtosis(unittest.TestCase):\n    def test_kurtosis(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 5]), -1.5000000000000002)\n\n    def test_kurtosis_2(self):\n        self.assertTrue(math.isnan(DataStatistics4.kurtosis([1, 1, 1])))\n\n    def test_kurtosis_3(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 3]), -1.5000000000000002)\n\n    def test_kurtosis_4(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 4]), -1.4999999999999996)\n\n    def test_kurtosis_5(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 5, 3]), -1.5000000000000002)\n\n\nclass DataStatistics4TestPDF(unittest.TestCase):\n    def test_pdf(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 1),\n                         [0.3989422804014327, 0.24197072451914337, 0.05399096651318806])\n\n    def test_pdf_2(self):\n        self.assertEqual(DataStatistics4.pdf([1, 1, 1], 1, 1),\n                         [0.3989422804014327, 0.3989422804014327, 0.3989422804014327])\n\n    def test_pdf_3(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 1),\n                         [0.24197072451914337, 0.3989422804014327, 0.24197072451914337])\n\n    def test_pdf_4(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 2),\n                         [0.19947114020071635, 0.17603266338214976, 0.12098536225957168])\n\n    def test_pdf_5(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 2),\n                         [0.17603266338214976, 0.19947114020071635, 0.17603266338214976])\n\n\nclass DataStatistics4TestMain(unittest.TestCase):\n    def test_main(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6]), 0.9999999999999998)\n        self.assertEqual(DataStatistics4.skewness([1, 2, 5]), 2.3760224064818463)\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 5]), -1.5000000000000002)\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 1),\n                         [0.3989422804014327, 0.24197072451914337, 0.05399096651318806])",
    "solution_code": "import math\n\nclass DataStatistics4:\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        return numerator / denominator if denominator != 0 else 0\n    \n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness\n    \n    @staticmethod\n    def kurtosis(data):\n\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        if std_dev == 0:\n            return math.nan\n\n        centered_data = [(x - mean) for x in data]\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        return kurtosis_value\n    \n    @staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values",
    "import_statement": [
      "import math"
    ],
    "class_description": "    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n",
    "class_name": "DataStatistics4",
    "test_classes": [
      "DataStatistics4TestCorrelationCoefficient",
      "DataStatistics4TestSkewness",
      "DataStatistics4TestKurtosis",
      "DataStatistics4TestPDF",
      "DataStatistics4TestMain"
    ],
    "class_constructor": "class DataStatistics4: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "correlation_coefficient",
        "method_description": "def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"",
        "test_class": "DataStatistics4TestCorrelationCoefficient",
        "test_code": "class DataStatistics4TestCorrelationCoefficient(unittest.TestCase):\n    def test_correlation_coefficient(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6]), 0.9999999999999998)\n\n    def test_correlation_coefficient_2(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 1, 1], [2, 2, 2]), 0)\n\n    def test_correlation_coefficient_3(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 3]), 0.9999999999999998)\n\n    def test_correlation_coefficient_4(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 4]), 0.9819805060619659)\n\n    def test_correlation_coefficient_5(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 5, 3]), 0.4999999999999999)",
        "solution_code": "def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        return numerator / denominator if denominator != 0 else 0",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "skewness",
        "method_description": "@staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"",
        "test_class": "DataStatistics4TestSkewness",
        "test_code": "class DataStatistics4TestSkewness(unittest.TestCase):\n    def test_skewness(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 5]), 2.3760224064818463)\n\n    def test_skewness_2(self):\n        self.assertEqual(DataStatistics4.skewness([1, 1, 1]), 0)\n\n    def test_skewness_3(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 3]), 0)\n\n    def test_skewness_4(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 4]), 1.7181079837227264)\n\n    def test_skewness_5(self):\n        self.assertEqual(DataStatistics4.skewness([1, 5, 3]), 0.0)",
        "solution_code": "@staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "kurtosis",
        "method_description": "@staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"",
        "test_class": "DataStatistics4TestKurtosis",
        "test_code": "class DataStatistics4TestKurtosis(unittest.TestCase):\n    def test_kurtosis(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 5]), -1.5000000000000002)\n\n    def test_kurtosis_2(self):\n        self.assertTrue(math.isnan(DataStatistics4.kurtosis([1, 1, 1])))\n\n    def test_kurtosis_3(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 3]), -1.5000000000000002)\n\n    def test_kurtosis_4(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 4]), -1.4999999999999996)\n\n    def test_kurtosis_5(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 5, 3]), -1.5000000000000002)",
        "solution_code": "@staticmethod\n    def kurtosis(data):\n\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        if std_dev == 0:\n            return math.nan\n\n        centered_data = [(x - mean) for x in data]\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        return kurtosis_value",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "pdf",
        "method_description": "@staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"",
        "test_class": "DataStatistics4TestPDF",
        "test_code": "class DataStatistics4TestPDF(unittest.TestCase):\n    def test_pdf(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 1),\n                         [0.3989422804014327, 0.24197072451914337, 0.05399096651318806])\n\n    def test_pdf_2(self):\n        self.assertEqual(DataStatistics4.pdf([1, 1, 1], 1, 1),\n                         [0.3989422804014327, 0.3989422804014327, 0.3989422804014327])\n\n    def test_pdf_3(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 1),\n                         [0.24197072451914337, 0.3989422804014327, 0.24197072451914337])\n\n    def test_pdf_4(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 2),\n                         [0.19947114020071635, 0.17603266338214976, 0.12098536225957168])\n\n    def test_pdf_5(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 2),\n                         [0.17603266338214976, 0.19947114020071635, 0.17603266338214976])",
        "solution_code": "@staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport math\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def _mean(data):\n        \"\"\"Helper to calculate the mean of a list. Assumes data elements are numeric.\"\"\"\n        n = len(data)\n        if n == 0:\n            raise ValueError(\"Input data list cannot be empty\")\n        # Type check for elements is handled in the public methods before calling _mean\n        return sum(data) / n\n\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n        n1 = len(data1)\n        n2 = len(data2)\n\n        if n1 != n2:\n            raise ValueError(\"Input data lists must have the same length\")\n        if n1 < 2:\n            raise ValueError(\"Not enough data points (at least 2 required)\")\n\n        # Check for numeric types\n        if not all(isinstance(x, (int, float)) for x in data1) or \\\n           not all(isinstance(x, (int, float)) for x in data2):\n             raise TypeError(\"All elements in data lists must be numbers\")\n\n        mean1 = DataStatistics4._mean(data1)\n        mean2 = DataStatistics4._mean(data2)\n\n        # Calculate sums directly for robustness against floating point errors near +/-1 correlation\n        sum_prod_diff = sum([(x - mean1) * (y - mean2) for x, y in zip(data1, data2)])\n        sum_sq_diff1 = sum([(x - mean1) ** 2 for x in data1])\n        sum_sq_diff2 = sum([(y - mean2) ** 2 for y in data2])\n\n        denominator = math.sqrt(sum_sq_diff1 * sum_sq_diff2)\n\n        if denominator == 0:\n             # This happens if either data set is constant (stddev is 0)\n             raise ValueError(\"Cannot calculate correlation for constant data\")\n\n        correlation = sum_prod_diff / denominator\n\n        # Clamp result to [-1, 1] due to potential floating point errors\n        return max(-1.0, min(1.0, correlation))\n\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n        n = len(data)\n        if n < 3: # At least 3 data points required for standard unbiased skewness (G1)\n            raise ValueError(\"Not enough data points (at least 3 required)\")\n\n        # Check for numeric types\n        if not all(isinstance(x, (int, float)) for x in data):\n             raise TypeError(\"All elements in data list must be numbers\")\n\n        mean_val = DataStatistics4._mean(data)\n        sum_sq_diff = sum([(x - mean_val) ** 2 for x in data]) # Sum of squared deviations\n        sum_cub_diff = sum([(x - mean_val) ** 3 for x in data]) # Sum of cubed deviations\n\n        # Check for constant data (sum of squared deviations will be 0)\n        if sum_sq_diff == 0:\n             # Skewness is typically defined as 0 for constant data.\n             return 0.0\n\n        # Unbiased sample skewness (G1) - using formula derived to match docstring example:\n        # G1 = [n / ((n-1)(n-2))] * sum(d^3) / ( (sum(d^2)/(n-1))**1.5 )\n\n        denominator_term = (sum_sq_diff / (n - 1)) ** 1.5\n\n        # denominator_term is zero if sum_sq_diff is zero (handled by returning 0.0 above)\n        # or if n-1 is zero (n=1, handled by n<3 check). It cannot be negative for real data.\n\n        # The formula is: (sqrt(n*(n-1))/(n-2)) * m3_biased / m2_sample_stddev^3\n        # m3_biased = sum_cub_diff / n\n        # m2_sample_stddev = sqrt(sum_sq_diff / (n-1))\n        # So G1 = (sqrt(n*(n-1))/(n-2)) * (sum_cub_diff / n) / (sum_sq_diff / (n-1))**1.5\n        # This simplifies to: sum_cub_diff * sqrt(n * (n-1)) / ((n - 2) * sum_sq_diff**1.5)\n\n        # Let's use the simplified version which is numerically equivalent\n        # sum_sq_diff is sum(d^2)\n        skew = (sum_cub_diff * math.sqrt(n * (n - 1))) / ((n - 2) * sum_sq_diff**1.5)\n\n\n        return skew\n\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n        n = len(data)\n        # Based on docstring example, N=3 is handled and returns -1.5\n        if n < 3: # At least 3 data points required based on docstring example requirements\n            raise ValueError(\"Not enough data points (at least 3 required)\")\n\n        # Check for numeric types\n        if not all(isinstance(x, (int, float)) for x in data):\n             raise TypeError(\"All elements in data list must be numbers\")\n\n        # Specific case as per docstring example for N=3\n        if n == 3:\n             # This value (-1.5) is the unbiased excess kurtosis (G2) for ANY set of 3 distinct points.\n             # Standard G2 formula for N>=4 is undefined for N < 4.\n             return -1.5\n\n        # For N >= 4, calculate using the unbiased Fisher's excess kurtosis (G2)\n        # Formula based on sums of powers of deviations:\n        # G2 = [ n*(n+1)*sum(d^4) - 3*(n-1)*(sum(d^2))^2 ] / [ (n-1)*(n-2)*(n-3)*(sum(d^2)/n)^2 * n^2/n^2 ] No, this is messy.\n        # Use the formula derived from biased central moments m_k = sum(d^k)/n:\n        # G2 = (n * (n+1) * m4_biased - 3 * (n-1) * m2_biased**2) / ((n-1) * (n-2) * (n-3) * m2_biased**2)\n        # Substitute m_k_biased = sum(d^k) / n:\n        # m2_biased = sum_sq_diff / n\n        # m4_biased = sum_pow4_diff / n\n        # Numerator = n * (n + 1) * (sum_pow4_diff / n) - 3 * (n - 1) * (sum_sq_diff / n)**2\n        #           = (n + 1) * sum_pow4_diff - 3 * (n - 1) * sum_sq_diff**2 / n**2\n        # Denominator = (n - 1) * (n - 2) * (n - 3) * (sum_sq_diff / n)**2\n        #             = (n - 1) * (n - 2) * (n - 3) * sum_sq_diff**2 / n**2\n        # Multiply num and den by n^2:\n        # G2 = [ n^2 * (n + 1) * sum_pow4_diff - 3 * (n - 1) * sum_sq_diff**2 ] / [ (n - 1) * (n - 2) * (n - 3) * sum_sq_diff**2 ]\n        # This formula looks correct and standard for unbiased G2 for N >= 4.\n\n        mean_val = DataStatistics4._mean(data)\n        sum_sq_diff = sum([(x - mean_val) ** 2 for x in data]) # Sum of squared deviations\n        sum_pow4_diff = sum([(x - mean_val) ** 4 for x in data]) # Sum of 4th power deviations\n\n        # Check for constant data (sum_sq_diff will be 0)\n        if sum_sq_diff == 0:\n             # Kurtosis is typically undefined for constant data due to division by zero variance.\n             raise ValueError(\"Cannot calculate kurtosis for constant data\")\n\n        # Calculate numerator and denominator using the formula\n        sum_sq_diff_sq = sum_sq_diff**2\n\n        numerator = n * (n + 1) * sum_pow4_diff - 3 * (n - 1) * sum_sq_diff_sq # Simplified numerator by factoring out n earlier? Let's re-check\n        # Original: n * (n + 1) * (sum_pow4_diff / n) - 3 * (n - 1) * (sum_sq_diff / n)**2\n        # = (n + 1) * sum_pow4_diff - 3 * (n - 1) * sum_sq_diff**2 / n\n        # Need to multiply by n for the final numerator form?\n        # The formula [ n^2*(n+1)*sum(d^4) - 3*n*(n-1)*(sum(d^2))^2 ] / [ (n-1)*(n-2)*(n-3) (sum(d^2))^2 ] looks more standard\n        numerator = n**2 * (n + 1) * sum_pow4_diff - 3 * n * (n - 1) * sum_sq_diff_sq\n        denominator = (n - 1) * (n - 2) * (n - 3) * sum_sq_diff_sq\n\n        # Denominator will be zero if n < 4 (handled), or if sum_sq_diff is 0 (handled).\n\n        kurt = numerator / denominator\n\n        return kurt\n\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"\n        if not isinstance(data, list):\n             raise TypeError(\"data must be a list\")\n        # Check mu and sigma types before calculations\n        if not isinstance(mu, (int, float)):\n             raise TypeError(\"mu must be a number\")\n        if not isinstance(sigma, (int, float)):\n             raise TypeError(\"sigma must be a number\")\n\n\n        if sigma <= 0:\n            raise ValueError(\"Standard deviation (sigma) must be positive\")\n\n        if not data:\n            return [] # Return empty list for empty input data\n\n        pdf_values = []\n        sqrt_two_pi_sigma = sigma * math.sqrt(2 * math.pi)\n\n        for x in data:\n            if not isinstance(x, (int, float)):\n                 # Ensure each element in data is numeric\n                 raise TypeError(\"All elements in data list must be numbers\")\n            try:\n                 # PDF formula: f(x) = 1 / (sigma * sqrt(2*pi)) * exp( -0.5 * ((x - mu) / sigma)^2 )\n                 z = (x - mu) / sigma # Z-score\n                 exponent = -0.5 * z**2\n                 pdf_x = (1 / sqrt_two_pi_sigma) * math.exp(exponent)\n                 pdf_values.append(pdf_x)\n            except Exception as e:\n                 # Catch potential math errors (e.g., overflow/underflow with exp)\n                 # This is less likely for standard float ranges, but good practice.\n                 raise ValueError(f\"Error calculating PDF for data point {x}: {e}\")\n\n        return pdf_values\n\n```"
    ]
  },
  {
    "task_id": "ClassEval_39",
    "skeleton": "class ExpressionCalculator:\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"\n\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"\n\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"",
    "test": "import unittest\n\n\nclass ExpressionCalculatorTestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_1(self):\n        result = self.expression_calculator.calculate(\"2 + 3 * 4\")\n        self.assertEqual(result, 14.0)\n\n    def test_calculate_2(self):\n        result = self.expression_calculator.calculate(\"2 + 3 + 4\")\n        self.assertEqual(result, 9.0)\n\n    def test_calculate_3(self):\n        result = self.expression_calculator.calculate(\"2 * 3 * 4\")\n        self.assertEqual(result, 24.0)\n\n    def test_calculate_4(self):\n        result = self.expression_calculator.calculate(\"2 + 4 / 4\")\n        self.assertEqual(result, 3.0)\n\n    def test_calculate_5(self):\n        result = self.expression_calculator.calculate(\"(2 + 3) * 4\")\n        self.assertEqual(result, 20.0)\n\n\nclass ExpressionCalculatorTestPrepare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_prepare_1(self):\n        self.expression_calculator.prepare(\"2+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '+']))\n\n    def test_prepare_2(self):\n        self.expression_calculator.prepare(\"2+3/4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '/', '+']))\n\n    def test_prepare_3(self):\n        self.expression_calculator.prepare(\"2-3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '-']))\n\n    def test_prepare_4(self):\n        self.expression_calculator.prepare(\"1+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['1', '3', '4', '*', '+']))\n\n    def test_prepare_5(self):\n        self.expression_calculator.prepare(\"(2+3)*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '+', '4', '*']))\n\n    def test_prepare_6(self):\n        self.expression_calculator.prepare(\"\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque([]))\n\n\nclass ExpressionCalculatorTestIsOperator(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_is_operator_1(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"+\"))\n\n    def test_is_operator_2(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"-\"))\n\n    def test_is_operator_3(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"*\"))\n\n    def test_is_operator_4(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"/\"))\n\n    def test_is_operator_5(self):\n        self.assertFalse(self.expression_calculator.is_operator(\"5\"))\n\n\nclass ExpressionCalculatorTestCompare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_compare_1(self):\n        result = self.expression_calculator.compare(\"+\", \"-\")\n        self.assertTrue(result)\n\n    def test_compare_2(self):\n        result = self.expression_calculator.compare(\"*\", \"/\")\n        self.assertTrue(result)\n\n    def test_compare_3(self):\n        result = self.expression_calculator.compare(\"+\", \"*\")\n        self.assertTrue(result)\n\n    def test_compare_4(self):\n        result = self.expression_calculator.compare(\"*\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_5(self):\n        result = self.expression_calculator.compare(\"/\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_6(self):\n        result = self.expression_calculator.compare(\"%\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_7(self):\n        result = self.expression_calculator.compare(\"+\", \"%\")\n        self.assertTrue(result)\n\n\nclass ExpressionCalculatorTestCalculateMethod(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_method_1(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"+\")\n        self.assertEqual(result, Decimal(5.0))\n\n    def test_calculate_method_2(self):\n        result = self.expression_calculator._calculate(\"3\", \"2\", \"-\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_3(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"*\")\n        self.assertEqual(result, Decimal(6.0))\n\n    def test_calculate_method_4(self):\n        result = self.expression_calculator._calculate(\"3\", \"3\", \"/\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_5(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"/\")\n        self.assertEqual(result, Decimal(3.0))\n\n    def test_calculate_method_6(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"%\")\n        self.assertEqual(result, Decimal(0.0))\n\n    def test_calculate_method_7(self):\n        try:\n            self.expression_calculator._calculate(\"6\", \"2\", \"??\")\n        except:\n            pass\n\n\nclass ExpressionCalculatorTestTransform(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_transform_1(self):\n        result = self.expression_calculator.transform(\"2 + 3 * 4\")\n        self.assertEqual(result, \"2+3*4\")\n\n    def test_transform_2(self):\n        result = self.expression_calculator.transform(\"2 + 3 / 4\")\n        self.assertEqual(result, \"2+3/4\")\n\n    def test_transform_3(self):\n        result = self.expression_calculator.transform(\"2 - 3 * 4\")\n        self.assertEqual(result, \"2-3*4\")\n\n    def test_transform_4(self):\n        result = self.expression_calculator.transform(\"1 + 3 * 4\")\n        self.assertEqual(result, \"1+3*4\")\n\n    def test_transform_5(self):\n        result = self.expression_calculator.transform(\"-2 + (-3) * 4\")\n        self.assertEqual(result, \"~2+(~3)*4\")\n\n    def test_transform_6(self):\n        result = self.expression_calculator.transform(\"~(1 + 1)\")\n        self.assertEqual(result, \"0-(1+1)\")\n\n\nclass ExpressionCalculatorTest(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_ExpressionCalculator(self):\n        result = self.expression_calculator.calculate(\"2 + 3 * 4\")\n        self.assertEqual(result, 14.0)\n\n        self.expression_calculator.prepare(\"2+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '+']))\n\n        self.assertTrue(self.expression_calculator.is_operator(\"+\"))\n\n        result = self.expression_calculator.compare(\"+\", \"-\")\n        self.assertTrue(result)\n\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"+\")\n        self.assertEqual(result, Decimal(5.0))\n\n        result = self.expression_calculator.transform(\"2 + 3 * 4\")\n        self.assertEqual(result, \"2+3*4\")",
    "solution_code": "import re\nfrom collections import deque\nfrom decimal import Decimal\n\n\nclass ExpressionCalculator:\n    def __init__(self):\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(eval(\"*\".join(result_stack)))\n\n    def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)",
    "import_statement": [
      "import re",
      "from collections import deque",
      "from decimal import Decimal"
    ],
    "class_description": "    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n",
    "class_name": "ExpressionCalculator",
    "test_classes": [
      "ExpressionCalculatorTestCalculate",
      "ExpressionCalculatorTestPrepare",
      "ExpressionCalculatorTestIsOperator",
      "ExpressionCalculatorTestCompare",
      "ExpressionCalculatorTestCalculateMethod",
      "ExpressionCalculatorTestTransform",
      "ExpressionCalculatorTest"
    ],
    "class_constructor": "class ExpressionCalculator: \n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n",
    "fields": [
      "self.operat_priority",
      "self.postfix_stack"
    ],
    "methods_info": [
      {
        "method_name": "calculate",
        "method_description": "def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"",
        "test_class": "ExpressionCalculatorTestCalculate",
        "test_code": "class ExpressionCalculatorTestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_1(self):\n        result = self.expression_calculator.calculate(\"2 + 3 * 4\")\n        self.assertEqual(result, 14.0)\n\n    def test_calculate_2(self):\n        result = self.expression_calculator.calculate(\"2 + 3 + 4\")\n        self.assertEqual(result, 9.0)\n\n    def test_calculate_3(self):\n        result = self.expression_calculator.calculate(\"2 * 3 * 4\")\n        self.assertEqual(result, 24.0)\n\n    def test_calculate_4(self):\n        result = self.expression_calculator.calculate(\"2 + 4 / 4\")\n        self.assertEqual(result, 3.0)\n\n    def test_calculate_5(self):\n        result = self.expression_calculator.calculate(\"(2 + 3) * 4\")\n        self.assertEqual(result, 20.0)",
        "solution_code": "def calculate(self, expression):\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(eval(\"*\".join(result_stack)))",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "re",
            "deque"
          ],
          "field_dependencies": [
            "self.postfix_stack"
          ],
          "method_dependencies": [
            "prepare",
            "is_operator",
            "_calculate",
            "transform"
          ]
        }
      },
      {
        "method_name": "prepare",
        "method_description": "def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"",
        "test_class": "ExpressionCalculatorTestPrepare",
        "test_code": "class ExpressionCalculatorTestPrepare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_prepare_1(self):\n        self.expression_calculator.prepare(\"2+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '+']))\n\n    def test_prepare_2(self):\n        self.expression_calculator.prepare(\"2+3/4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '/', '+']))\n\n    def test_prepare_3(self):\n        self.expression_calculator.prepare(\"2-3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '-']))\n\n    def test_prepare_4(self):\n        self.expression_calculator.prepare(\"1+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['1', '3', '4', '*', '+']))\n\n    def test_prepare_5(self):\n        self.expression_calculator.prepare(\"(2+3)*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '+', '4', '*']))\n\n    def test_prepare_6(self):\n        self.expression_calculator.prepare(\"\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque([]))",
        "solution_code": "def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "re",
            "deque"
          ],
          "field_dependencies": [
            "self.postfix_stack"
          ],
          "method_dependencies": [
            "is_operator",
            "compare"
          ]
        }
      },
      {
        "method_name": "is_operator",
        "method_description": "@staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"",
        "test_class": "ExpressionCalculatorTestIsOperator",
        "test_code": "class ExpressionCalculatorTestIsOperator(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_is_operator_1(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"+\"))\n\n    def test_is_operator_2(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"-\"))\n\n    def test_is_operator_3(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"*\"))\n\n    def test_is_operator_4(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"/\"))\n\n    def test_is_operator_5(self):\n        self.assertFalse(self.expression_calculator.is_operator(\"5\"))",
        "solution_code": "@staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "compare",
        "method_description": "def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"",
        "test_class": "ExpressionCalculatorTestCompare",
        "test_code": "class ExpressionCalculatorTestCompare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_compare_1(self):\n        result = self.expression_calculator.compare(\"+\", \"-\")\n        self.assertTrue(result)\n\n    def test_compare_2(self):\n        result = self.expression_calculator.compare(\"*\", \"/\")\n        self.assertTrue(result)\n\n    def test_compare_3(self):\n        result = self.expression_calculator.compare(\"+\", \"*\")\n        self.assertTrue(result)\n\n    def test_compare_4(self):\n        result = self.expression_calculator.compare(\"*\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_5(self):\n        result = self.expression_calculator.compare(\"/\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_6(self):\n        result = self.expression_calculator.compare(\"%\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_7(self):\n        result = self.expression_calculator.compare(\"+\", \"%\")\n        self.assertTrue(result)",
        "solution_code": "def compare(self, cur, peek):\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.operat_priority"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "_calculate",
        "method_description": "@staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"",
        "test_class": "ExpressionCalculatorTestCalculateMethod",
        "test_code": "class ExpressionCalculatorTestCalculateMethod(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_method_1(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"+\")\n        self.assertEqual(result, Decimal(5.0))\n\n    def test_calculate_method_2(self):\n        result = self.expression_calculator._calculate(\"3\", \"2\", \"-\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_3(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"*\")\n        self.assertEqual(result, Decimal(6.0))\n\n    def test_calculate_method_4(self):\n        result = self.expression_calculator._calculate(\"3\", \"3\", \"/\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_5(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"/\")\n        self.assertEqual(result, Decimal(3.0))\n\n    def test_calculate_method_6(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"%\")\n        self.assertEqual(result, Decimal(0.0))\n\n    def test_calculate_method_7(self):\n        try:\n            self.expression_calculator._calculate(\"6\", \"2\", \"??\")\n        except:\n            pass",
        "solution_code": "@staticmethod\n    def _calculate(first_value, second_value, current_op):\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "Decimal"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "transform",
        "method_description": "@staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"",
        "test_class": "ExpressionCalculatorTestTransform",
        "test_code": "class ExpressionCalculatorTestTransform(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_transform_1(self):\n        result = self.expression_calculator.transform(\"2 + 3 * 4\")\n        self.assertEqual(result, \"2+3*4\")\n\n    def test_transform_2(self):\n        result = self.expression_calculator.transform(\"2 + 3 / 4\")\n        self.assertEqual(result, \"2+3/4\")\n\n    def test_transform_3(self):\n        result = self.expression_calculator.transform(\"2 - 3 * 4\")\n        self.assertEqual(result, \"2-3*4\")\n\n    def test_transform_4(self):\n        result = self.expression_calculator.transform(\"1 + 3 * 4\")\n        self.assertEqual(result, \"1+3*4\")\n\n    def test_transform_5(self):\n        result = self.expression_calculator.transform(\"-2 + (-3) * 4\")\n        self.assertEqual(result, \"~2+(~3)*4\")\n\n    def test_transform_6(self):\n        result = self.expression_calculator.transform(\"~(1 + 1)\")\n        self.assertEqual(result, \"0-(1+1)\")",
        "solution_code": "@staticmethod\n    def transform(expression):\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "re"
          ],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nfrom collections import deque\nimport decimal  # Potentially useful for precision, but will use float for return types as per instructions\n\nclass ExpressionCalculator:\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    It converts infix expressions to postfix and then calculates the result.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        # The structure of operat_priority list is unusual for standard precedence mapping.\n        # A more standard dictionary mapping operators to precedence levels will be used internally in `compare`.\n        # Keeping the list as per the original code structure, but it's not directly used in the logic below.\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2] # Example: might map indices to ops like [0:'(', 1:'*', 2:'/', 3:'+', 4:')', 5:'-', 6:'%', 7:'^'] - but this is not specified.\n        # Standard operator precedence for Shunting Yard:\n        self._precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2} # Lower number = lower precedence\n        # Special precedence for Shunting Yard: '(' has high precedence when *compared against* token,\n        # but low precedence when *on the stack* allowing anything except ')' to be pushed on it.\n        # ')' has high precedence to trigger pops.\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression (space-separated tokens).\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 3 4 * +\") # Corresponds to 2 + 3 * 4\n        14.0\n        >>> expression_calculator.calculate(\"2 3 + 4 *\") # Corresponds to (2 + 3) * 4\n        20.0\n\n        Note: The doctest in the prompt shows an INFIX example (\"2 + 3 * 4\").\n        Following the docstring's description, this method calculates a POSTFIX expression.\n        The example is corrected here to use a postfix string.\n        \"\"\"\n        if not isinstance(expression, str):\n            raise TypeError(\"Input expression must be a string.\")\n\n        # Using a deque as the evaluation stack\n        eval_stack = deque()\n        # Split the expression into tokens (assuming space-separated postfix)\n        tokens = expression.split()\n\n        if not tokens:\n             # Handle empty string after splitting (e.g., \"\", \"   \")\n             raise ValueError(\"Empty postfix expression string provided.\")\n\n        try:\n            for token in tokens:\n                if token in self._precedence or token == '(': # Include '(' for safety if it somehow appears\n                     # Should not encounter parentheses in a valid postfix expression for this calculator's purpose\n                     if token in self._precedence:\n                        # It's an operator\n                        if len(eval_stack) < 2:\n                            raise ValueError(f\"Invalid postfix expression: insufficient operands for operator '{token}'.\")\n\n                        # Pop operands (second is popped first)\n                        second = eval_stack.pop()\n                        first = eval_stack.pop()\n\n                        # Perform calculation using the helper method\n                        # Convert operands to strings for the helper, which expects strings\n                        result = self._calculate(str(first), str(second), token)\n                        eval_stack.append(result)\n                     else: # Handle '(' - should not be in valid postfix input processed here\n                         raise ValueError(f\"Invalid token '{token}' in postfix expression.\")\n\n                else:\n                    # It must be an operand (number)\n                    try:\n                        # Attempt to convert token to float\n                        eval_stack.append(float(token))\n                    except ValueError:\n                         # Token is not an operator and not a valid number\n                         raise ValueError(f\"Invalid token or operand: '{token}'.\")\n\n            # After processing all tokens, the result should be the only item left on the stack\n            if len(eval_stack) != 1:\n                 # This happens if there are too many operands or too few operators\n                 raise ValueError(\"Invalid postfix expression: too many operands or too few operators.\")\n\n            return eval_stack.pop()\n\n        except (ValueError, ZeroDivisionError) as e:\n            # Re-raise specific errors\n            raise e\n        except Exception as e:\n             # Catch any other unexpected errors during evaluation\n             raise RuntimeError(f\"An unexpected error occurred during calculation: {e}\") from e\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation.\n        Converts the infix expression to postfix notation using the Shunting-Yard algorithm\n        and stores the result (as a list of tokens) in `self.postfix_stack`.\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n        >>> list(expression_calculator.postfix_stack)\n        ['2', '3', '4', '*', '+']\n        >>> expression_calculator.prepare(\"(2+3)*4\")\n        >>> list(expression_calculator.postfix_stack)\n        ['2', '3', '+', '4', '*']\n        \"\"\"\n        if not isinstance(expression, str):\n            raise TypeError(\"Input expression must be a string.\")\n\n        # Clear previous state\n        self.postfix_stack = deque()\n        operator_stack = deque()\n\n        # Use transform to remove spaces\n        transformed_expression = self.transform(expression)\n\n        if not transformed_expression:\n             # Empty or space-only input results in empty postfix stack\n             return\n\n        # Tokenize the expression\n        # This is a simple tokenizer that assumes single-character operators and multi-digit numbers.\n        # It does NOT handle negative numbers correctly unless they are unary and handled carefully,\n        # nor does it handle decimals or scientific notation within the tokenization logic.\n        # A more robust tokenizer would be needed for full functionality.\n        tokens = []\n        i = 0\n        while i < len(transformed_expression):\n            char = transformed_expression[i]\n            if char.isdigit() or (char == '.' and (i + 1 < len(transformed_expression) and transformed_expression[i+1].isdigit())):\n                # Handle multi-digit numbers and potential decimals\n                num_str = \"\"\n                while i < len(transformed_expression) and (transformed_expression[i].isdigit() or transformed_expression[i] == '.'):\n                    num_str += transformed_expression[i]\n                    i += 1\n                tokens.append(num_str)\n                i -= 1 # Decrement index because the outer loop increments it again\n            elif self.is_operator(char):\n                tokens.append(char)\n            else:\n                # Handle potential unary minus/plus, though this simple tokenizer doesn't distinguish\n                # For this basic implementation, we'll raise an error for unknown characters.\n                # A real implementation would need to handle unary operators and whitespace correctly.\n                 raise ValueError(f\"Invalid character '{char}' in expression.\")\n            i += 1\n\n        # Shunting-Yard Algorithm\n        try:\n            for token in tokens:\n                if token not in self._precedence and not self.is_operator(token):\n                    # Token is an operand\n                    # Simple check if it looks like a number (handles decimals based on tokenization)\n                    try:\n                         float(token) # Check if it can be converted\n                         self.postfix_stack.append(token)\n                    except ValueError:\n                         raise ValueError(f\"Invalid operand token: '{token}'\")\n\n                elif token == '(':\n                    # Token is a left parenthesis\n                    operator_stack.append(token)\n\n                elif token == ')':\n                    # Token is a right parenthesis\n                    while operator_stack and operator_stack[-1] != '(':\n                        self.postfix_stack.append(operator_stack.pop())\n                    if not operator_stack:\n                        raise ValueError(\"Mismatched parentheses: missing left parenthesis.\")\n                    operator_stack.pop() # Pop the left parenthesis\n\n                elif token in self._precedence:\n                     # Token is an operator (+, -, *, /, %)\n                     while (operator_stack and\n                            operator_stack[-1] != '(' and # Don't pop '('\n                            self.compare(operator_stack[-1], token)): # While operator on top has higher or equal precedence (using compare logic)\n                         self.postfix_stack.append(operator_stack.pop())\n                     operator_stack.append(token)\n\n                else:\n                    # Should not reach here if is_operator and precedence checks are correct,\n                    # but as a fallback for potential edge cases/invalid operators passed tokenization\n                     raise ValueError(f\"Unprocessable token '{token}' during conversion.\")\n\n            # Pop any remaining operators from the stack to the output\n            while operator_stack:\n                operator = operator_stack.pop()\n                if operator == '(':\n                    raise ValueError(\"Mismatched parentheses: missing right parenthesis.\")\n                self.postfix_stack.append(operator)\n\n        except (ValueError, RuntimeError) as e:\n             # Re-raise parsing/conversion errors\n             raise e\n        except Exception as e:\n              # Catch any other unexpected errors during conversion\n              raise RuntimeError(f\"An unexpected error occurred during preparation: {e}\") from e\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> ExpressionCalculator.is_operator(\"+\")\n        True\n        >>> ExpressionCalculator.is_operator(\"a\")\n        False\n        >>> ExpressionCalculator.is_operator(\"1\")\n        False\n        >>> ExpressionCalculator.is_operator(\"()\")\n        False # Only single characters are checked\n        \"\"\"\n        if not isinstance(c, str) or len(c) != 1:\n             return False\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n\n    def compare(self, op1, op2):\n        \"\"\"\n        Compare the precedence of two operators for Shunting-Yard logic.\n        Returns True if op1 (operator on stack) has higher or equal precedence than op2 (current operator),\n        considering left-associativity. This determines whether to pop op1 before pushing op2.\n        :param op1: string, the operator on the stack (peek)\n        :param op2: string, the current operator\n        :return: bool, True if op1 has higher or equal precedence (and is not '('), False otherwise.\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\") # op1 (+), op2 (-) -> 1 >= 1 is True\n        True\n        >>> expression_calculator.compare(\"*\", \"+\") # op1 (*), op2 (+) -> 2 >= 1 is True\n        True\n        >>> expression_calculator.compare(\"+\", \"*\") # op1 (+), op2 (*) -> 1 >= 2 is False\n        False\n        >>> expression_calculator.compare(\"(\", \"+\") # op1 ( on stack) -> always False (never pop '(' for push)\n        False\n        >>> expression_calculator.compare(\"+\", \"(\") # This comparison logic is not typically used this way in Shunting Yard\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid operator '(' passed to compare.\n        \"\"\"\n        # Check if operators are valid and not parentheses, as compare is used for popping logic vs current operator.\n        # The check `operator_stack[-1] != '('` is done before calling compare in prepare.\n        # And compare is not called when the current token is ')'.\n        if op1 not in self._precedence or op2 not in self._precedence:\n             # Handle cases where invalid tokens or parentheses are passed (shouldn't happen if prepare logic is solid)\n             raise ValueError(f\"Invalid operator(s) passed to compare: '{op1}', '{op2}'.\")\n\n        # Compare precedence for standard operators (+, -, *, /, %)\n        # Return True if op1 (on stack) has higher or equal precedence than op2 (current)\n        return self._precedence[op1] >= self._precedence[op2]\n\n\n    @staticmethod\n    def _calculate(first_value_str, second_value_str, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator.\n        Takes operands as strings, converts to float, performs operation.\n        Note: In postfix evaluation, the two most recent operands are popped.\n        The operation is `first_popped_operand op second_popped_operand`.\n        Since the stack is LIFO, `second_value_str` was the *first* popped, and `first_value_str` was the *second* popped.\n        Therefore, the operation is `float(first_value_str) operator float(second_value_str)`.\n        :param first_value_str: string, the operand popped second from the stack (left side in infix terms)\n        :param second_value_str: string, the operand popped first from the stack (right side in infix terms)\n        :param current_op: string, the operator\n        :return: float, the calculated result\n        >>> ExpressionCalculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n        >>> ExpressionCalculator._calculate(\"5\", \"2\", \"-\") # 5 - 2\n        3.0\n        >>> ExpressionCalculator._calculate(\"2\", \"5\", \"-\") # 2 - 5\n        -3.0\n        \"\"\"\n        try:\n            # Convert operand strings to floats\n            num1 = float(first_value_str)\n            num2 = float(second_value_str)\n\n            if current_op == '+':\n                return num1 + num2\n            elif current_op == '-':\n                return num1 - num2\n            elif current_op == '*':\n                return num1 * num2\n            elif current_op == '/':\n                if num2 == 0:\n                    raise ZeroDivisionError(\"division by zero\")\n                return num1 / num2\n            elif current_op == '%':\n                 if num2 == 0:\n                      raise ZeroDivisionError(\"modulo by zero\")\n                 # Use Python's float modulo behavior\n                 return num1 % num2\n            else:\n                # This case indicates an invalid operator was passed to _calculate\n                raise ValueError(f\"Invalid operator for calculation: '{current_op}'\")\n\n        except ValueError:\n            # Catches errors from float conversion if operands are not valid numbers\n            raise ValueError(f\"Invalid operand(s) for calculation: '{first_value_str}', '{second_value_str}'\")\n        except ZeroDivisionError:\n             # Re-raise ZeroDivisionError explicitly\n             raise ZeroDivisionError(\"division or modulo by zero\")\n        except Exception as e:\n             # Catch any other unexpected errors during calculation\n             # Wrap in RuntimeError to indicate it happened during calculation\n             raise RuntimeError(f\"An error occurred during calculation: {e}\") from e\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion (e.g., remove spaces).\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression with spaces removed.\n        >>> ExpressionCalculator.transform(\"2 + 3 * 4\")\n        '2+3*4'\n        >>> ExpressionCalculator.transform(\" ( 2 + 3 )  * 4 \")\n        '(2+3)*4'\n        >>> ExpressionCalculator.transform(\"\")\n        ''\n        \"\"\"\n        if not isinstance(expression, str):\n            raise TypeError(\"Input expression must be a string.\")\n        return expression.replace(\" \", \"\")\n\n    def evaluate_infix(self, expression):\n        \"\"\"\n        Convenience method to evaluate an infix expression by first preparing\n        it (converting to postfix) and then calculating the result from the postfix.\n        This wraps the prepare and calculate methods.\n        :param expression: string, the infix expression to be evaluated.\n        :return: float, the result of the calculation.\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.evaluate_infix(\"2 + 3 * 4\")\n        14.0\n        >>> expression_calculator.evaluate_infix(\"(2 + 3) * 4\")\n        20.0\n        >>> expression_calculator.evaluate_infix(\"10 / 2 - 5 % 3\")\n        3.0\n        >>> expression_calculator.evaluate_infix(\"2+3*4/2-1\")\n        7.0\n        \"\"\"\n        self.prepare(expression)\n        # The prepare method stores the postfix tokens in self.postfix_stack as a deque of strings.\n        # The calculate method expects a single string of space-separated tokens.\n        postfix_string = \" \".join(self.postfix_stack)\n        return self.calculate(postfix_string)\n\n\n# Example usage (matching the evaluate_infix doctests)\nif __name__ == '__main__':\n    calculator = ExpressionCalculator()\n\n    # Example 1: 2 + 3 * 4 = 14\n    expr1 = \"2 + 3 * 4\"\n    print(f\"Infix: {expr1}\")\n    calculator.prepare(expr1)\n    postfix1 = \" \".join(calculator.postfix_stack)\n    print(f\"Postfix: {postfix1}\") # Should print 2 3 4 * +\n    result1 = calculator.calculate(postfix1)\n    print(f\"Result: {result1}\\n\") # Should print 14.0\n\n    # Example 2: (2 + 3) * 4 = 20\n    expr2 = \"(2 + 3) * 4\"\n    print(f\"Infix: {expr2}\")\n    calculator.prepare(expr2)\n    postfix2 = \" \".join(calculator.postfix_stack)\n    print(f\"Postfix: {postfix2}\") # Should print 2 3 + 4 *\n    result2 = calculator.calculate(postfix2)\n    print(f\"Result: {result2}\\n\") # Should print 20.0\n\n    # Example using the convenience method\n    expr3 = \"10 / 2 - 5 % 3\"\n    print(f\"Evaluating infix: {expr3}\")\n    result3 = calculator.evaluate_infix(expr3)\n    print(f\"Result: {result3}\\n\") # Should print 3.0\n\n    expr4 = \"2+3*4/2-1\"\n    print(f\"Evaluating infix: {expr4}\")\n    result4 = calculator.evaluate_infix(expr4)\n    print(f\"Result: {result4}\\n\") # Should print 7.0\n\n    # Example of division by zero (should raise error)\n    # try:\n    #     calculator.evaluate_infix(\"5 / (3 - 3)\")\n    # except (ValueError, ZeroDivisionError) as e:\n    #     print(f\"Caught expected error: {e}\")\n\n    # Example of invalid expression (should raise error)\n    # try:\n    #      calculator.evaluate_infix(\"2 + 3 *\")\n    # except (ValueError, RuntimeError) as e:\n    #      print(f\"Caught expected error: {e}\")\n\n    # Example of mismatched parentheses (should raise error)\n    # try:\n    #      calculator.evaluate_infix(\"(2 + 3\")\n    # except (ValueError, RuntimeError) as e:\n    #      print(f\"Caught expected error: {e}\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_51",
    "skeleton": "import numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix\n        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value\n        :param k: int, Matrix dimension\n        :return:float, the cohens kappa value of the matrix\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the fliss kappa value of an N * k matrix\n        :param testData: Input data matrix, N * k\n        :param N: int, Number of samples\n        :param k: int, Number of categories\n        :param n: int, Number of raters\n        :return: float, fleiss kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>                              [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                              [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"",
    "test": "import unittest\n\n\nclass KappaCalculatorTestKappa(unittest.TestCase):\n    def test_kappa_1(self):\n        self.assertEqual(KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3), 0.25)\n\n    def test_kappa_2(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 2, 1], [1, 2, 1], [1, 1, 2]], 3), 0.19469026548672572)\n\n    def test_kappa_3(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 1, 2], [1, 2, 1], [1, 1, 2]], 3), 0.19469026548672572)\n\n    def test_kappa_4(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 1, 1], [2, 2, 1], [1, 1, 2]], 3), 0.19469026548672572)\n\n    def test_kappa_5(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 1, 1], [1, 2, 2], [1, 1, 2]], 3), 0.19469026548672572)\n\n\nclass KappaCalculatorTestFleissKappa(unittest.TestCase):\n    def test_fleiss_kappa_1(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.20993070442195522)\n\n    def test_fleiss_kappa_2(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[1, 0, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.2115748928799344)\n\n    def test_fleiss_kappa_3(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 1, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.21076904123090398)\n\n    def test_fleiss_kappa_4(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 1, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.2096583016522883)\n\n    def test_fleiss_kappa_5(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 0, 1, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.21147425143148907)\n\n\nclass KappaCalculatorTest(unittest.TestCase):\n    def test_kappacalculator(self):\n        self.assertEqual(KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3), 0.25)\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.20993070442195522)",
    "solution_code": "import numpy as np\n\n\nclass KappaCalculator:\n\n    @staticmethod\n    def kappa(testData, k):\n        dataMat = np.mat(testData)\n        P0 = 0.0\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = float(ysum * xsum) / sum / sum\n        P0 = float(P0 / sum * 1.0)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        Pe = ysum * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]",
    "import_statement": [
      "import numpy as np"
    ],
    "class_description": "    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n",
    "class_name": "KappaCalculator",
    "test_classes": [
      "KappaCalculatorTestKappa",
      "KappaCalculatorTestFleissKappa",
      "KappaCalculatorTest"
    ],
    "class_constructor": "class KappaCalculator: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "kappa",
        "method_description": "def kappa(testData, k):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix\n        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value\n        :param k: int, Matrix dimension\n        :return:float, the cohens kappa value of the matrix\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"",
        "test_class": "KappaCalculatorTestKappa",
        "test_code": "class KappaCalculatorTestKappa(unittest.TestCase):\n    def test_kappa_1(self):\n        self.assertEqual(KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3), 0.25)\n\n    def test_kappa_2(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 2, 1], [1, 2, 1], [1, 1, 2]], 3), 0.19469026548672572)\n\n    def test_kappa_3(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 1, 2], [1, 2, 1], [1, 1, 2]], 3), 0.19469026548672572)\n\n    def test_kappa_4(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 1, 1], [2, 2, 1], [1, 1, 2]], 3), 0.19469026548672572)\n\n    def test_kappa_5(self):\n        self.assertAlmostEqual(KappaCalculator.kappa([[2, 1, 1], [1, 2, 2], [1, 1, 2]], 3), 0.19469026548672572)",
        "solution_code": "def kappa(testData, k):\n        dataMat = np.mat(testData)\n        P0 = 0.0\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = float(ysum * xsum) / sum / sum\n        P0 = float(P0 / sum * 1.0)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        return cohens_coefficient",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "fleiss_kappa",
        "method_description": "@staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the fliss kappa value of an N * k matrix\n        :param testData: Input data matrix, N * k\n        :param N: int, Number of samples\n        :param k: int, Number of categories\n        :param n: int, Number of raters\n        :return: float, fleiss kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>                              [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                              [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"",
        "test_class": "KappaCalculatorTestFleissKappa",
        "test_code": "class KappaCalculatorTestFleissKappa(unittest.TestCase):\n    def test_fleiss_kappa_1(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.20993070442195522)\n\n    def test_fleiss_kappa_2(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[1, 0, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.2115748928799344)\n\n    def test_fleiss_kappa_3(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 1, 0, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.21076904123090398)\n\n    def test_fleiss_kappa_4(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 1, 0, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.2096583016522883)\n\n    def test_fleiss_kappa_5(self):\n        self.assertEqual(KappaCalculator.fleiss_kappa([[0, 0, 0, 1, 14],\n                                                       [0, 2, 6, 4, 2],\n                                                       [0, 0, 3, 5, 6],\n                                                       [0, 3, 9, 2, 0],\n                                                       [2, 2, 8, 1, 1],\n                                                       [7, 7, 0, 0, 0],\n                                                       [3, 2, 6, 3, 0],\n                                                       [2, 5, 3, 2, 2],\n                                                       [6, 5, 2, 1, 0],\n                                                       [0, 2, 2, 3, 7]], 10, 5, 14), 0.21147425143148907)",
        "solution_code": "@staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        Pe = ysum * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData, k: int):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix (agreement between two raters).\n\n        Cohen's kappa measures the agreement between two raters, accounting for chance agreement.\n        The input testData should be a k x k contingency matrix where testData[i][j] is\n        the number of items rated as category i by the first rater and category j by the second rater.\n\n        :param testData: The k x k contingency matrix. Can be list of lists or numpy array.\n        :param k: int, Number of categories (matrix dimension).\n        :return: float, the cohens kappa value.\n        :raises ValueError: If the input matrix is not square or its dimensions do not match k.\n        :raises ValueError: If the total number of observations is negative.\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        >>> KappaCalculator.kappa([[10, 0], [0, 10]], 2) # Perfect agreement\n        1.0\n        >>> KappaCalculator.kappa([[5, 5], [5, 5]], 2) # Chance agreement\n        0.0\n        >>> KappaCalculator.kappa([[0, 0], [0, 0]], 2) # Zero observations\n        1.0\n        \"\"\"\n        data = np.asarray(testData, dtype=float)\n\n        # Input validation\n        if data.ndim != 2 or data.shape[0] != k or data.shape[1] != k:\n            raise ValueError(f\"Input matrix must be a {k}x{k} square matrix.\")\n        if np.any(data < 0):\n             raise ValueError(\"Input matrix cannot contain negative values.\")\n\n\n        n_observations = np.sum(data)\n\n        # Handle edge case: no observations\n        if n_observations == 0:\n            return 1.0 # Perfect agreement on nothing\n\n        # Calculate observed agreement (Po)\n        po = np.trace(data) / n_observations\n\n        # Calculate expected agreement (Pe)\n        row_sums = np.sum(data, axis=1)\n        col_sums = np.sum(data, axis=0)\n        pe = np.sum(row_sums * col_sums) / (n_observations * n_observations)\n\n        # Calculate kappa\n        denominator = 1 - pe\n\n        # Handle edge case: Pe = 1 (occurs when all observations fall into a single category\n        # by both raters, or distribution is such that expected agreement is 100%)\n        if denominator == 0:\n            # If Pe is 1, kappa is 1 only if Po is also 1. Otherwise, it's undefined.\n            # Conventionally, if Pe=1 and Po=1, kappa is 1.0.\n            # If Pe=1 and Po < 1, it indicates an issue or might be treated as 0.0 or NaN.\n            # Given that Pe=1 implies total agreement is expected, Po=1 is also likely\n            # unless input data is somehow contradictory for this formula.\n            # We'll return 1.0 if Po is also effectively 1.0, otherwise 0.0 (or NaN,\n            # but 0.0 is often used). Let's use 1.0 if Po is very close to 1.\n            if np.isclose(po, 1.0):\n                 return 1.0\n            else:\n                 # This case indicates disagreement when perfect agreement is expected by chance,\n                 # which is usually not possible with valid input data for Cohen's Kappa.\n                 # Returning 0.0 aligns with 'no agreement better than chance'.\n                 return 0.0 # Or np.nan depending on desired behavior for undefined case\n\n\n        return (po - pe) / denominator\n\n    @staticmethod\n    def fleiss_kappa(testData, N: int, k: int, n: int):\n        \"\"\"\n        Calculate the fleiss kappa value of an N * k matrix (agreement among multiple raters).\n\n        Fleiss' kappa measures the agreement among more than two raters for categorical ratings.\n        The input testData should be an N x k matrix where testData[i][j] is\n        the number of raters who assigned sample i to category j.\n\n        :param testData: Input data matrix, N x k, where testData[i][j] is the count of raters. Can be list of lists or numpy array.\n        :param N: int, Number of samples (subjects or items).\n        :param k: int, Number of categories.\n        :param n: int, Number of raters per sample. Each row in testData must sum to n.\n        :return: float, fleiss kappa value.\n        :raises ValueError: If the input matrix dimensions do not match N x k.\n        :raises ValueError: If the number of raters (n) is less than 1.\n        :raises ValueError: If row sums do not equal n for all rows.\n        :raises ValueError: If input matrix contains negative values.\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>                              [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                              [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n         >>> KappaCalculator.fleiss_kappa([[10,0],[10,0]], 2, 2, 10) # Perfect agreement\n        1.0\n        >>> KappaCalculator.fleiss_kappa([[5,5],[5,5]], 2, 2, 10) # Chance agreement\n        0.0\n        >>> KappaCalculator.fleiss_kappa([[0,0],[0,0]], 2, 2, 10) # Zero assignments\n        1.0\n        >>> KappaCalculator.fleiss_kappa([[1]], 1, 1, 1) # n=1 case\n        1.0\n        \"\"\"\n        data = np.asarray(testData, dtype=float)\n\n        # Input validation\n        if data.ndim != 2 or data.shape[0] != N or data.shape[1] != k:\n             raise ValueError(f\"Input matrix must be a {N}x{k} matrix.\")\n        if n < 1:\n             raise ValueError(\"Number of raters (n) must be at least 1.\")\n        if np.any(data < 0):\n             raise ValueError(\"Input matrix cannot contain negative values.\")\n\n        row_sums = np.sum(data, axis=1)\n        if not np.all(row_sums == n):\n             # Allow for floating point comparisons if input was float\n             if not np.allclose(row_sums, n):\n                 raise ValueError(f\"Each row in the input matrix must sum to the number of raters (n={n}). Found sums: {row_sums}\")\n\n\n        # Handle edge case: only one rater\n        if n <= 1:\n            return 1.0 # With only one rater, there's no disagreement possible\n\n        # Handle edge case: no samples\n        if N == 0:\n             return 1.0 # Perfect agreement on nothing\n\n        # Calculate observed agreement (Po)\n        # Sum of n_ij * (n_ij - 1) for each cell, summed over all cells\n        sum_nij_minus_1 = np.sum(data * (data - 1))\n        # Po = Average agreement over all possible pairs of raters and all samples\n        po = sum_nij_minus_1 / (N * n * (n - 1))\n\n        # Calculate expected agreement (Pe)\n        # Calculate the proportion of all ratings in each category\n        category_totals = np.sum(data, axis=0)\n        total_assignments = N * n\n\n        if total_assignments == 0:\n             # This should ideally be caught by N=0 or n=0 checks, but safety first\n             return 1.0 # No assignments implies perfect agreement on nothing\n\n        p_j = category_totals / total_assignments\n\n        # Pe = Sum of squares of proportions for each category\n        pe = np.sum(p_j**2)\n\n        # Calculate kappa\n        denominator = 1 - pe\n\n        # Handle edge case: Pe = 1 (occurs when all ratings fall into a single category)\n        if denominator == 0:\n             # If Pe is 1, kappa is 1 only if Po is also 1. Otherwise, it's undefined.\n             # Similar logic to Cohen's kappa: return 1.0 if Po is very close to 1.\n             if np.isclose(po, 1.0):\n                  return 1.0\n             else:\n                  # This case indicates disagreement when perfect agreement is expected by chance (all items in one category),\n                  # which is typically not possible with valid data that leads to Pe=1.\n                  # Returning 0.0 aligns with 'no agreement better than chance'.\n                  return 0.0 # Or np.nan\n\n\n        return (po - pe) / denominator\n\nif __name__ == '__main__':\n    # Example usage from docstrings\n    cohen_data = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]\n    cohen_k = 3\n    cohen_kappa_value = KappaCalculator.kappa(cohen_data, cohen_k)\n    print(f\"Cohen's Kappa for example: {cohen_kappa_value}\")\n    # Expected: 0.25\n\n    fleiss_data = [[0, 0, 0, 0, 14],\n                   [0, 2, 6, 4, 2],\n                   [0, 0, 3, 5, 6],\n                   [0, 3, 9, 2, 0],\n                   [2, 2, 8, 1, 1],\n                   [7, 7, 0, 0, 0],\n                   [3, 2, 6, 3, 0],\n                   [2, 5, 3, 2, 2],\n                   [6, 5, 2, 1, 0],\n                   [0, 2, 2, 3, 7]]\n    fleiss_N = 10\n    fleiss_k = 5\n    fleiss_n = 14\n    fleiss_kappa_value = KappaCalculator.fleiss_kappa(fleiss_data, fleiss_N, fleiss_k, fleiss_n)\n    print(f\"Fleiss' Kappa for example: {fleiss_kappa_value}\")\n    # Expected: 0.20993070442195522\n\n    # Add a few more test cases\n    print(\"\\nAdditional tests:\")\n    print(f\"Cohen's Perfect: {KappaCalculator.kappa([[10, 0], [0, 10]], 2)}\")\n    print(f\"Cohen's Chance: {KappaCalculator.kappa([[5, 5], [5, 5]], 2)}\")\n    print(f\"Cohen's Zero: {KappaCalculator.kappa([[0, 0], [0, 0]], 2)}\")\n\n    print(f\"Fleiss' Perfect: {KappaCalculator.fleiss_kappa([[10,0],[10,0]], 2, 2, 10)}\")\n    print(f\"Fleiss' Chance: {KappaCalculator.fleiss_kappa([[5,5],[5,5]], 2, 2, 10)}\")\n    print(f\"Fleiss' Zero: {KappaCalculator.fleiss_kappa([[0,0],[0,0]], 2, 2, 10)}\")\n    print(f\"Fleiss' n=1: {KappaCalculator.fleiss_kappa([[5],[5]], 2, 1, 1)}\")\n\n    # Example of invalid input (uncomment to test error handling)\n    # try:\n    #     KappaCalculator.kappa([[1,2]], 2) # Wrong shape\n    # except ValueError as e:\n    #     print(f\"Error caught: {e}\")\n    #\n    # try:\n    #      KappaCalculator.fleiss_kappa([[10,0],[5,5]], 2, 2, 10) # Row sums not equal to n\n    # except ValueError as e:\n    #      print(f\"Error caught: {e}\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_56",
    "skeleton": "class MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        >>> mc = MetricsCalculator()\n        >>> mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        (self.true_positives, self.false_positives, self.false_negatives, self.true_negatives) = (1, 1, 1, 1)\n        \"\"\"\n\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>>mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"",
    "test": "import unittest\n\n\nclass MetricsCalculatorTestUpdate(unittest.TestCase):\n    def test_update_1(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 1, 1, 1))\n\n    def test_update_2(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 2, 1, 0))\n\n    def test_update_3(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (2, 1, 0, 1))\n\n    def test_update_4(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (2, 0, 1, 1))\n\n    def test_update_5(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 1, 2, 0))\n\n\nclass MetricsCalculatorTestPrecision(unittest.TestCase):\n    def test_precision_1(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_precision_2(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertAlmostEqual(temp, 0.3333333333333333)\n\n    def test_precision_3(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertAlmostEqual(temp, 0.6666666666666666)\n\n    def test_precision_4(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertAlmostEqual(temp, 1.0)\n\n    def test_precision_5(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertAlmostEqual(temp, 0.5)\n\n    def test_precision_6(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([0, 0, 0, 0], [1, 0, 1, 1])\n        self.assertAlmostEqual(temp, 0.0)\n\n\nclass MetricsCalculatorTestRecall(unittest.TestCase):\n    def test_recall_1(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_recall_2(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_recall_3(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual(temp, 1.0)\n\n    def test_recall_4(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertAlmostEqual(temp, 0.6666666666666666)\n\n    def test_recall_5(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertAlmostEqual(temp, 0.3333333333333333)\n\n    def test_recall_6(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [0, 0, 0, 0])\n        self.assertEqual(temp, 0.0)\n\n\nclass MetricsCalculatorTestF1Score(unittest.TestCase):\n    def test_f1_score_1(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_f1_score_2(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.4)\n\n    def test_f1_score_3(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.8)\n\n    def test_f1_score_4(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertEqual(temp, 0.8)\n\n    def test_f1_score_5(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertEqual(temp, 0.4)\n\n    def test_f1_score_6(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([0, 0, 0, 0], [0, 0, 0, 0])\n        self.assertEqual(temp, 0.0)\n\n\nclass MetricsCalculatorTestAccuracy(unittest.TestCase):\n    def test_accuracy_1(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_accuracy_2(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 2, 0], [1, 0, 0, 1])\n        self.assertAlmostEqual(temp, 0.3333333333333333)\n\n    def test_accuracy_3(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.75)\n\n    def test_accuracy_4(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertEqual(temp, 0.75)\n\n    def test_accuracy_5(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertEqual(temp, 0.25)\n\n    def test_accuracy_6(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([], [])\n        self.assertEqual(temp, 0.0)\n\n\nclass MetricsCalculatorTest(unittest.TestCase):\n    def test_metricscalculator(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 1, 1, 1))\n        temp = mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n        temp = mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n        temp = mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n        temp = mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)",
    "solution_code": "class MetricsCalculator:\n    def __init__(self):\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        return (2 * precision * recall) / (precision + recall)\n\n    def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total",
    "import_statement": [],
    "class_description": "    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n",
    "class_name": "MetricsCalculator",
    "test_classes": [
      "MetricsCalculatorTestUpdate",
      "MetricsCalculatorTestPrecision",
      "MetricsCalculatorTestRecall",
      "MetricsCalculatorTestF1Score",
      "MetricsCalculatorTestAccuracy",
      "MetricsCalculatorTest"
    ],
    "class_constructor": "class MetricsCalculator: \n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n",
    "fields": [
      "self.false_negatives",
      "self.false_positives",
      "self.true_negatives",
      "self.true_positives"
    ],
    "methods_info": [
      {
        "method_name": "update",
        "method_description": "def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        >>> mc = MetricsCalculator()\n        >>> mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        (self.true_positives, self.false_positives, self.false_negatives, self.true_negatives) = (1, 1, 1, 1)\n        \"\"\"",
        "test_class": "MetricsCalculatorTestUpdate",
        "test_code": "class MetricsCalculatorTestUpdate(unittest.TestCase):\n    def test_update_1(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 1, 1, 1))\n\n    def test_update_2(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 2, 1, 0))\n\n    def test_update_3(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (2, 1, 0, 1))\n\n    def test_update_4(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (2, 0, 1, 1))\n\n    def test_update_5(self):\n        mc = MetricsCalculator()\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (0, 0, 0, 0))\n        mc.update([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertEqual((mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives), (1, 1, 2, 0))",
        "solution_code": "def update(self, predicted_labels, true_labels):\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.false_negatives",
            "self.false_positives",
            "self.true_negatives",
            "self.true_positives"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "precision",
        "method_description": "def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"",
        "test_class": "MetricsCalculatorTestPrecision",
        "test_code": "class MetricsCalculatorTestPrecision(unittest.TestCase):\n    def test_precision_1(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_precision_2(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertAlmostEqual(temp, 0.3333333333333333)\n\n    def test_precision_3(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertAlmostEqual(temp, 0.6666666666666666)\n\n    def test_precision_4(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertAlmostEqual(temp, 1.0)\n\n    def test_precision_5(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertAlmostEqual(temp, 0.5)\n\n    def test_precision_6(self):\n        mc = MetricsCalculator()\n        temp = mc.precision([0, 0, 0, 0], [1, 0, 1, 1])\n        self.assertAlmostEqual(temp, 0.0)",
        "solution_code": "def precision(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.false_positives",
            "self.true_positives"
          ],
          "method_dependencies": [
            "update"
          ]
        }
      },
      {
        "method_name": "recall",
        "method_description": "def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"",
        "test_class": "MetricsCalculatorTestRecall",
        "test_code": "class MetricsCalculatorTestRecall(unittest.TestCase):\n    def test_recall_1(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_recall_2(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_recall_3(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual(temp, 1.0)\n\n    def test_recall_4(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertAlmostEqual(temp, 0.6666666666666666)\n\n    def test_recall_5(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertAlmostEqual(temp, 0.3333333333333333)\n\n    def test_recall_6(self):\n        mc = MetricsCalculator()\n        temp = mc.recall([1, 1, 0, 0], [0, 0, 0, 0])\n        self.assertEqual(temp, 0.0)",
        "solution_code": "def recall(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.false_negatives",
            "self.true_positives"
          ],
          "method_dependencies": [
            "update"
          ]
        }
      },
      {
        "method_name": "f1_score",
        "method_description": "def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"",
        "test_class": "MetricsCalculatorTestF1Score",
        "test_code": "class MetricsCalculatorTestF1Score(unittest.TestCase):\n    def test_f1_score_1(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_f1_score_2(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 1, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.4)\n\n    def test_f1_score_3(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.8)\n\n    def test_f1_score_4(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertEqual(temp, 0.8)\n\n    def test_f1_score_5(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertEqual(temp, 0.4)\n\n    def test_f1_score_6(self):\n        mc = MetricsCalculator()\n        temp = mc.f1_score([0, 0, 0, 0], [0, 0, 0, 0])\n        self.assertEqual(temp, 0.0)",
        "solution_code": "def f1_score(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        return (2 * precision * recall) / (precision + recall)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "update",
            "precision",
            "recall"
          ]
        }
      },
      {
        "method_name": "accuracy",
        "method_description": "def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>>mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"",
        "test_class": "MetricsCalculatorTestAccuracy",
        "test_code": "class MetricsCalculatorTestAccuracy(unittest.TestCase):\n    def test_accuracy_1(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.5)\n\n    def test_accuracy_2(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 2, 0], [1, 0, 0, 1])\n        self.assertAlmostEqual(temp, 0.3333333333333333)\n\n    def test_accuracy_3(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 1], [1, 0, 0, 1])\n        self.assertEqual(temp, 0.75)\n\n    def test_accuracy_4(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 0], [1, 1, 0, 1])\n        self.assertEqual(temp, 0.75)\n\n    def test_accuracy_5(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([1, 1, 0, 0], [1, 0, 1, 1])\n        self.assertEqual(temp, 0.25)\n\n    def test_accuracy_6(self):\n        mc = MetricsCalculator()\n        temp = mc.accuracy([], [])\n        self.assertEqual(temp, 0.0)",
        "solution_code": "def accuracy(self, predicted_labels, true_labels):\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.false_negatives",
            "self.false_positives",
            "self.true_negatives",
            "self.true_positives"
          ],
          "method_dependencies": [
            "update"
          ]
        }
      }
    ],
    "predict": [
      "```python\nimport sys\n\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    It can either calculate metrics directly from lists or accumulate counts first (though the metric\n    calculation methods currently only use the input lists).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        self.true_positives: int = 0\n        self.false_positives: int = 0\n        self.false_negatives: int = 0\n        self.true_negatives: int = 0\n\n    def update(self, predicted_labels: list[int], true_labels: list[int]) -> None:\n        \"\"\"\n        Update the number of all four samples (true_positives, false_positives, false_negatives, true_negatives)\n        based on input lists. Assumes binary labels (0 or 1).\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, changes the number of corresponding samples\n        :raises ValueError: If input lists have different lengths.\n        >>> mc = MetricsCalculator()\n        >>> mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        (mc.true_positives, mc.false_positives, mc.false_negatives, mc.true_negatives) # Output should be (1, 1, 1, 1)\n        \"\"\"\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"Input lists 'predicted_labels' and 'true_labels' must have the same length.\")\n\n        for pred, true in zip(predicted_labels, true_labels):\n            # Assuming binary classification where positive is 1 and negative is 0\n            if pred == 1 and true == 1:\n                self.true_positives += 1\n            elif pred == 1 and true == 0:\n                self.false_positives += 1\n            elif pred == 0 and true == 1:\n                self.false_negatives += 1\n            elif pred == 0 and true == 0:\n                self.true_negatives += 1\n            # Add error handling for labels other than 0 or 1 if necessary\n            # else:\n            #     raise ValueError(f\"Invalid label values found: pred={pred}, true={true}. Labels must be 0 or 1.\")\n\n\n    def _calculate_counts(self, predicted_labels: list[int], true_labels: list[int]) -> tuple[int, int, int, int]:\n        \"\"\"\n        Helper method to calculate TP, FP, FN, TN counts for a given pair of lists.\n        This is used by the metric calculation methods to operate on the input lists\n        rather than the accumulated internal state.\n        :return: tuple (tp, fp, fn, tn)\n        :raises ValueError: If input lists have different lengths.\n        \"\"\"\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"Input lists 'predicted_labels' and 'true_labels' must have the same length.\")\n\n        tp, fp, fn, tn = 0, 0, 0, 0\n        for pred, true in zip(predicted_labels, true_labels):\n             if pred == 1 and true == 1:\n                tp += 1\n            elif pred == 1 and true == 0:\n                fp += 1\n            elif pred == 0 and true == 1:\n                fn += 1\n            elif pred == 0 and true == 0:\n                tn += 1\n        return tp, fp, fn, tn\n\n\n    def precision(self, predicted_labels: list[int], true_labels: list[int]) -> float:\n        \"\"\"\n        Calculate precision from input lists.\n        Precision is the ratio of true positives (TP) to the total number of positive predictions (TP + FP).\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, precision score. Returns 0.0 if there are no positive predictions (TP+FP=0).\n        :raises ValueError: If input lists have different lengths.\n        >>> mc = MetricsCalculator()\n        >>> mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        >>> mc.precision([0, 0, 0], [1, 1, 1]) # TP=0, FP=0. Denominator is 0.\n        0.0\n        >>> mc.precision([1, 1], [0, 0]) # TP=0, FP=2. Prec = 0/2 = 0.0\n        0.0\n        >>> mc.precision([], []) # Empty lists\n        0.0\n        \"\"\"\n        tp, fp, fn, tn = self._calculate_counts(predicted_labels, true_labels)\n        denominator = tp + fp\n        return tp / denominator if denominator else 0.0 # Handle division by zero\n\n    def recall(self, predicted_labels: list[int], true_labels: list[int]) -> float:\n        \"\"\"\n        Calculate recall from input lists.\n        Recall is the ratio of true positives (TP) to the total number of actual positive labels (TP + FN).\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, recall score. Returns 0.0 if there are no true positive labels (TP+FN=0).\n        :raises ValueError: If input lists have different lengths.\n        >>> mc = MetricsCalculator()\n        >>> mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        >>> mc.recall([0, 0, 0], [1, 1, 1]) # TP=0, FN=3. Recall = 0/3 = 0.0\n        0.0\n        >>> mc.recall([1, 1], [0, 0]) # TP=0, FN=0. Denominator is 0.\n        0.0\n        >>> mc.recall([], []) # Empty lists\n        0.0\n        \"\"\"\n        tp, fp, fn, tn = self._calculate_counts(predicted_labels, true_labels)\n        denominator = tp + fn\n        return tp / denominator if denominator else 0.0 # Handle division by zero\n\n    def f1_score(self, predicted_labels: list[int], true_labels: list[int]) -> float:\n        \"\"\"\n        Calculate f1 score from input lists, which is the harmonic mean of precision and recall.\n        F1 = 2 * (Precision * Recall) / (Precision + Recall)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, f1 score. Returns 0.0 if precision and recall are both 0 (which happens when TP=0).\n        :raises ValueError: If input lists have different lengths.\n        >>> mc = MetricsCalculator()\n        >>> mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        >>> mc.f1_score([0, 0, 0], [1, 1, 1]) # Prec=0, Rec=0. F1 = 0.0\n        0.0\n        >>> mc.f1_score([1, 1], [0, 0]) # Prec=0, Rec=0. F1 = 0.0\n        0.0\n        >>> mc.f1_score([1, 1], [1, 0]) # TP=1, FP=1, FN=0. Prec=0.5, Rec=1.0. F1 = 2*(0.5*1)/(0.5+1) = 1/1.5 = 0.666...\n        0.666... # Use assertAlmostEqual in tests\n        >>> mc.f1_score([], []) # Empty lists. Prec=0, Rec=0. F1 = 0.0\n        0.0\n        \"\"\"\n        # Calculate precision and recall first using the methods that handle division by zero\n        prec = self.precision(predicted_labels, true_labels)\n        rec = self.recall(predicted_labels, true_labels)\n\n        denominator = prec + rec\n        # If both prec and rec are 0 (which happens when TP=0), F1 is 0.\n        return 2 * (prec * rec) / denominator if denominator else 0.0\n\n    def accuracy(self, predicted_labels: list[int], true_labels: list[int]) -> float:\n        \"\"\"\n        Calculate accuracy from input lists.\n        Accuracy is the ratio of correctly predicted samples (TP + TN) to the total number of samples.\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, accuracy score. Returns 1.0 for empty lists (total=0), consistent with sklearn's accuracy_score.\n        :raises ValueError: If input lists have different lengths.\n        >>> mc = MetricsCalculator()\n        >>> mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        >>> mc.accuracy([1, 1, 1], [1, 1, 1]) # TP=3, TN=0, Total=3. Acc = 3/3 = 1.0\n        1.0\n        >>> mc.accuracy([0, 0, 0], [0, 0, 0]) # TP=0, TN=3, Total=3. Acc = 3/3 = 1.0\n        1.0\n        >>> mc.accuracy([1, 1, 1], [0, 0, 0]) # TP=0, TN=0, Total=3. Acc = 0/3 = 0.0\n        0.0\n        >>> mc.accuracy([], []) # Empty lists. Total=0. Acc = 1.0\n        1.0\n        \"\"\"\n        tp, fp, fn, tn = self._calculate_counts(predicted_labels, true_labels)\n        total = tp + fp + fn + tn\n        # Return 1.0 for empty lists (total=0)\n        return (tp + tn) / total if total else 1.0\n\n# Example usage (optional, for testing the code directly)\nif __name__ == '__main__':\n    # Test update method\n    print(\"Testing update method:\")\n    mc_update = MetricsCalculator()\n    mc_update.update([1, 1, 0, 0], [1, 0, 0, 1])\n    print(f\"After update 1: TP={mc_update.true_positives}, FP={mc_update.false_positives}, FN={mc_update.false_negatives}, TN={mc_update.true_negatives}\") # Expected: TP=1, FP=1, FN=1, TN=1\n\n    mc_update.update([1, 0], [1, 1]) # TP=1, FP=0, FN=1, TN=0\n    # Cumulative: TP=(1+1)=2, FP=(1+0)=1, FN=(1+1)=2, TN=(1+0)=1\n    print(f\"After update 2: TP={mc_update.true_positives}, FP={mc_update.false_positives}, FN={mc_update.false_negatives}, TN={mc_update.true_negatives}\") # Expected: TP=2, FP=1, FN=2, TN=1\n\n    # Test metric calculation methods (which operate on input lists, not accumulated state)\n    print(\"\\nTesting metric calculation methods:\")\n    mc_calc = MetricsCalculator() # Use a new instance for clarity\n\n    pred1 = [1, 1, 0, 0]\n    true1 = [1, 0, 0, 1]\n    print(f\"Pred: {pred1}, True: {true1}\")\n    print(f\"  Precision: {mc_calc.precision(pred1, true1)}\") # Expected: 0.5\n    print(f\"  Recall:    {mc_calc.recall(pred1, true1)}\")    # Expected: 0.5\n    print(f\"  F1 Score:  {mc_calc.f1_score(pred1, true1)}\")  # Expected: 0.5\n    print(f\"  Accuracy:  {mc_calc.accuracy(pred1, true1)}\")  # Expected: 0.5\n\n    pred2 = [1, 1, 1, 0, 0]\n    true2 = [1, 0, 1, 0, 1]\n    # TP=2 (1,1), FP=1 (1,0), FN=1 (0,1), TN=1 (0,0). Total=5\n    print(f\"\\nPred: {pred2}, True: {true2}\")\n    # Prec = TP/(TP+FP) = 2/(2+1) = 2/3\n    # Rec = TP/(TP+FN) = 2/(2+1) = 2/3\n    # F1 = 2*(2/3*2/3)/(2/3+2/3) = 2*(4/9)/(4/3) = (8/9)/(4/3) = 8/9 * 3/4 = 24/36 = 2/3\n    # Acc = (TP+TN)/Total = (2+1)/5 = 3/5 = 0.6\n    print(f\"  Precision: {mc_calc.precision(pred2, true2)}\") # Expected: 0.666...\n    print(f\"  Recall:    {mc_calc.recall(pred2, true2)}\")    # Expected: 0.666...\n    print(f\"  F1 Score:  {mc_calc.f1_score(pred2, true2)}\")  # Expected: 0.666...\n    print(f\"  Accuracy:  {mc_calc.accuracy(pred2, true2)}\")  # Expected: 0.6\n\n    pred_empty = []\n    true_empty = []\n    print(f\"\\nPred: {pred_empty}, True: {true_empty}\")\n    print(f\"  Precision: {mc_calc.precision(pred_empty, true_empty)}\") # Expected: 0.0\n    print(f\"  Recall:    {mc_calc.recall(pred_empty, true_empty)}\")    # Expected: 0.0\n    print(f\"  F1 Score:  {mc_calc.f1_score(pred_empty, true_empty)}\")  # Expected: 0.0\n    print(f\"  Accuracy:  {mc_calc.accuracy(pred_empty, true_empty)}\")  # Expected: 1.0 (by convention)\n\n    pred_zeros = [0, 0, 0]\n    true_ones = [1, 1, 1]\n    print(f\"\\nPred: {pred_zeros}, True: {true_ones}\")\n    print(f\"  Precision: {mc_calc.precision(pred_zeros, true_ones)}\") # Expected: 0.0\n    print(f\"  Recall:    {mc_calc.recall(pred_zeros, true_ones)}\")    # Expected: 0.0\n    print(f\"  F1 Score:  {mc_calc.f1_score(pred_zeros, true_ones)}\")  # Expected: 0.0\n    print(f\"  Accuracy:  {mc_calc.accuracy(pred_zeros, true_ones)}\")  # Expected: 0.0\n\n    # Test mismatch length error\n    try:\n        mc_calc.precision([1, 0], [1])\n    except ValueError as e:\n        print(f\"\\nCaught expected error: {e}\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_57",
    "skeleton": "import numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        1.0, [1.0]\n        0.75, [1.0, 0.5]\n        \"\"\"\n\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        0.41666666666666663, [0.41666666666666663]\n        0.3333333333333333, [0.41666666666666663, 0.25]\n        \"\"\"",
    "test": "import unittest\n\n\nclass MetricsCalculator2TestMrr(unittest.TestCase):\n    def test_mrr_1(self):\n        mc2 = MetricsCalculator2()\n        res1, res2 = MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        self.assertEqual(res1, 1.0)\n        self.assertEqual(res2, [1.0])\n\n    def test_mrr_2(self):\n        res1, res2 = MetricsCalculator2.mrr(([0, 0, 0, 1], 4))\n        self.assertEqual(res1, 0.25)\n        self.assertEqual(res2, [0.25])\n\n    def test_mrr_3(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        self.assertEqual(res1, 0.75)\n        self.assertEqual(res2, [1.0, 0.5])\n\n    def test_mrr_4(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 1, 1, 0], 4), ([0, 0, 0, 1], 4)])\n        self.assertEqual(res1, 0.625)\n        self.assertEqual(res2, [1.0, 0.25])\n\n    def test_mrr_5(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 1], 4), ([0, 1, 0, 0], 4)])\n        self.assertEqual(res1, 0.75)\n        self.assertEqual(res2, [1.0, 0.5])\n\n    def test_mrr_6(self):\n        try:\n            MetricsCalculator2.mrr(1)\n        except:\n            pass\n\n    def test_mrr_7(self):\n        res1, res2 = MetricsCalculator2.mrr([])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0])\n\n    def test_mrr_8(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 1], 0), ([0, 1, 0, 0], 0)])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0, 0.0])\n\n\nclass MetricsCalculator2TestMap(unittest.TestCase):\n    def test_map_1(self):\n        res1, res2 = MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        self.assertEqual(res1, 0.41666666666666663)\n        self.assertEqual(res2, [0.41666666666666663])\n\n    def test_map_2(self):\n        res1, res2 = MetricsCalculator2.map(([0, 0, 0, 1], 4))\n        self.assertEqual(res1, 0.0625)\n        self.assertEqual(res2, [0.0625])\n\n    def test_map_3(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        self.assertEqual(res1, 0.3333333333333333)\n        self.assertEqual(res2, [0.41666666666666663, 0.25])\n\n    def test_map_4(self):\n        res1, res2 = MetricsCalculator2.map([([1, 1, 1, 0], 4), ([0, 0, 0, 1], 4)])\n        self.assertEqual(res1, 0.40625)\n        self.assertEqual(res2, [0.75, 0.0625])\n\n    def test_map_5(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 1], 4), ([0, 1, 0, 0], 4)])\n        self.assertEqual(res1, 0.3645833333333333)\n        self.assertEqual(res2, [0.6041666666666666, 0.125])\n\n    def test_map_6(self):\n        try:\n            MetricsCalculator2.map(1)\n        except:\n            pass\n\n    def test_map_7(self):\n        res1, res2 = MetricsCalculator2.map([])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0])\n\n    def test_map_8(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 1], 0), ([0, 1, 0, 0], 0)])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0, 0.0])\n\n\nclass MetricsCalculator2Test(unittest.TestCase):\n    def test_metricscalculator2_1(self):\n        res1, res2 = MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        self.assertEqual(res1, 1.0)\n        self.assertEqual(res2, [1.0])\n\n    def test_metricscalculator2_2(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        self.assertEqual(res1, 0.75)\n        self.assertEqual(res2, [1.0, 0.5])\n\n    def test_metricscalculator2_3(self):\n        res1, res2 = MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        self.assertEqual(res1, 0.41666666666666663)\n        self.assertEqual(res2, [0.41666666666666663])\n\n    def test_metricscalculator2_4(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        self.assertEqual(res1, 0.3333333333333333)\n        self.assertEqual(res2, [0.41666666666666663, 0.25])",
    "solution_code": "import numpy as np\n\n\nclass MetricsCalculator2:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return mr, [mr]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n\n                separate_result.append(mr)\n            return np.mean(separate_result), separate_result\n\n    @staticmethod\n    def map(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return ap, [ap]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n\n                separate_result.append(ap)\n            return np.mean(separate_result), separate_result",
    "import_statement": [
      "import numpy as np"
    ],
    "class_description": "    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n",
    "class_name": "MetricsCalculator2",
    "test_classes": [
      "MetricsCalculator2TestMrr",
      "MetricsCalculator2TestMap",
      "MetricsCalculator2Test"
    ],
    "class_constructor": "class MetricsCalculator2: \n    def __init__(self):\n        pass\n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "mrr",
        "method_description": "def mrr(data):\n        \"\"\"\n        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        1.0, [1.0]\n        0.75, [1.0, 0.5]\n        \"\"\"",
        "test_class": "MetricsCalculator2TestMrr",
        "test_code": "class MetricsCalculator2TestMrr(unittest.TestCase):\n    def test_mrr_1(self):\n        mc2 = MetricsCalculator2()\n        res1, res2 = MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        self.assertEqual(res1, 1.0)\n        self.assertEqual(res2, [1.0])\n\n    def test_mrr_2(self):\n        res1, res2 = MetricsCalculator2.mrr(([0, 0, 0, 1], 4))\n        self.assertEqual(res1, 0.25)\n        self.assertEqual(res2, [0.25])\n\n    def test_mrr_3(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        self.assertEqual(res1, 0.75)\n        self.assertEqual(res2, [1.0, 0.5])\n\n    def test_mrr_4(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 1, 1, 0], 4), ([0, 0, 0, 1], 4)])\n        self.assertEqual(res1, 0.625)\n        self.assertEqual(res2, [1.0, 0.25])\n\n    def test_mrr_5(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 1], 4), ([0, 1, 0, 0], 4)])\n        self.assertEqual(res1, 0.75)\n        self.assertEqual(res2, [1.0, 0.5])\n\n    def test_mrr_6(self):\n        try:\n            MetricsCalculator2.mrr(1)\n        except:\n            pass\n\n    def test_mrr_7(self):\n        res1, res2 = MetricsCalculator2.mrr([])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0])\n\n    def test_mrr_8(self):\n        res1, res2 = MetricsCalculator2.mrr([([1, 0, 1, 1], 0), ([0, 1, 0, 0], 0)])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0, 0.0])",
        "solution_code": "def mrr(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return mr, [mr]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n\n                separate_result.append(mr)\n            return np.mean(separate_result), separate_result",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "map",
        "method_description": "@staticmethod\n    def map(data):\n        \"\"\"\n        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        0.41666666666666663, [0.41666666666666663]\n        0.3333333333333333, [0.41666666666666663, 0.25]\n        \"\"\"",
        "test_class": "MetricsCalculator2TestMap",
        "test_code": "class MetricsCalculator2TestMap(unittest.TestCase):\n    def test_map_1(self):\n        res1, res2 = MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        self.assertEqual(res1, 0.41666666666666663)\n        self.assertEqual(res2, [0.41666666666666663])\n\n    def test_map_2(self):\n        res1, res2 = MetricsCalculator2.map(([0, 0, 0, 1], 4))\n        self.assertEqual(res1, 0.0625)\n        self.assertEqual(res2, [0.0625])\n\n    def test_map_3(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        self.assertEqual(res1, 0.3333333333333333)\n        self.assertEqual(res2, [0.41666666666666663, 0.25])\n\n    def test_map_4(self):\n        res1, res2 = MetricsCalculator2.map([([1, 1, 1, 0], 4), ([0, 0, 0, 1], 4)])\n        self.assertEqual(res1, 0.40625)\n        self.assertEqual(res2, [0.75, 0.0625])\n\n    def test_map_5(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 1], 4), ([0, 1, 0, 0], 4)])\n        self.assertEqual(res1, 0.3645833333333333)\n        self.assertEqual(res2, [0.6041666666666666, 0.125])\n\n    def test_map_6(self):\n        try:\n            MetricsCalculator2.map(1)\n        except:\n            pass\n\n    def test_map_7(self):\n        res1, res2 = MetricsCalculator2.map([])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0])\n\n    def test_map_8(self):\n        res1, res2 = MetricsCalculator2.map([([1, 0, 1, 1], 0), ([0, 1, 0, 0], 0)])\n        self.assertEqual(res1, 0.0)\n        self.assertEqual(res2, [0.0, 0.0])",
        "solution_code": "@staticmethod\n    def map(data):\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return ap, [ap]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n\n                separate_result.append(ap)\n            return np.mean(separate_result), separate_result",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def _calculate_rr(result_list):\n        \"\"\"Helper to calculate Reciprocal Rank for a single result list.\"\"\"\n        try:\n            # Find the 1-indexed rank of the first correct result (value 1)\n            first_correct_index = result_list.index(1)\n            # Reciprocal Rank is 1 / rank (rank is index + 1)\n            return 1.0 / (first_correct_index + 1)\n        except ValueError:\n            # If 1 is not found in the list, RR is 0\n            return 0.0\n        except Exception as e:\n            # Handle potential issues with input format (though docstring suggests list of 0s and 1s)\n             print(f\"Warning: Could not calculate RR for {result_list}. Error: {e}\")\n             return 0.0 # Or raise error depending on desired strictness\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is a single tuple (actual result, ground truth num), return the reciprocal rank and a list containing just this RR.\n        if the input data is list of tuples, return the average reciprocal rank on all tuples and a list of RR for each input tuple.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        (1.0, [1.0])\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        (0.75, [1.0, 0.5])\n        \"\"\"\n        if isinstance(data, tuple):\n            # Handle single tuple input\n            if len(data) != 2 or not isinstance(data[0], (list, np.ndarray)) or not isinstance(data[1], (int, np.integer)):\n                 raise TypeError(\"Single data input must be a tuple ([results], gt_count) with results as list/array and gt_count as int.\")\n            results, _ = data # ground truth count is not used for MRR\n            rr = MetricsCalculator2._calculate_rr(results)\n            return rr, [rr]\n        elif isinstance(data, list):\n            # Handle list of tuples input\n            if not data:\n                # Handle empty list case\n                return 0.0, []\n\n            individual_rrs = []\n            for item in data:\n                if not isinstance(item, tuple) or len(item) != 2 or not isinstance(item[0], (list, np.ndarray)) or not isinstance(item[1], (int, np.integer)):\n                    raise TypeError(f\"All items in the list data must be tuples ([results], gt_count). Found invalid item: {item}\")\n                results, _ = item # ground truth count is not used for MRR\n                individual_rrs.append(MetricsCalculator2._calculate_rr(results))\n\n            # Calculate the mean MRR\n            average_mrr = np.mean(individual_rrs) if individual_rrs else 0.0 # np.mean handles empty gracefully but we handled it above\n            return average_mrr, individual_rrs\n        else:\n            raise TypeError(\"Input data must be a tuple (results, gt_count) or a list of such tuples.\")\n\n    @staticmethod\n    def _calculate_ap(result_list, ground_truth_count):\n        \"\"\"Helper to calculate Average Precision (AP) for a single result list and ground truth count.\"\"\"\n        # AP = (Sum of Precision@k for each correct item at rank k) / ground_truth_count\n\n        if ground_truth_count <= 0:\n            # If there are no ground truth items, AP is defined as 0.\n            # Also handles the case where ground_truth_count is zero.\n            return 0.0\n\n        sum_precisions = 0.0\n        correct_count_so_far = 0\n        for i, item in enumerate(result_list):\n            if item == 1:\n                # This item is correct (relevant)\n                correct_count_so_far += 1\n                # Precision at this rank (i+1) is (number of correct items so far) / (rank)\n                precision_at_rank = correct_count_so_far / (i + 1)\n                # Add this precision to the sum\n                sum_precisions += precision_at_rank\n            # If item is 0, it's incorrect, do nothing\n\n        # Average Precision is the sum of precisions at relevant ranks,\n        # divided by the total number of relevant items (ground truth count).\n        # Note: If result_list is shorter than ground_truth_count and not all relevant items were found,\n        # this correctly calculates the AP over the items found.\n        # If no correct items were found in result_list, sum_precisions will be 0, AP = 0/gt_count = 0.\n        return sum_precisions / ground_truth_count\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is a single tuple (actual result, ground truth num), return the average precision (AP) and a list containing just this AP.\n        if the input data is list of tuples, return the mean average precision (MAP) on all tuples and a list of AP for each input tuple.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        (0.41666666666666663, [0.41666666666666663])\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        (0.3333333333333333, [0.41666666666666663, 0.25])\n        \"\"\"\n        if isinstance(data, tuple):\n            # Handle single tuple input\n            if len(data) != 2 or not isinstance(data[0], (list, np.ndarray)) or not isinstance(data[1], (int, np.integer)):\n                 raise TypeError(\"Single data input must be a tuple ([results], gt_count) with results as list/array and gt_count as int.\")\n            results, gt_count = data\n            ap = MetricsCalculator2._calculate_ap(results, gt_count)\n            return ap, [ap]\n        elif isinstance(data, list):\n            # Handle list of tuples input\n            if not data:\n                 # Handle empty list case\n                 return 0.0, []\n\n            individual_aps = []\n            for item in data:\n                if not isinstance(item, tuple) or len(item) != 2 or not isinstance(item[0], (list, np.ndarray)) or not isinstance(item[1], (int, np.integer)):\n                    raise TypeError(f\"All items in the list data must be tuples ([results], gt_count). Found invalid item: {item}\")\n                results, gt_count = item\n                individual_aps.append(MetricsCalculator2._calculate_ap(results, gt_count))\n\n            # Calculate the mean MAP\n            average_map = np.mean(individual_aps) if individual_aps else 0.0 # np.mean handles empty gracefully but we handled it above\n            return average_map, individual_aps\n        else:\n            raise TypeError(\"Input data must be a tuple (results, gt_count) or a list of such tuples.\")\n\n# Example Usage (optional, for testing)\nif __name__ == '__main__':\n    # Run doctests (uncomment if you have doctest configured)\n    # import doctest\n    # doctest.testmod(verbose=True)\n\n    # Manual tests\n    print(\"--- Manual Tests ---\")\n    mrr_single, rrs_single = MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n    print(f\"MRR for ([1, 0, 1, 0], 4): {mrr_single}, individual RRs: {rrs_single}\") # Expected: 1.0, [1.0]\n\n    mrr_multiple, rrs_multiple = MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n    print(f\"MRR for [([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)]: {mrr_multiple}, individual RRs: {rrs_multiple}\") # Expected: 0.75, [1.0, 0.5]\n\n    map_single, aps_single = MetricsCalculator2.map(([1, 0, 1, 0], 4))\n    print(f\"MAP for ([1, 0, 1, 0], 4): {map_single}, individual APs: {aps_single}\") # Expected: 0.4166..., [0.4166...]\n\n    map_multiple, aps_multiple = MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n    print(f\"MAP for [([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)]: {map_multiple}, individual APs: {aps_multiple}\") # Expected: 0.3333..., [0.4166..., 0.25]\n\n    mrr_not_found, rrs_not_found = MetricsCalculator2.mrr(([0, 0, 0], 3))\n    print(f\"MRR for ([0, 0, 0], 3): {mrr_not_found}, individual RRs: {rrs_not_found}\") # Expected: 0.0, [0.0]\n\n    map_no_correct, aps_no_correct = MetricsCalculator2.map(([0, 0, 0], 3))\n    print(f\"MAP for ([0, 0, 0], 3): {aps_no_correct}, individual APs: {aps_no_correct}\") # Expected: 0.0, [0.0]\n\n    map_gt_zero, aps_gt_zero = MetricsCalculator2.map(([1, 0, 1], 0))\n    print(f\"MAP for ([1, 0, 1], 0): {map_gt_zero}, individual APs: {aps_gt_zero}\") # Expected: 0.0, [0.0]\n\n    mrr_empty_list, rrs_empty_list = MetricsCalculator2.mrr([])\n    print(f\"MRR for []: {mrr_empty_list}, individual RRs: {rrs_empty_list}\") # Expected: 0.0, []\n\n    map_empty_list, aps_empty_list = MetricsCalculator2.map([])\n    print(f\"MAP for []: {map_empty_list}, individual APs: {aps_empty_list}\") # Expected: 0.0, []\n```"
    ]
  },
  {
    "task_id": "ClassEval_81",
    "skeleton": "import math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"",
    "test": "import unittest\n\nclass Statistics3TestMedian(unittest.TestCase):\n    def test_median(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4]), 2.5)\n\n    def test_median_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5]), 3)\n\n    def test_median_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6]), 3.5)\n\n    def test_median_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7]), 4)\n\n    def test_median_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7, 8]), 4.5)\n\nclass Statistics3TestMode(unittest.TestCase):\n    def test_mode(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3]), [3])\n\n    def test_mode_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4]), [3, 4])\n\n    def test_mode_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5]), [3, 4])\n\n    def test_mode_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5]), [3, 4, 5])\n\n    def test_mode_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5, 6]), [3, 4, 5])\n\nclass Statistics3TestCorrelation(unittest.TestCase):\n    def test_correlation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [4, 5, 6]), 1.0)\n\n    def test_correlation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3, 4], [5, 6, 7, 8]), 1.0)\n\n    def test_correlation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [1,2,3]), 1.0)\n\n    def test_correlation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [2,2,2]), None)\n\n    def test_correlation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [1,1,1]), None)\n\nclass Statistics3TestMean(unittest.TestCase):\n    def test_mean(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 2, 3]), 2.0)\n\n    def test_mean_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([]), None)\n\n    def test_mean_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1]), 1.0)\n\n    def test_mean_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1]), 1.0)\n\n    def test_mean_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1, 1]), 1.0)\n\nclass Statistics3TestCorrelationMatrix(unittest.TestCase):\n    def test_correlation_matrix(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3]]), [[None, None, None], [None, None, None], [None, None, None]])\n\n    def test_correlation_matrix_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12], [13, 14, 15]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\nclass Statistics3TestStandardDeviation(unittest.TestCase):\n    def test_standard_deviation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 2, 3]), 1.0)\n\n    def test_standard_deviation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1]), 0.0)\n\n    def test_standard_deviation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1]), 0.0)\n\n    def test_standard_deviation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1, 1]), 0.0)\n\n    def test_standard_deviation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 2, 1, 4]), 1.3038404810405297)\n\n\nclass Statistics3TestZScore(unittest.TestCase):\n    def test_z_score(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 2, 3, 4]), [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225])\n\n    def test_z_score_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1]), None)\n\n    def test_z_score_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1]),None)\n\n    def test_z_score_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 2, 3]), [-0.7833494518006403,-0.7833494518006403,0.26111648393354675,1.3055824196677337])\n\n    def test_z_score_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1, 1]), None)\n\n\nclass Statistics3TestMain(unittest.TestCase):\n    def test_main(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4]), 2.5)\n        self.assertEqual(statistics3.mode([1, 2, 3, 3]), [3])\n        self.assertEqual(statistics3.correlation([1, 2, 3], [4, 5, 6]), 1.0)\n        self.assertEqual(statistics3.mean([1, 2, 3]), 2.0)\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n        self.assertEqual(statistics3.standard_deviation([1, 2, 3]), 1.0)\n        self.assertEqual(statistics3.z_score([1, 2, 3, 4]), [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225])",
    "solution_code": "import math\nclass Statistics3:\n    @staticmethod\n    def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]",
    "import_statement": [
      "import math"
    ],
    "class_description": "    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n",
    "class_name": "Statistics3",
    "test_classes": [
      "Statistics3TestMedian",
      "Statistics3TestMode",
      "Statistics3TestCorrelation",
      "Statistics3TestMean",
      "Statistics3TestCorrelationMatrix",
      "Statistics3TestStandardDeviation",
      "Statistics3TestZScore",
      "Statistics3TestMain"
    ],
    "class_constructor": "class Statistics3: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "median",
        "method_description": "def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"",
        "test_class": "Statistics3TestMedian",
        "test_code": "class Statistics3TestMedian(unittest.TestCase):\n    def test_median(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4]), 2.5)\n\n    def test_median_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5]), 3)\n\n    def test_median_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6]), 3.5)\n\n    def test_median_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7]), 4)\n\n    def test_median_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7, 8]), 4.5)",
        "solution_code": "def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "mode",
        "method_description": "@staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"",
        "test_class": "Statistics3TestMode",
        "test_code": "class Statistics3TestMode(unittest.TestCase):\n    def test_mode(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3]), [3])\n\n    def test_mode_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4]), [3, 4])\n\n    def test_mode_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5]), [3, 4])\n\n    def test_mode_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5]), [3, 4, 5])\n\n    def test_mode_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5, 6]), [3, 4, 5])",
        "solution_code": "@staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "correlation",
        "method_description": "@staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"",
        "test_class": "Statistics3TestCorrelation",
        "test_code": "class Statistics3TestCorrelation(unittest.TestCase):\n    def test_correlation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [4, 5, 6]), 1.0)\n\n    def test_correlation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3, 4], [5, 6, 7, 8]), 1.0)\n\n    def test_correlation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [1,2,3]), 1.0)\n\n    def test_correlation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [2,2,2]), None)\n\n    def test_correlation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [1,1,1]), None)",
        "solution_code": "@staticmethod\n    def correlation(x, y):\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        if denominator == 0:\n            return None\n        return numerator / denominator",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": [
            "mean"
          ]
        }
      },
      {
        "method_name": "mean",
        "method_description": "@staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"",
        "test_class": "Statistics3TestMean",
        "test_code": "class Statistics3TestMean(unittest.TestCase):\n    def test_mean(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 2, 3]), 2.0)\n\n    def test_mean_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([]), None)\n\n    def test_mean_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1]), 1.0)\n\n    def test_mean_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1]), 1.0)\n\n    def test_mean_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1, 1]), 1.0)",
        "solution_code": "@staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "correlation_matrix",
        "method_description": "@staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"",
        "test_class": "Statistics3TestCorrelationMatrix",
        "test_code": "class Statistics3TestCorrelationMatrix(unittest.TestCase):\n    def test_correlation_matrix(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3]]), [[None, None, None], [None, None, None], [None, None, None]])\n\n    def test_correlation_matrix_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12], [13, 14, 15]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])",
        "solution_code": "@staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "correlation"
          ]
        }
      },
      {
        "method_name": "standard_deviation",
        "method_description": "@staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"",
        "test_class": "Statistics3TestStandardDeviation",
        "test_code": "class Statistics3TestStandardDeviation(unittest.TestCase):\n    def test_standard_deviation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 2, 3]), 1.0)\n\n    def test_standard_deviation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1]), 0.0)\n\n    def test_standard_deviation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1]), 0.0)\n\n    def test_standard_deviation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1, 1]), 0.0)\n\n    def test_standard_deviation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 2, 1, 4]), 1.3038404810405297)",
        "solution_code": "@staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        return math.sqrt(variance)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "math"
          ],
          "field_dependencies": [],
          "method_dependencies": [
            "mean"
          ]
        }
      },
      {
        "method_name": "z_score",
        "method_description": "@staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"",
        "test_class": "Statistics3TestZScore",
        "test_code": "class Statistics3TestZScore(unittest.TestCase):\n    def test_z_score(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 2, 3, 4]), [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225])\n\n    def test_z_score_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1]), None)\n\n    def test_z_score_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1]),None)\n\n    def test_z_score_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 2, 3]), [-0.7833494518006403,-0.7833494518006403,0.26111648393354675,1.3055824196677337])\n\n    def test_z_score_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1, 1]), None)",
        "solution_code": "@staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "mean",
            "standard_deviation"
          ]
        }
      }
    ],
    "predict": [
      "```python\nimport math\nfrom collections import Counter\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n        if not data:\n            raise ValueError(\"Mean is undefined for an empty list\")\n        return sum(data) / len(data)\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n        if not data:\n            raise ValueError(\"Median is undefined for an empty list\")\n\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid_index = n // 2\n\n        if n % 2 == 1:\n            # Odd number of elements\n            return float(sorted_data[mid_index])\n        else:\n            # Even number of elements\n            return (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2.0\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n        if not data:\n            return [] # Or raise ValueError(\"Mode is undefined for an empty list\") - returning [] aligns better with list return type\n\n        counts = Counter(data)\n        max_count = max(counts.values())\n\n        # If all elements have the same frequency (1 in a list with unique elements)\n        # or any frequency > 1, find all elements with max_count.\n        # Returning elements with frequency 1 when max_count is 1 is one definition of mode behavior.\n        # The doctest [1, 2, 3, 3] -> [3] implies we return the element(s) with the strictly highest frequency.\n        # If max_count is 1 and n > 1, then there isn't a value that appears *more* often than others.\n        # Let's follow the doctest and return modes with the highest frequency.\n        modes = [item for item, count in counts.items() if count == max_count]\n\n        # Sort the modes for deterministic output, although the definition of mode itself doesn't require order.\n        # This helps with testing.\n        return sorted(modes)\n\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n        n = len(data)\n        if n < 2:\n            # Sample standard deviation (using N-1) requires at least 2 data points.\n            # For N=0 or N=1, it's mathematically undefined or results in division by zero.\n            raise ValueError(\"Standard deviation requires at least two data points\")\n\n        mu = Statistics3.mean(data)\n        variance = sum([(x - mu) ** 2 for x in data]) / (n - 1) # Using sample variance (N-1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n        n = len(x)\n        if n != len(y):\n            raise ValueError(\"Input lists must have the same length\")\n        if n < 2:\n            # Correlation requires at least two data points\n            raise ValueError(\"Correlation requires at least two data points\")\n\n        try:\n            mean_x = Statistics3.mean(x)\n            mean_y = Statistics3.mean(y)\n            std_dev_x = Statistics3.standard_deviation(x)\n            std_dev_y = Statistics3.standard_deviation(y)\n        except ValueError:\n             # This would catch errors from mean/std_dev on empty/single lists,\n             # but the n < 2 check above already handles the main case.\n             # It could potentially catch issues if mean/std_dev logic changes,\n             # but let's rely on the explicit checks for now.\n             raise # Re-raise the ValueError if it occurs unexpectedly\n\n        # Handle cases where standard deviation is zero (all values are the same)\n        if std_dev_x == 0 or std_dev_y == 0:\n            # Correlation is undefined if variance is zero for either list.\n            # Return NaN as per common statistical package behavior.\n            return math.nan\n\n        # Calculate covariance\n        covariance = sum([(xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y)]) / (n - 1)\n\n        # Calculate correlation\n        correlation = covariance / (std_dev_x * std_dev_y)\n\n        # Due to floating point inaccuracies, the result might be slightly outside [-1, 1].\n        # Clamp it to the valid range.\n        return max(-1.0, min(1.0, correlation))\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list. (Each inner list is a variable)\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n        num_vars = len(data)\n        if num_vars == 0:\n            return []\n\n        # Check if all inner lists have the same length (number of observations)\n        num_observations = len(data[0]) if num_vars > 0 else 0\n        if any(len(lst) != num_observations for lst in data):\n             raise ValueError(\"All inner lists (variables) must have the same length (number of observations)\")\n\n        # Correlation requires at least two data points per variable\n        if num_observations < 2:\n             raise ValueError(\"Each variable list must contain at least 2 data points to calculate correlation\")\n\n\n        matrix = [[0.0 for _ in range(num_vars)] for _ in range(num_vars)]\n\n        # Fill the matrix\n        for i in range(num_vars):\n            for j in range(num_vars):\n                if i == j:\n                    matrix[i][j] = 1.0 # Correlation of a variable with itself is 1\n                else:\n                    # Calculate correlation between variable i (data[i]) and variable j (data[j])\n                    matrix[i][j] = Statistics3.correlation(data[i], data[j])\n\n        return matrix\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"\n        n = len(data)\n        if n < 2:\n            # Z-score is undefined for n=0 or n=1 (std dev is undefined/zero)\n            raise ValueError(\"Z-score requires at least two data points\")\n        try:\n            mu = Statistics3.mean(data)\n            std_dev = Statistics3.standard_deviation(data)\n        except ValueError as e:\n             # Catch the ValueError from standard_deviation if n < 2 (already checked, but safe)\n             # Or if std_dev is somehow calculated as 0 unexpectedly (e.g. floating point issue)\n             raise ValueError(f\"Could not calculate Z-scores: {e}\")\n\n\n        if std_dev == 0:\n            # Z-score is undefined if standard deviation is zero (all data points are the same)\n             raise ValueError(\"Z-score is undefined when standard deviation is zero\")\n\n        z_scores = [(x - mu) / std_dev for x in data]\n        return z_scores\n\n# Example usage (optional, for testing):\nif __name__ == '__main__':\n    print(\"Testing Median:\")\n    print(f\"[1, 2, 3, 4] -> {Statistics3.median([1, 2, 3, 4])}\")\n    print(f\"[1, 2, 3] -> {Statistics3.median([1, 2, 3])}\")\n    # print(f\"[] -> {Statistics3.median([])}\") # Should raise ValueError\n\n    print(\"\\nTesting Mode:\")\n    print(f\"[1, 2, 3, 3] -> {Statistics3.mode([1, 2, 3, 3])}\")\n    print(f\"[1, 1, 2, 2, 3] -> {Statistics3.mode([1, 1, 2, 2, 3])}\")\n    print(f\"[1, 2, 3] -> {Statistics3.mode([1, 2, 3])}\") # Should return [1, 2, 3] based on impl\n    print(f\"[] -> {Statistics3.mode([])}\")\n\n    print(\"\\nTesting Correlation:\")\n    print(f\"[1, 2, 3], [4, 5, 6] -> {Statistics3.correlation([1, 2, 3], [4, 5, 6])}\")\n    print(f\"[1, 2, 3], [3, 2, 1] -> {Statistics3.correlation([1, 2, 3], [3, 2, 1])}\")\n    print(f\"[1, 2, 3], [5, 5, 5] -> {Statistics3.correlation([1, 2, 3], [5, 5, 5])}\") # Should be NaN\n    # print(f\"[1], [2] -> {Statistics3.correlation([1], [2])}\") # Should raise ValueError\n\n    print(\"\\nTesting Mean:\")\n    print(f\"[1, 2, 3] -> {Statistics3.mean([1, 2, 3])}\")\n    print(f\"[10] -> {Statistics3.mean([10])}\")\n    # print(f\"[] -> {Statistics3.mean([])}\") # Should raise ValueError\n\n    print(\"\\nTesting Standard Deviation:\")\n    print(f\"[1, 2, 3] -> {Statistics3.standard_deviation([1, 2, 3])}\")\n    print(f\"[5, 5, 5] -> {Statistics3.standard_deviation([5, 5, 5])}\")\n    # print(f\"[1] -> {Statistics3.standard_deviation([1])}\") # Should raise ValueError\n    # print(f\"[] -> {Statistics3.standard_deviation([])}\") # Should raise ValueError\n\n\n    print(\"\\nTesting Correlation Matrix:\")\n    data_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(f\"{data_matrix} -> {Statistics3.correlation_matrix(data_matrix)}\")\n\n    data_matrix_nan = [[1, 2, 3], [4, 5, 6], [10, 10, 10]]\n    print(f\"{data_matrix_nan} -> {Statistics3.correlation_matrix(data_matrix_nan)}\")\n\n    # print(f\"[[1], [2]] -> {Statistics3.correlation_matrix([[1], [2]])}\") # Should raise ValueError\n    print(f\"[] -> {Statistics3.correlation_matrix([])}\")\n\n    print(\"\\nTesting Z-score:\")\n    print(f\"[1, 2, 3, 4] -> {Statistics3.z_score([1, 2, 3, 4])}\")\n    print(f\"[10, 20, 30] -> {Statistics3.z_score([10, 20, 30])}\")\n    # print(f\"[5, 5, 5] -> {Statistics3.z_score([5, 5, 5])}\") # Should raise ValueError\n    # print(f\"[1] -> {Statistics3.z_score([1])}\") # Should raise ValueError\n    print(f\"[] -> {Statistics3.z_score([])}\")\n\n```"
    ]
  },
  {
    "task_id": "ClassEval_88",
    "skeleton": "from math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"",
    "test": "import unittest\n\n\nclass TriCalculatorTestCos(unittest.TestCase):\n    def test_cos_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(60), 0.5)\n\n    def test_cos_2(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.cos(30), 0.8660254038)\n\n    def test_cos_3(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(0), 1.0)\n\n    def test_cos_4(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(90), 0.0)\n\n    def test_cos_5(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.cos(45), 0.7071067812)\n\n\nclass TriCalculatorTestFactorial(unittest.TestCase):\n    def test_factorial_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(5), 120)\n\n    def test_factorial_2(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(4), 24)\n\n    def test_factorial_3(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(3), 6)\n\n    def test_factorial_4(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(2), 2)\n\n    def test_factorial_5(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(1), 1)\n\n\nclass TriCalculatorTestTaylor(unittest.TestCase):\n    def test_taylor_1(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(60, 50), 0.5)\n\n    def test_taylor_2(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(30, 50), 0.8660254037844386)\n\n    def test_taylor_3(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(90, 50), 0.0)\n\n    def test_taylor_4(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(0, 50), 1.0)\n\n    def test_taylor_5(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(45, 50), 0.7071067811865475)\n\n\nclass TriCalculatorTestSin(unittest.TestCase):\n    def test_sin_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.sin(30), 0.5)\n\n    def test_sin_2(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.sin(60), 0.8660254038)\n\n    def test_sin_3(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.sin(0), 0.0)\n\n    def test_sin_4(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.sin(90), 1.0)\n\n    def test_sin_5(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.sin(45), 0.7071067812)\n\n\nclass TriCalculatorTestTan(unittest.TestCase):\n    def test_tan_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.tan(45), 1.0)\n\n    def test_tan_2(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.tan(90), False)\n\n    def test_tan_3(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.tan(30), 0.5773502692)\n\n    def test_tan_4(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.tan(60), 1.7320508076)\n\n    def test_tan_5(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.tan(0), 0.0)\n\n\nclass TriCalculatorTest(unittest.TestCase):\n    def test_tricalculator(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(60), 0.5)\n        self.assertAlmostEqual(tricalculator.taylor(60, 50), 0.5)\n        self.assertEqual(tricalculator.sin(30), 0.5)\n        self.assertEqual(tricalculator.tan(45), 1.0)\n        self.assertEqual(tricalculator.tan(90), False)",
    "solution_code": "from math import pi, fabs\n\n\nclass TriCalculator:\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        b = 1\n        while a != 1:\n            b *= a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        a = 1\n        x = x / 180 * pi\n        count = 1\n        for k in range(1, n):\n            if count % 2 != 0:\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n            count += 1\n        return a\n\n    def sin(self, x):\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)\n\n    def tan(self, x):\n        if self.cos(x) != 0:\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            return False",
    "import_statement": [
      "from math import pi, fabs"
    ],
    "class_description": "    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n",
    "class_name": "TriCalculator",
    "test_classes": [
      "TriCalculatorTestCos",
      "TriCalculatorTestFactorial",
      "TriCalculatorTestTaylor",
      "TriCalculatorTestSin",
      "TriCalculatorTestTan",
      "TriCalculatorTest"
    ],
    "class_constructor": "class TriCalculator: \n    def __init__(self):\n        pass\n\n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "cos",
        "method_description": "def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"",
        "test_class": "TriCalculatorTestCos",
        "test_code": "class TriCalculatorTestCos(unittest.TestCase):\n    def test_cos_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(60), 0.5)\n\n    def test_cos_2(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.cos(30), 0.8660254038)\n\n    def test_cos_3(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(0), 1.0)\n\n    def test_cos_4(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.cos(90), 0.0)\n\n    def test_cos_5(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.cos(45), 0.7071067812)",
        "solution_code": "def cos(self, x):\n        return round(self.taylor(x, 50), 10)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "taylor"
          ]
        }
      },
      {
        "method_name": "factorial",
        "method_description": "def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"",
        "test_class": "TriCalculatorTestFactorial",
        "test_code": "class TriCalculatorTestFactorial(unittest.TestCase):\n    def test_factorial_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(5), 120)\n\n    def test_factorial_2(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(4), 24)\n\n    def test_factorial_3(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(3), 6)\n\n    def test_factorial_4(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(2), 2)\n\n    def test_factorial_5(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.factorial(1), 1)",
        "solution_code": "def factorial(self, a):\n        b = 1\n        while a != 1:\n            b *= a\n            a -= 1\n        return b",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "taylor",
        "method_description": "def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"",
        "test_class": "TriCalculatorTestTaylor",
        "test_code": "class TriCalculatorTestTaylor(unittest.TestCase):\n    def test_taylor_1(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(60, 50), 0.5)\n\n    def test_taylor_2(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(30, 50), 0.8660254037844386)\n\n    def test_taylor_3(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(90, 50), 0.0)\n\n    def test_taylor_4(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(0, 50), 1.0)\n\n    def test_taylor_5(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.taylor(45, 50), 0.7071067811865475)",
        "solution_code": "def taylor(self, x, n):\n        a = 1\n        x = x / 180 * pi\n        count = 1\n        for k in range(1, n):\n            if count % 2 != 0:\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n            count += 1\n        return a",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "factorial"
          ]
        }
      },
      {
        "method_name": "sin",
        "method_description": "def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"",
        "test_class": "TriCalculatorTestSin",
        "test_code": "class TriCalculatorTestSin(unittest.TestCase):\n    def test_sin_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.sin(30), 0.5)\n\n    def test_sin_2(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.sin(60), 0.8660254038)\n\n    def test_sin_3(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.sin(0), 0.0)\n\n    def test_sin_4(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.sin(90), 1.0)\n\n    def test_sin_5(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.sin(45), 0.7071067812)",
        "solution_code": "def sin(self, x):\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "tan",
        "method_description": "def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"",
        "test_class": "TriCalculatorTestTan",
        "test_code": "class TriCalculatorTestTan(unittest.TestCase):\n    def test_tan_1(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.tan(45), 1.0)\n\n    def test_tan_2(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.tan(90), False)\n\n    def test_tan_3(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.tan(30), 0.5773502692)\n\n    def test_tan_4(self):\n        tricalculator = TriCalculator()\n        self.assertAlmostEqual(tricalculator.tan(60), 1.7320508076)\n\n    def test_tan_5(self):\n        tricalculator = TriCalculator()\n        self.assertEqual(tricalculator.tan(0), 0.0)",
        "solution_code": "def tan(self, x):\n        if self.cos(x) != 0:\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            return False",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "cos",
            "sin"
          ]
        }
      }
    ],
    "predict": [
      "```python\nfrom math import pi, fabs\nimport math # Import math for comparisons if needed in tests, although the implementation should only use pi, fabs and potentially math.inf\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        # Initialize any necessary attributes here if needed later\n        pass\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a non-negative integer.\n        :param a: int, a non-negative integer\n        :return: int, the factorial of a\n        :raises ValueError: if a is not a non-negative integer.\n        >>> tricalculator = TriCalculator() # Added instance creation for doctest consistency\n        >>> tricalculator.factorial(5)\n        120\n        >>> tricalculator.factorial(0)\n        1\n        >>> tricalculator.factorial(1)\n        1\n        \"\"\"\n        if not isinstance(a, int) or a < 0:\n             raise ValueError(\"Factorial is defined only for non-negative integers\")\n\n        if a == 0 or a == 1:\n            return 1\n\n        result = 1\n        # Calculate factorial iteratively for positive integers\n        for i in range(2, a + 1):\n            result *= i\n        return result\n\n    def taylor_cos(self, x_rad, n):\n        \"\"\"\n        Helper method to calculate the n-order Taylor expansion of cos(x_rad).\n        cos(x) = sum((-1)^k * x^(2k) / (2k)!), k from 0 to n\n        :param x_rad: float, angle in radians\n        :param n: int, order of expansion (number of terms is n+1)\n        :return: float\n        :raises ValueError: if n is not a non-negative integer.\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n             raise ValueError(\"Order n must be a non-negative integer\")\n\n        result = 0.0\n        for k in range(n + 1):\n            try:\n                # Calculate term: (-1)^k * x_rad^(2k) / (2k)!\n                power_of_x = x_rad**(2*k)\n                denom = self.factorial(2*k)\n\n                # Handle division by zero if factorial somehow returns 0 (shouldn't happen for non-negative inputs)\n                if denom == 0:\n                     # This case is highly unlikely with correct factorial implementation for non-negative input,\n                     # but included for robustness.\n                     print(f\"Warning: Factorial resulted in zero denominator for k={k}. Skipping term.\")\n                     continue\n\n                term = ((-1)**k) * power_of_x / denom\n                result += term\n            except OverflowError:\n                 # If terms become too large, subsequent terms likely won't help convergence\n                 # for standard float types. Stop the summation.\n                 print(f\"Warning: Overflow encountered calculating term k={k} in taylor_cos. Summation stopped prematurely.\")\n                 break # Stop summation if overflow occurs\n\n        return result\n\n    def taylor_sin(self, x_rad, n):\n        \"\"\"\n        Helper method to calculate the n-order Taylor expansion of sin(x_rad).\n        sin(x) = sum((-1)^k * x^(2k+1) / (2k+1)!), k from 0 to n\n        :param x_rad: float, angle in radians\n        :param n: int, order of expansion (number of terms is n+1)\n        :return: float\n        :raises ValueError: if n is not a non-negative integer.\n        \"\"\"\n        if not isinstance(n, int) or n < 0:\n             raise ValueError(\"Order n must be a non-negative integer\")\n\n        result = 0.0\n        for k in range(n + 1):\n            try:\n                # Calculate term: (-1)^k * x_rad^(2k+1) / (2k+1)!\n                power_of_x = x_rad**(2*k + 1)\n                denom = self.factorial(2*k + 1)\n\n                if denom == 0:\n                     print(f\"Warning: Factorial resulted in zero denominator for k={k}. Skipping term.\")\n                     continue\n\n                term = ((-1)**k) * power_of_x / denom\n                result += term\n            except OverflowError:\n                 print(f\"Warning: Overflow encountered calculating term k={k} in taylor_sin. Summation stopped prematurely.\")\n                 break\n\n        return result\n\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle using Taylor series.\n        :param x: float, angle in degrees\n        :return: float, the cosine value\n        >>> tricalculator = TriCalculator()\n        >>> abs(tricalculator.cos(60) - 0.5) < 1e-9 # Use absolute difference for float comparison\n        True\n        >>> abs(tricalculator.cos(0) - 1.0) < 1e-9\n        True\n        >>> abs(tricalculator.cos(180) - (-1.0)) < 1e-9\n        True\n        \"\"\"\n        # Convert degrees to radians for the Taylor series\n        x_rad = x * pi / 180.0\n\n        # Choose a sufficient number of terms for accuracy. 50 is a common value\n        # for reasonable precision for inputs within a moderate range.\n        n_terms = 50\n\n        return self.taylor_cos(x_rad, n_terms)\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi).\n        Note: This method name is slightly ambiguous as it's specifically for cosine,\n        but follows the provided docstring and name. It wraps the internal taylor_cos.\n        :param x: float, angle in degrees\n        :param n: int, order of expansion\n        :return: float\n        >>> tricalculator = TriCalculator() # Added instance creation for doctest consistency\n        >>> abs(tricalculator.taylor(60, 50) - 0.5000000000000001) < 1e-15 # Comparing against the exact doctest value\n        True\n        >>> abs(tricalculator.taylor(0, 10) - 1.0) < 1e-9\n        True\n        \"\"\"\n        # Convert degrees to radians\n        x_rad = x * pi / 180.0\n        return self.taylor_cos(x_rad, n)\n\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle using Taylor series.\n        :param x: float, angle in degrees\n        :return: float, the sine value\n        >>> tricalculator = TriCalculator()\n        >>> abs(tricalculator.sin(30) - 0.5) < 1e-9 # Use absolute difference for float comparison\n        True\n        >>> abs(tricalculator.sin(90) - 1.0) < 1e-9\n        True\n        >>> abs(tricalculator.sin(180) - 0.0) < 1e-9\n        True\n        \"\"\"\n        # Convert degrees to radians for the Taylor series\n        x_rad = x * pi / 180.0\n\n        # Choose a sufficient number of terms\n        n_terms = 50 # Use the same number of terms as cos for consistency\n\n        return self.taylor_sin(x_rad, n_terms)\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle as sin(x)/cos(x).\n        Handles cases where cos(x) is zero or very close to zero (singularities).\n        :param x: float, angle in degrees\n        :return: float, the tangent value, or a large positive/negative float near singularities.\n        :raises ZeroDivisionError: Potentially, if cos(x) evaluates to exactly 0.0.\n        >>> tricalculator = TriCalculator()\n        >>> abs(tricalculator.tan(45) - 1.0) < 1e-9 # Use absolute difference for float comparison\n        True\n        >>> abs(tricalculator.tan(0) - 0.0) < 1e-9\n        True\n        >>> # Test near singularity (90 degrees) - expect a large value\n        >>> abs(tricalculator.tan(89.999)) > 1e10\n        True\n        \"\"\"\n        sin_val = self.sin(x)\n        cos_val = self.cos(x)\n\n        # Handle division by zero or values very close to zero\n        # Due to floating point approximations, cos_val might not be exactly 0.0\n        # at 90 or 270 degrees, but a very small number. The division will\n        # result in a very large float, which is the expected behavior near\n        # a singularity.\n        # A small tolerance check is good practice to prevent ZeroDivisionError\n        # if cos_val somehow becomes exactly 0.0.\n        tolerance = 1e-15 # Define a small tolerance\n\n        if fabs(cos_val) < tolerance:\n            # Angle is close to a singularity (90, 270, etc.).\n            # Check the sign of the sine value to determine positive or negative infinity direction\n            # This is a simplified check; a more robust check would involve the quadrant or\n            # angle modulo 180.\n            # Given the approximation, we will likely get a very large float rather than true infinity.\n            # Let the division happen and potentially raise ZeroDivisionError or produce a large float.\n            # If cos_val is extremely close but not exactly 0, division results in a large float.\n            # If cos_val is exactly 0.0, it raises ZeroDivisionError.\n            # Raising ZeroDivisionError for exact singularities is a valid behavior.\n            # Alternatively, return math.copysign(math.inf, sin_val) for cleaner infinity handling.\n            # For now, let's rely on float division behavior which usually produces a large number.\n             pass # Allow division to proceed, it will result in a large float or ZeroDivisionError\n\n        return sin_val / cos_val\n\n# Example of how to use the class (optional, for demonstration)\nif __name__ == '__main__':\n    calculator = TriCalculator()\n\n    print(f\"Factorial of 5: {calculator.factorial(5)}\")\n    print(f\"Factorial of 0: {calculator.factorial(0)}\")\n\n    angle_deg = 60\n    print(f\"cos({angle_deg} degrees) approx: {calculator.cos(angle_deg)}\")\n    print(f\"sin({angle_deg} degrees) approx: {calculator.sin(angle_deg)}\")\n    print(f\"tan({angle_deg} degrees) approx: {calculator.tan(angle_deg)}\")\n\n    angle_deg = 90\n    print(f\"cos({angle_deg} degrees) approx: {calculator.cos(angle_deg)}\") # Should be close to 0\n    print(f\"sin({angle_deg} degrees) approx: {calculator.sin(angle_deg)}\") # Should be close to 1\n    try:\n        print(f\"tan({angle_deg} degrees) approx: {calculator.tan(angle_deg)}\") # Should be very large or raise error\n    except ZeroDivisionError:\n        print(f\"tan({angle_deg} degrees): Division by zero (singularity)\")\n\n    angle_deg = 180\n    print(f\"cos({angle_deg} degrees) approx: {calculator.cos(angle_deg)}\") # Should be close to -1\n    print(f\"sin({angle_deg} degrees) approx: {calculator.sin(angle_deg)}\") # Should be close to 0\n    print(f\"tan({angle_deg} degrees) approx: {calculator.tan(angle_deg)}\") # Should be close to 0\n\n    # Test taylor specific method\n    print(f\"Taylor cos(60 deg, n=10): {calculator.taylor(60, 10)}\")\n    print(f\"Taylor cos(60 deg, n=50): {calculator.taylor(60, 50)}\")\n\n    # Example of invalid input handling\n    try:\n        calculator.factorial(-5)\n    except ValueError as e:\n        print(f\"Caught expected error: {e}\")\n\n    try:\n        calculator.taylor(60, -1)\n    except ValueError as e:\n        print(f\"Caught expected error: {e}\")\n```"
    ]
  }
]