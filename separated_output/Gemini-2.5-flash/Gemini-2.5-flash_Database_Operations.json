[
  {
    "task_id": "ClassEval_14",
    "skeleton": "import sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        \"\"\"\n    \n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        \"\"\"\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        \"\"\"\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        \"\"\"\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        \"\"\"\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        \"\"\"",
    "test": "import unittest\nimport os\n\n\nclass BookManagementDBTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_create_table_1(self):\n        # Check if the table exists\n        self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='books'\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n\n    def test_create_table_2(self):\n        self.db.create_table()\n        # Check if the table has the correct columns\n        self.cursor.execute(\"PRAGMA table_info(books)\")\n        columns = self.cursor.fetchall()\n        column_names = [column[1] for column in columns]\n        expected_column_names = ['id', 'title', 'author', 'available']\n        self.assertEqual(column_names, expected_column_names)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestAddBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_add_book(self):\n        title = \"Introduction to Python\"\n        author = \"John Smith\"\n        self.db.add_book(title, author)\n\n        # Check if the book was added correctly\n        self.cursor.execute(\"SELECT title, author, available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], title)\n        self.assertEqual(result[1], author)\n        self.assertEqual(result[2], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestRemoveBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing removal\n        self.db.add_book(\"Book to Remove\", \"John Doe\")\n\n    def test_remove_book(self):\n        self.db.remove_book(1)\n\n        # Check if the book was removed correctly\n        self.cursor.execute(\"SELECT * FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNone(result)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestBorrowBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing borrowing\n        self.db.add_book(\"Book to Borrow\", \"Jane Smith\")\n\n    def test_borrow_book(self):\n        self.db.borrow_book(1)\n\n        # Check if the book was marked as unavailable\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 0)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestReturnBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing returning\n        self.db.add_book(\"Book to Return\", \"James Smith\")\n        self.db.borrow_book(1)  # Mark the book as borrowed\n\n    def test_return_book(self):\n        self.db.return_book(1)\n\n        # Check if the book was marked as available again\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)\n\n\nclass BookManagementDBTestSearchBooks(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add some books for testing search\n        self.db.add_book(\"Book 1\", \"Author 1\")\n        self.db.add_book(\"Book 2\", \"Author 2\")\n        self.db.add_book(\"Book 3\", \"Author 3\")\n\n    def test_search_books(self):\n        books = self.db.search_books()\n\n        # Ensure that all books were retrieved\n        self.assertEqual(len(books), 3)\n\n        # Ensure that the correct book information is retrieved\n        self.assertEqual(books[0][1], \"Book 1\")\n        self.assertEqual(books[1][2], \"Author 2\")\n        self.assertEqual(books[2][3], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
    "solution_code": "import sqlite3\n\nclass BookManagementDB:\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        books = self.cursor.fetchall()\n        return books",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n",
    "class_name": "BookManagementDB",
    "test_classes": [
      "BookManagementDBTestCreateTable",
      "BookManagementDBTestAddBook",
      "BookManagementDBTestRemoveBook",
      "BookManagementDBTestBorrowBook",
      "BookManagementDBTestReturnBook",
      "BookManagementDBTestSearchBooks"
    ],
    "class_constructor": "class BookManagementDB: \n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n",
    "fields": [
      "self.connection",
      "self.cursor"
    ],
    "methods_info": [
      {
        "method_name": "create_table",
        "method_description": "def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        \"\"\"",
        "test_class": "BookManagementDBTestCreateTable",
        "test_code": "class BookManagementDBTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_create_table_1(self):\n        # Check if the table exists\n        self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='books'\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n\n    def test_create_table_2(self):\n        self.db.create_table()\n        # Check if the table has the correct columns\n        self.cursor.execute(\"PRAGMA table_info(books)\")\n        columns = self.cursor.fetchall()\n        column_names = [column[1] for column in columns]\n        expected_column_names = ['id', 'title', 'author', 'available']\n        self.assertEqual(column_names, expected_column_names)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "add_book",
        "method_description": "def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        \"\"\"",
        "test_class": "BookManagementDBTestAddBook",
        "test_code": "class BookManagementDBTestAddBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n\n    def test_add_book(self):\n        title = \"Introduction to Python\"\n        author = \"John Smith\"\n        self.db.add_book(title, author)\n\n        # Check if the book was added correctly\n        self.cursor.execute(\"SELECT title, author, available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], title)\n        self.assertEqual(result[1], author)\n        self.assertEqual(result[2], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def add_book(self, title, author):\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "remove_book",
        "method_description": "def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        \"\"\"",
        "test_class": "BookManagementDBTestRemoveBook",
        "test_code": "class BookManagementDBTestRemoveBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing removal\n        self.db.add_book(\"Book to Remove\", \"John Doe\")\n\n    def test_remove_book(self):\n        self.db.remove_book(1)\n\n        # Check if the book was removed correctly\n        self.cursor.execute(\"SELECT * FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertIsNone(result)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def remove_book(self, book_id):\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "borrow_book",
        "method_description": "def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        \"\"\"",
        "test_class": "BookManagementDBTestBorrowBook",
        "test_code": "class BookManagementDBTestBorrowBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing borrowing\n        self.db.add_book(\"Book to Borrow\", \"Jane Smith\")\n\n    def test_borrow_book(self):\n        self.db.borrow_book(1)\n\n        # Check if the book was marked as unavailable\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 0)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def borrow_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "return_book",
        "method_description": "def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        \"\"\"",
        "test_class": "BookManagementDBTestReturnBook",
        "test_code": "class BookManagementDBTestReturnBook(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add a book for testing returning\n        self.db.add_book(\"Book to Return\", \"James Smith\")\n        self.db.borrow_book(1)  # Mark the book as borrowed\n\n    def test_return_book(self):\n        self.db.return_book(1)\n\n        # Check if the book was marked as available again\n        self.cursor.execute(\"SELECT available FROM books WHERE id=1\")\n        result = self.cursor.fetchone()\n        self.assertEqual(result[0], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def return_book(self, book_id):\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_books",
        "method_description": "def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        \"\"\"",
        "test_class": "BookManagementDBTestSearchBooks",
        "test_code": "class BookManagementDBTestSearchBooks(unittest.TestCase):\n    def setUp(self):\n        self.db_name = \"test.db\"\n        self.db = BookManagementDB(self.db_name)\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        # Add some books for testing search\n        self.db.add_book(\"Book 1\", \"Author 1\")\n        self.db.add_book(\"Book 2\", \"Author 2\")\n        self.db.add_book(\"Book 3\", \"Author 3\")\n\n    def test_search_books(self):\n        books = self.db.search_books()\n\n        # Ensure that all books were retrieved\n        self.assertEqual(len(books), 3)\n\n        # Ensure that the correct book information is retrieved\n        self.assertEqual(books[0][1], \"Book 1\")\n        self.assertEqual(books[1][2], \"Author 2\")\n        self.assertEqual(books[2][3], 1)\n\n    def tearDown(self):\n        self.db.connection.close()\n        self.connection.close()\n        # remove the test database file\n        os.remove(self.db_name)",
        "solution_code": "def search_books(self):\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        books = self.cursor.fetchall()\n        return books",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.cursor"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            self.create_table()\n            print(f\"Database '{db_name}' connected successfully.\")\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            self.connection = None # Ensure connection is None on error\n            self.cursor = None\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        The table schema is:\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        author TEXT NOT NULL,\n        availability INTEGER DEFAULT 1 -- 1 for available, 0 for borrowed\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for test\n        >>> book_db.create_table()\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection is not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS books (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    title TEXT NOT NULL,\n                    author TEXT NOT NULL,\n                    availability INTEGER DEFAULT 1 -- 1 for available, 0 for borrowed\n                )\n            \"\"\")\n            self.connection.commit()\n            print(\"Table 'books' checked/created successfully.\")\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for test\n        >>> book_db.add_book('book1', 'author')\n        Book 'book1' added successfully.\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection is not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"\"\"\n                INSERT INTO books (title, author, availability)\n                VALUES (?, ?, ?)\n            \"\"\", (title, author, 1))\n            self.connection.commit()\n            print(f\"Book '{title}' added successfully.\")\n        except sqlite3.Error as e:\n            print(f\"Error adding book '{title}': {e}\")\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for test\n        >>> book_db.add_book('book_to_remove', 'author')\n        Book 'book_to_remove' added successfully.\n        >>> book_db.remove_book(1) # Assuming ID 1 was assigned\n        Book with ID 1 removed successfully.\n        >>> book_db.remove_book(999) # Test removing non-existent book\n        Book with ID 999 not found.\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection is not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                print(f\"Book with ID {book_id} removed successfully.\")\n            else:\n                print(f\"Book with ID {book_id} not found.\")\n        except sqlite3.Error as e:\n            print(f\"Error removing book with ID {book_id}: {e}\")\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for test\n        >>> book_db.add_book('book_to_borrow', 'author')\n        Book 'book_to_borrow' added successfully.\n        >>> book_db.borrow_book(1) # Assuming ID 1 was assigned\n        Book with ID 1 marked as borrowed.\n        >>> book_db.borrow_book(999) # Test borrowing non-existent book\n        Book with ID 999 not found or already borrowed.\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection is not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"\"\"\n                UPDATE books\n                SET availability = 0\n                WHERE id = ? AND availability = 1\n            \"\"\", (book_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                print(f\"Book with ID {book_id} marked as borrowed.\")\n            else:\n                print(f\"Book with ID {book_id} not found or already borrowed.\")\n        except sqlite3.Error as e:\n            print(f\"Error borrowing book with ID {book_id}: {e}\")\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for test\n        >>> book_db.add_book('book_to_return', 'author')\n        Book 'book_to_return' added successfully.\n        >>> book_db.borrow_book(1) # Need to borrow it first\n        Book with ID 1 marked as borrowed.\n        >>> book_db.return_book(1) # Assuming ID 1 was assigned and borrowed\n        Book with ID 1 marked as returned.\n        >>> book_db.return_book(999) # Test returning non-existent book\n        Book with ID 999 not found or already available.\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection is not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"\"\"\n                UPDATE books\n                SET availability = 1\n                WHERE id = ? AND availability = 0\n            \"\"\", (book_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                print(f\"Book with ID {book_id} marked as returned.\")\n            else:\n                print(f\"Book with ID {book_id} not found or already available.\")\n        except sqlite3.Error as e:\n            print(f\"Error returning book with ID {book_id}: {e}\")\n\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for test\n        >>> book_db.add_book('book1', 'author1')\n        Book 'book1' added successfully.\n        >>> book_db.add_book('book2', 'author2')\n        Book 'book2' added successfully.\n        >>> books = book_db.search_books()\n        >>> # The exact IDs might vary in real db, but for ':memory:' with simple adds, they are sequential\n        >>> # Let's check the content ignoring potential ID variations if run repeatedly without closing\n        >>> # For doctest simplicity, we will assume sequential IDs starting from 1 in a fresh :memory: db\n        >>> if books:\n        ...     print(books[0]) # Assuming the first book is ID 1\n        ...     print(books[1]) # Assuming the second book is ID 2\n        [(1, 'book1', 'author1', 1), (2, 'book2', 'author2', 1)] # Expected output for a fresh :memory:\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection is not established.\")\n            return []\n\n        try:\n            self.cursor.execute(\"SELECT id, title, author, availability FROM books\")\n            books = self.cursor.fetchall()\n            return books\n        except sqlite3.Error as e:\n            print(f\"Error searching books: {e}\")\n            return []\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            print(\"Database connection closed.\")\n            self.connection = None\n            self.cursor = None\n\n    def __del__(self):\n        \"\"\"\n        Ensure the connection is closed when the object is garbage collected.\n        \"\"\"\n        self.close()\n\n# Example Usage (optional, can be removed if only the class definition is needed)\nif __name__ == '__main__':\n    # Use a file-based database for persistent storage\n    db = BookManagementDB(\"books.db\")\n\n    # Add some books\n    db.add_book(\"The Hitchhiker's Guide to the Galaxy\", \"Douglas Adams\")\n    db.add_book(\"1984\", \"George Orwell\")\n    db.add_book(\"Pride and Prejudice\", \"Jane Austen\")\n\n    # Search all books\n    print(\"\\n--- All Books ---\")\n    all_books = db.search_books()\n    for book in all_books:\n        print(book)\n\n    # Assume we know the ID of \"1984\" from the search results (let's say it's ID 2)\n    # In a real application, you might search by title to get the ID\n    book_id_to_borrow = None\n    for book in all_books:\n        if book[1] == \"1984\":\n            book_id_to_borrow = book[0]\n            break\n\n    if book_id_to_borrow:\n        print(f\"\\n--- Borrowing Book ID {book_id_to_borrow} ---\")\n        db.borrow_book(book_id_to_borrow)\n\n        # Search again to see the updated availability\n        print(\"\\n--- Books after borrowing ---\")\n        all_books_after_borrow = db.search_books()\n        for book in all_books_after_borrow:\n            print(book)\n\n        # Return the book\n        print(f\"\\n--- Returning Book ID {book_id_to_borrow} ---\")\n        db.return_book(book_id_to_borrow)\n\n        # Search again\n        print(\"\\n--- Books after returning ---\")\n        all_books_after_return = db.search_books()\n        for book in all_books_after_return:\n            print(book)\n    else:\n        print(\"\\nCould not find '1984' to test borrowing/returning.\")\n\n    # Remove a book (e.g., \"Pride and Prejudice\", assume ID 3)\n    book_id_to_remove = None\n    for book in all_books_after_return: # Use the latest list\n         if book[1] == \"Pride and Prejudice\":\n             book_id_to_remove = book[0]\n             break\n\n    if book_id_to_remove:\n        print(f\"\\n--- Removing Book ID {book_id_to_remove} ---\")\n        db.remove_book(book_id_to_remove)\n\n        # Search again\n        print(\"\\n--- Books after removing ---\")\n        all_books_after_remove = db.search_books()\n        for book in all_books_after_remove:\n            print(book)\n    else:\n         print(\"\\nCould not find 'Pride and Prejudice' to test removing.\")\n\n\n    # Close the connection\n    db.close()\n\n    # Test connecting to a non-existent file or with permission issues (example)\n    # This might not work reliably on all systems depending on permissions\n    # try:\n    #     print(\"\\n--- Testing error handling ---\")\n    #     # Assuming 'non_writable_dir/test.db' is not writable\n    #     error_db = BookManagementDB(\"/non_existent_path/error.db\")\n    #     error_db.add_book(\"Test Error\", \"Error Author\")\n    #     error_db.close()\n    # except Exception as e:\n    #     print(f\"Caught expected error: {e}\")\n```",
      "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            self.create_table()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            self.connection = None\n            self.cursor = None\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        The table has columns: id (INTEGER PRIMARY KEY), title (TEXT), author (TEXT), available (INTEGER).\n        'available' is 1 for free (available to borrow) and 0 for borrowed.\n        >>> # Example Usage (assuming test.db)\n        >>> # import os\n        >>> # if os.path.exists(\"test.db\"): os.remove(\"test.db\")\n        >>> # book_db = BookManagementDB(\"test.db\")\n        >>> # book_db.create_table() # This is called in __init__\n        >>> # book_db.connection.close()\n        >>> pass # Placeholder for demonstration\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS books (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    title TEXT NOT NULL,\n                    author TEXT NOT NULL,\n                    available INTEGER DEFAULT 1 -- 1: available, 0: borrowed\n                )\n            \"\"\")\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> # Example Usage (assuming test.db exists and table is created)\n        >>> # book_db = BookManagementDB(\"test.db\")\n        >>> # book_db.add_book('book1', 'authorA')\n        >>> # book_db.add_book('book2', 'authorB')\n        >>> # books = book_db.search_books()\n        >>> # print(books)\n        >>> # book_db.connection.close()\n        >>> pass # Placeholder for demonstration\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"INSERT INTO books (title, author, available) VALUES (?, ?, ?)\", (title, author, 1))\n            self.connection.commit()\n            print(f\"Book '{title}' by {author} added.\")\n        except sqlite3.Error as e:\n            print(f\"Error adding book: {e}\")\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> # Example Usage (assuming test.db exists and has books)\n        >>> # book_db = BookManagementDB(\"test.db\")\n        >>> # book_db.remove_book(1) # Removes book with id 1\n        >>> # books = book_db.search_books()\n        >>> # print(books)\n        >>> # book_db.connection.close()\n        >>> pass # Placeholder for demonstration\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                print(f\"Book with ID {book_id} removed.\")\n            else:\n                print(f\"No book found with ID {book_id}.\")\n        except sqlite3.Error as e:\n            print(f\"Error removing book: {e}\")\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed (available = 0) in the database based on the given book ID.\n        Does nothing if the book is already borrowed or not found.\n        :param book_id: int\n        >>> # Example Usage (assuming test.db exists and has books)\n        >>> # book_db = BookManagementDB(\"test.db\")\n        >>> # book_db.borrow_book(2) # Borrow book with id 2\n        >>> # books = book_db.search_books()\n        >>> # print(books)\n        >>> # book_db.connection.close()\n        >>> pass # Placeholder for demonstration\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            # Optional: Check if book exists and is available before attempting update\n            self.cursor.execute(\"SELECT available FROM books WHERE id = ?\", (book_id,))\n            result = self.cursor.fetchone()\n\n            if result is None:\n                print(f\"No book found with ID {book_id}.\")\n                return\n            elif result[0] == 0:\n                 print(f\"Book with ID {book_id} is already borrowed.\")\n                 return\n\n            self.cursor.execute(\"UPDATE books SET available = 0 WHERE id = ?\", (book_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                 print(f\"Book with ID {book_id} marked as borrowed.\")\n\n        except sqlite3.Error as e:\n            print(f\"Error borrowing book: {e}\")\n\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned (available = 1) in the database based on the given book ID.\n        Does nothing if the book is already available or not found.\n        :param book_id: int\n        >>> # Example Usage (assuming test.db exists and has books)\n        >>> # book_db = BookManagementDB(\"test.db\")\n        >>> # book_db.return_book(2) # Return book with id 2\n        >>> # books = book_db.search_books()\n        >>> # print(books)\n        >>> # book_db.connection.close()\n        >>> pass # Placeholder for demonstration\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n             # Optional: Check if book exists and is borrowed before attempting update\n            self.cursor.execute(\"SELECT available FROM books WHERE id = ?\", (book_id,))\n            result = self.cursor.fetchone()\n\n            if result is None:\n                print(f\"No book found with ID {book_id}.\")\n                return\n            elif result[0] == 1:\n                 print(f\"Book with ID {book_id} is already available.\")\n                 return\n\n            self.cursor.execute(\"UPDATE books SET available = 1 WHERE id = ?\", (book_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                 print(f\"Book with ID {book_id} marked as returned.\")\n\n        except sqlite3.Error as e:\n            print(f\"Error returning book: {e}\")\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        The returned list contains tuples, where each tuple represents a book:\n        (id, title, author, available)\n        :return books: list[tuple], the information of all books in database\n        >>> # Example Usage (assuming test.db exists and has books)\n        >>> # book_db = BookManagementDB(\"test.db\")\n        >>> # books = book_db.search_books()\n        >>> # print(books)\n        >>> # book_db.connection.close()\n        >>> pass # Placeholder for demonstration\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return [] # Return empty list if connection failed\n\n        try:\n            self.cursor.execute(\"SELECT id, title, author, available FROM books\")\n            books = self.cursor.fetchall()\n            return books\n        except sqlite3.Error as e:\n            print(f\"Error searching books: {e}\")\n            return []\n\n    def close_connection(self):\n        \"\"\"\n        Closes the database connection.\n        It's good practice to call this when done with the database object.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n            print(\"Database connection closed.\")\n\n\n# Example of how to use the class:\nif __name__ == '__main__':\n    import os\n\n    # Clean up previous test database if it exists\n    db_file = \"library.db\"\n    if os.path.exists(db_file):\n        os.remove(db_file)\n        print(f\"Removed existing {db_file}\")\n\n    # Initialize the database\n    book_manager = BookManagementDB(db_file)\n\n    # Add some books\n    book_manager.add_book(\"The Hitchhiker's Guide to the Galaxy\", \"Douglas Adams\")\n    book_manager.add_book(\"Pride and Prejudice\", \"Jane Austen\")\n    book_manager.add_book(\"1984\", \"George Orwell\")\n\n    # Search and display all books\n    print(\"\\n--- All Books ---\")\n    all_books = book_manager.search_books()\n    for book in all_books:\n        availability = \"Available\" if book[3] == 1 else \"Borrowed\"\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Status: {availability}\")\n\n    # Borrow a book (let's assume ID 1 is 'The Hitchhiker\\'s Guide...')\n    print(\"\\n--- Borrowing Book ID 1 ---\")\n    book_manager.borrow_book(1)\n\n    # Try borrowing the same book again\n    print(\"\\n--- Trying to Borrow Book ID 1 again ---\")\n    book_manager.borrow_book(1)\n\n    # Borrow another book (let's assume ID 3 is '1984')\n    print(\"\\n--- Borrowing Book ID 3 ---\")\n    book_manager.borrow_book(3)\n\n    # Search again to see updated status\n    print(\"\\n--- All Books After Borrowing ---\")\n    all_books = book_manager.search_books()\n    for book in all_books:\n        availability = \"Available\" if book[3] == 1 else \"Borrowed\"\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Status: {availability}\")\n\n    # Return a book (ID 1)\n    print(\"\\n--- Returning Book ID 1 ---\")\n    book_manager.return_book(1)\n\n     # Try returning the same book again\n    print(\"\\n--- Trying to Return Book ID 1 again ---\")\n    book_manager.return_book(1)\n\n    # Search again to see updated status\n    print(\"\\n--- All Books After Returning ---\")\n    all_books = book_manager.search_books()\n    for book in all_books:\n        availability = \"Available\" if book[3] == 1 else \"Borrowed\"\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Status: {availability}\")\n\n    # Remove a book (ID 2 'Pride and Prejudice')\n    print(\"\\n--- Removing Book ID 2 ---\")\n    book_manager.remove_book(2)\n\n     # Try removing a non-existent book\n    print(\"\\n--- Trying to Remove Book ID 99 ---\")\n    book_manager.remove_book(99)\n\n\n    # Search final state\n    print(\"\\n--- Final Book List ---\")\n    all_books = book_manager.search_books()\n    if all_books:\n        for book in all_books:\n            availability = \"Available\" if book[3] == 1 else \"Borrowed\"\n            print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Status: {availability}\")\n    else:\n        print(\"No books left in the database.\")\n\n\n    # Close the connection\n    book_manager.close_connection()\n```",
      "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory db for doctest\n        >>> book_db.create_table()\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL DEFAULT 1\n            )\n        ''')\n        self.connection.commit()\n\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\":memory:\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('The Great Gatsby', 'F. Scott Fitzgerald')\n        >>> book_db.add_book('1984', 'George Orwell')\n        \"\"\"\n        self.cursor.execute('''\n            INSERT INTO books (title, author, availability)\n            VALUES (?, ?, ?)\n        ''', (title, author, 1)) # 1 means available\n        self.connection.commit()\n\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('Book to Remove', 'Author')\n        >>> books_before = book_db.search_books()\n        >>> len(books_before)\n        1\n        >>> book_id_to_remove = books_before[0][0]\n        >>> book_db.remove_book(book_id_to_remove)\n        >>> books_after = book_db.search_books()\n        >>> len(books_after)\n        0\n        \"\"\"\n        self.cursor.execute('DELETE FROM books WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('Book to Borrow', 'Author')\n        >>> book = book_db.search_books()[0]\n        >>> book[3] # Check initial availability (1)\n        1\n        >>> book_db.borrow_book(book[0])\n        >>> updated_book = book_db.search_books()\n        >>> updated_book[0][3] # Check updated availability (0)\n        0\n        \"\"\"\n        self.cursor.execute('UPDATE books SET availability = 0 WHERE id = ?', (book_id,)) # 0 means borrowed\n        self.connection.commit()\n\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('Book to Return', 'Author')\n        >>> book = book_db.search_books()[0]\n        >>> book_db.borrow_book(book[0]) # First borrow it\n        >>> borrowed_book = book_db.search_books()[0]\n        >>> borrowed_book[3] # Check if it's borrowed (0)\n        0\n        >>> book_db.return_book(book[0]) # Then return it\n        >>> returned_book = book_db.search_books()\n        >>> returned_book[0][3] # Check if it's returned (1)\n        1\n        \"\"\"\n        self.cursor.execute('UPDATE books SET availability = 1 WHERE id = ?', (book_id,)) # 1 means available\n        self.connection.commit()\n\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db = BookManagementDB(\":memory:\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('Book A', 'Author X')\n        >>> book_db.add_book('Book B', 'Author Y')\n        >>> books = book_db.search_books()\n        >>> len(books)\n        2\n        >>> books[0][1]\n        'Book A'\n        >>> books[1][1]\n        'Book B'\n        \"\"\"\n        self.cursor.execute('SELECT * FROM books')\n        books = self.cursor.fetchall()\n        return books\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n\n# Example Usage (optional, but good for testing outside doctests)\nif __name__ == '__main__':\n    # Clean up previous test db if it exists\n    import os\n    if os.path.exists(\"test.db\"):\n        os.remove(\"test.db\")\n\n    book_db = BookManagementDB(\"test.db\")\n\n    # Add books\n    print(\"Adding books...\")\n    book_db.add_book(\"The Lord of the Rings\", \"J.R.R. Tolkien\")\n    book_db.add_book(\"Pride and Prejudice\", \"Jane Austen\")\n    book_db.add_book(\"To Kill a Mockingbird\", \"Harper Lee\")\n    print(\"Books added.\")\n\n    # Search books\n    print(\"\\nAll books:\")\n    all_books = book_db.search_books()\n    for book in all_books:\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {'Yes' if book[3] == 1 else 'No'}\")\n\n    # Borrow a book (let's borrow the first one, ID 1)\n    if all_books:\n        book_id_to_borrow = all_books[0][0]\n        print(f\"\\nBorrowing book with ID {book_id_to_borrow}...\")\n        book_db.borrow_book(book_id_to_borrow)\n        print(\"Book borrowed.\")\n\n        # Search again to see status change\n        print(\"\\nAll books after borrowing:\")\n        all_books = book_db.search_books()\n        for book in all_books:\n             print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {'Yes' if book[3] == 1 else 'No'}\")\n\n        # Return the book\n        print(f\"\\nReturning book with ID {book_id_to_borrow}...\")\n        book_db.return_book(book_id_to_borrow)\n        print(\"Book returned.\")\n\n        # Search again to see status change\n        print(\"\\nAll books after returning:\")\n        all_books = book_db.search_books()\n        for book in all_books:\n             print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {'Yes' if book[3] == 1 else 'No'}\")\n\n    # Remove a book (let's remove the second one added)\n    if len(all_books) >= 2:\n        book_id_to_remove = all_books[1][0]\n        print(f\"\\nRemoving book with ID {book_id_to_remove}...\")\n        book_db.remove_book(book_id_to_remove)\n        print(\"Book removed.\")\n\n        # Search again\n        print(\"\\nAll books after removal:\")\n        all_books = book_db.search_books()\n        for book in all_books:\n             print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {'Yes' if book[3] == 1 else 'No'}\")\n    else:\n        print(\"\\nNot enough books to demonstrate removal.\")\n\n\n    # Close connection\n    book_db.close()\n    print(\"\\nDatabase connection closed.\")\n\n    # Clean up the test db file\n    # os.remove(\"test.db\") # Uncomment this if you want to remove the file after running\n```",
      "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = None\n        self.cursor = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            self.create_table()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            if self.connection:\n                self.connection.close()\n            self.connection = None\n            self.cursor = None\n\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        The table will have columns: id (INTEGER PRIMARY KEY AUTOINCREMENT), \n        title (TEXT NOT NULL), author (TEXT NOT NULL), available (INTEGER NOT NULL, default 1).\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory database for doctest\n        >>> book_db.create_table()\n        >>> # Clean up for doctest\n        >>> book_db.close()\n        \"\"\"\n        if self.connection:\n            try:\n                self.cursor.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS books (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        title TEXT NOT NULL,\n                        author TEXT NOT NULL,\n                        available INTEGER NOT NULL DEFAULT 1 -- 1 for available, 0 for borrowed\n                    )\n                \"\"\")\n                self.connection.commit()\n            except sqlite3.Error as e:\n                print(f\"Error creating table: {e}\")\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory database for doctest\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'authorA')\n        >>> book_db.add_book('book2', 'authorB')\n        >>> # Clean up for doctest\n        >>> book_db.close()\n        \"\"\"\n        if self.connection:\n            try:\n                self.cursor.execute(\"INSERT INTO books (title, author, available) VALUES (?, ?, ?)\", (title, author, 1))\n                self.connection.commit()\n                # print(f\"Book '{title}' by {author} added successfully.\")\n            except sqlite3.Error as e:\n                print(f\"Error adding book: {e}\")\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory database for doctest\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'authorA')\n        >>> book_db.add_book('book2', 'authorB')\n        >>> book_db.remove_book(1)\n        >>> books = book_db.search_books()\n        >>> print(len(books))\n        1\n        >>> # Clean up for doctest\n        >>> book_db.close()\n        \"\"\"\n        if self.connection:\n            try:\n                self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n                if self.cursor.rowcount > 0:\n                    self.connection.commit()\n                    # print(f\"Book with ID {book_id} removed successfully.\")\n                # else:\n                    # print(f\"No book found with ID {book_id}.\")\n            except sqlite3.Error as e:\n                print(f\"Error removing book: {e}\")\n\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed (available = 0) in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory database for doctest\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'authorA')\n        >>> book_db.borrow_book(1)\n        >>> book = book_db.search_books()[0] # Assuming book with id 1 is the first one\n        >>> print(book[3]) # Index 3 is the 'available' column\n        0\n        >>> # Clean up for doctest\n        >>> book_db.close()\n        \"\"\"\n        if self.connection:\n            try:\n                self.cursor.execute(\"UPDATE books SET available = 0 WHERE id = ?\", (book_id,))\n                if self.cursor.rowcount > 0:\n                    self.connection.commit()\n                    # print(f\"Book with ID {book_id} marked as borrowed.\")\n                # else:\n                    # print(f\"No book found with ID {book_id}.\")\n            except sqlite3.Error as e:\n                print(f\"Error borrowing book: {e}\")\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned (available = 1) in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory database for doctest\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'authorA')\n        >>> book_db.borrow_book(1) # First borrow it\n        >>> book_db.return_book(1) # Then return it\n        >>> book = book_db.search_books()[0] # Assuming book with id 1 is the first one\n        >>> print(book[3]) # Index 3 is the 'available' column\n        1\n        >>> # Clean up for doctest\n        >>> book_db.close()\n        \"\"\"\n        if self.connection:\n            try:\n                self.cursor.execute(\"UPDATE books SET available = 1 WHERE id = ?\", (book_id,))\n                if self.cursor.rowcount > 0:\n                    self.connection.commit()\n                    # print(f\"Book with ID {book_id} marked as returned.\")\n                # else:\n                    # print(f\"No book found with ID {book_id}.\")\n            except sqlite3.Error as e:\n                print(f\"Error returning book: {e}\")\n\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information as a list of tuples.\n        Each tuple contains (id, title, author, available).\n        :return books: list[tuple], the information of all books in database\n        >>> book_db = BookManagementDB(\":memory:\") # Use in-memory database for doctest\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'authorA')\n        >>> book_db.add_book('book2', 'authorB')\n        >>> books = book_db.search_books()\n        >>> # Sort for consistent output in doctest\n        >>> books.sort(key=lambda x: x[0]) \n        >>> print(books)\n        [(1, 'book1', 'authorA', 1), (2, 'book2', 'authorB', 1)]\n        >>> # Clean up for doctest\n        >>> book_db.close()\n        \"\"\"\n        if self.connection:\n            try:\n                self.cursor.execute(\"SELECT id, title, author, available FROM books\")\n                books = self.cursor.fetchall()\n                return books\n            except sqlite3.Error as e:\n                print(f\"Error searching books: {e}\")\n                return []\n        return [] # Return empty list if connection is not established\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        >>> book_db = BookManagementDB(\":memory:\")\n        >>> book_db.close()\n        >>> print(book_db.connection is None)\n        True\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n            # print(\"Database connection closed.\")\n\n# Example Usage (optional, can be uncommented to test manually)\n# if __name__ == \"__main__\":\n#     db = BookManagementDB(\"library.db\")\n#\n#     # Add books\n#     db.add_book(\"The Hitchhiker's Guide to the Galaxy\", \"Douglas Adams\")\n#     db.add_book(\"Pride and Prejudice\", \"Jane Austen\")\n#     db.add_book(\"1984\", \"George Orwell\")\n#\n#     print(\"\\nAll books:\")\n#     all_books = db.search_books()\n#     for book in all_books:\n#         print(book)\n#\n#     # Borrow a book\n#     print(\"\\nBorrowing book with ID 1:\")\n#     db.borrow_book(1)\n#\n#     print(\"\\nBooks after borrowing:\")\n#     all_books = db.search_books()\n#     for book in all_books:\n#         print(book)\n#\n#     # Return a book\n#     print(\"\\nReturning book with ID 1:\")\n#     db.return_book(1)\n#\n#     print(\"\\nBooks after returning:\")\n#     all_books = db.search_books()\n#     for book in all_books:\n#         print(book)\n#\n#     # Remove a book\n#     print(\"\\nRemoving book with ID 3:\")\n#     db.remove_book(3)\n#\n#     print(\"\\nBooks after removing:\")\n#     all_books = db.search_books()\n#     for book in all_books:\n#         print(book)\n#\n#     # Remove non-existent book\n#     print(\"\\nAttempting to remove book with ID 99:\")\n#     db.remove_book(99)\n#\n#     db.close()\n```",
      "```python\nimport sqlite3\nimport os # Import os for doctest cleanup\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        # Ensure the database file exists before connecting if needed, or just connect\n        # sqlite3.connect will create the file if it doesn't exist\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        >>> import os\n        >>> db_file = \"test_create_table.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up before test\n        >>> book_db = BookManagementDB(db_file)\n        >>> book_db.create_table()\n        >>> book_db.close()\n        >>> os.path.exists(db_file) # Verify file creation\n        True\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL DEFAULT 1 -- 1 for available, 0 for borrowed\n            )\n        ''')\n        self.connection.commit() # Commit the table creation\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> import os\n        >>> db_file = \"test_add_book.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up before test\n        >>> book_db = BookManagementDB(db_file)\n        >>> book_db.add_book('book1', 'author')\n        >>> books = book_db.search_books()\n        >>> book_db.close()\n        >>> len(books)\n        1\n        >>> books[0][1:4] # Check title, author, availability\n        ('book1', 'author', 1)\n        \"\"\"\n        self.cursor.execute('''\n            INSERT INTO books (title, author, availability)\n            VALUES (?, ?, ?)\n        ''', (title, author, 1))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> import os\n        >>> db_file = \"test_remove_book.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up before test\n        >>> book_db = BookManagementDB(db_file)\n        >>> book_db.add_book('book_to_remove', 'author')\n        >>> books_before = book_db.search_books()\n        >>> len(books_before)\n        1\n        >>> book_id_to_remove = books_before[0][0] # Get the ID\n        >>> book_db.remove_book(book_id_to_remove)\n        >>> books_after = book_db.search_books()\n        >>> book_db.close()\n        >>> len(books_after)\n        0\n        \"\"\"\n        self.cursor.execute('DELETE FROM books WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> import os\n        >>> db_file = \"test_borrow_book.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up before test\n        >>> book_db = BookManagementDB(db_file)\n        >>> book_db.add_book('book_to_borrow', 'author')\n        >>> book_id_to_borrow = book_db.search_books()[0][0] # Get the ID\n        >>> book_db.borrow_book(book_id_to_borrow)\n        >>> books = book_db.search_books()\n        >>> book_db.close()\n        >>> books[0][3] # Check availability (0 for borrowed)\n        0\n        \"\"\"\n        self.cursor.execute('UPDATE books SET availability = 0 WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> import os\n        >>> db_file = \"test_return_book.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up before test\n        >>> book_db = BookManagementDB(db_file)\n        >>> book_db.add_book('book_to_return', 'author')\n        >>> book_id_to_return = book_db.search_books()[0][0] # Get the ID\n        >>> book_db.borrow_book(book_id_to_return) # Borrow it first\n        >>> book_db.search_books()[0][3]\n        0\n        >>> book_db.return_book(book_id_to_return) # Then return it\n        >>> books = book_db.search_books()\n        >>> book_db.close()\n        >>> books[0][3] # Check availability (1 for available)\n        1\n        \"\"\"\n        self.cursor.execute('UPDATE books SET availability = 1 WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> import os\n        >>> db_file = \"test_search_books.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up before test\n        >>> book_db = BookManagementDB(db_file)\n        >>> book_db.add_book('book1', 'author1')\n        >>> book_db.add_book('book2', 'author2')\n        >>> books = book_db.search_books()\n        >>> book_db.close()\n        >>> len(books)\n        2\n        # Check contents without relying on exact order or ID (assuming default 1,2 IDs for a fresh db)\n        >>> books # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n        [(1, 'book1', 'author1', 1), (2, 'book2', 'author2', 1)]\n        \"\"\"\n        self.cursor.execute('SELECT id, title, author, availability FROM books')\n        books = self.cursor.fetchall()\n        return books\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None # Set to None after closing\n            self.cursor = None     # Set to None after closing\n\n    def __del__(self):\n        \"\"\"\n        Ensures the connection is closed when the object is garbage collected.\n        This is a fallback; explicit close() is recommended.\n        \"\"\"\n        self.close()\n\n\nif __name__ == '__main__':\n    # Example Usage:\n    # Clean up any previous test databases\n    for db_file in [\"test_create_table.db\", \"test_add_book.db\", \"test_remove_book.db\",\n                    \"test_borrow_book.db\", \"test_return_book.db\", \"test_search_books.db\", \"my_library.db\"]:\n         if os.path.exists(db_file):\n             os.remove(db_file)\n\n    print(\"--- Running Doctests ---\")\n    import doctest\n    doctest.testmod(verbose=True)\n    print(\"--- Doctests Finished ---\")\n\n    print(\"\\n--- Example Library Usage ---\")\n    # Create a new database\n    library_db = BookManagementDB(\"my_library.db\")\n\n    # Add books\n    library_db.add_book(\"The Hitchhiker's Guide to the Galaxy\", \"Douglas Adams\")\n    library_db.add_book(\"1984\", \"George Orwell\")\n    library_db.add_book(\"To Kill a Mockingbird\", \"Harper Lee\")\n\n    print(\"\\nAll books:\")\n    all_books = library_db.search_books()\n    for book in all_books:\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {bool(book[3])}\")\n\n    # Borrow a book (e.g., 1984 - assuming ID is 2)\n    book_id_to_borrow = 2\n    print(f\"\\nBorrowing book with ID {book_id_to_borrow}...\")\n    library_db.borrow_book(book_id_to_borrow)\n\n    print(\"\\nAll books after borrowing:\")\n    all_books = library_db.search_books()\n    for book in all_books:\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {bool(book[3])}\")\n\n    # Return the book (e.g., 1984 - ID 2)\n    book_id_to_return = 2\n    print(f\"\\nReturning book with ID {book_id_to_return}...\")\n    library_db.return_book(book_id_to_return)\n\n    print(\"\\nAll books after returning:\")\n    all_books = library_db.search_books()\n    for book in all_books:\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {bool(book[3])}\")\n\n    # Remove a book (e.g., The Hitchhiker's Guide - ID 1)\n    book_id_to_remove = 1\n    print(f\"\\nRemoving book with ID {book_id_to_remove}...\")\n    library_db.remove_book(book_id_to_remove)\n\n    print(\"\\nAll books after removal:\")\n    all_books = library_db.search_books()\n    for book in all_books:\n        print(f\"ID: {book[0]}, Title: {book[1]}, Author: {book[2]}, Available: {bool(book[3])}\")\n\n    # Close the connection\n    library_db.close()\n    print(\"\\nDatabase connection closed.\")\n\n    # Clean up the example database\n    if os.path.exists(\"my_library.db\"):\n        os.remove(\"my_library.db\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_28",
    "skeleton": "import sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"",
    "test": "import unittest\nimport sqlite3\n\n\nclass DatabaseProcessorTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_create_table_1(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_2(self):\n        table_name = \"test_table2\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_3(self):\n        table_name = \"test_table3\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_4(self):\n        table_name = \"test_table4\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_5(self):\n        table_name = \"test_table5\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n\nclass DatabaseProcessorTestInsertIntoDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_into_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n    def test_insert_into_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 15},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 15)\n\n    def test_insert_into_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 16},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 16)\n\n    def test_insert_into_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 17},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 17)\n\n    def test_insert_into_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 18},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 18)\n\n\nclass DatabaseProcessorTestSearchDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_search_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_search_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Alice')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_search_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Bob')\n        self.assertIsNone(result)\n\n    def test_search_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'aaa')\n        self.assertIsNone(result)\n\n    def test_search_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'bbb')\n        self.assertIsNone(result)\n\n\nclass DatabaseProcessorTestDeteleFromDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_from_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_delete_from_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_delete_from_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_from_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'aaa', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_delete_from_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'bbb', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'bbb')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n\nclass DatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_DatabaseProcessor(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')",
    "solution_code": "import sqlite3\nimport pandas as pd\n\n\nclass DatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        if result:\n            return result\n        else:\n            return None\n\n    def delete_from_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
    "import_statement": [
      "import sqlite3",
      "import pandas as pd"
    ],
    "class_description": "    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n",
    "class_name": "DatabaseProcessor",
    "test_classes": [
      "DatabaseProcessorTestCreateTable",
      "DatabaseProcessorTestInsertIntoDatabase",
      "DatabaseProcessorTestSearchDatabase",
      "DatabaseProcessorTestDeteleFromDatabase",
      "DatabaseProcessorTest"
    ],
    "class_constructor": "class DatabaseProcessor: \n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n",
    "fields": [
      "self.database_name"
    ],
    "methods_info": [
      {
        "method_name": "create_table",
        "method_description": "def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"",
        "test_class": "DatabaseProcessorTestCreateTable",
        "test_code": "class DatabaseProcessorTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_create_table_1(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_2(self):\n        table_name = \"test_table2\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_3(self):\n        table_name = \"test_table3\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_4(self):\n        table_name = \"test_table4\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_5(self):\n        table_name = \"test_table5\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)",
        "solution_code": "def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert_into_database",
        "method_description": "def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"",
        "test_class": "DatabaseProcessorTestInsertIntoDatabase",
        "test_code": "class DatabaseProcessorTestInsertIntoDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_into_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n    def test_insert_into_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 15},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 15)\n\n    def test_insert_into_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 16},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 16)\n\n    def test_insert_into_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 17},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 17)\n\n    def test_insert_into_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 18},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 18)",
        "solution_code": "def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_database",
        "method_description": "def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"",
        "test_class": "DatabaseProcessorTestSearchDatabase",
        "test_code": "class DatabaseProcessorTestSearchDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_search_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_search_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Alice')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_search_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Bob')\n        self.assertIsNone(result)\n\n    def test_search_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'aaa')\n        self.assertIsNone(result)\n\n    def test_search_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'bbb')\n        self.assertIsNone(result)",
        "solution_code": "def search_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        if result:\n            return result\n        else:\n            return None",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_from_database",
        "method_description": "def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"",
        "test_class": "DatabaseProcessorTestDeteleFromDatabase",
        "test_code": "class DatabaseProcessorTestDeteleFromDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_from_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_delete_from_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_delete_from_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_from_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'aaa', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_delete_from_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'bbb', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'bbb')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')",
        "solution_code": "def delete_from_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def _execute_query(self, query, params=(), commit=False, fetchone=False, fetchall=False):\n        \"\"\"Helper method to handle connecting, executing, and closing.\"\"\"\n        conn = None\n        cursor = None\n        result = None\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            if commit:\n                conn.commit()\n            if fetchone:\n                result = cursor.fetchone()\n            if fetchall:\n                result = cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            if conn and commit:\n                 conn.rollback()\n            result = None # Ensure None is returned on error for fetch calls\n        finally:\n            if cursor:\n                cursor.close()\n            if conn:\n                conn.close()\n        return result\n\n    def _get_column_names(self, table_name):\n        \"\"\"Helper to get column names from a table schema, excluding the primary key 'id'.\"\"\"\n        # PRAGMA table_info(tablename) returns rows like:\n        # (cid, name, type, notnull, dflt_value, pk)\n        query = f\"PRAGMA table_info({table_name})\"\n        rows = self._execute_query(query, fetchall=True)\n        if rows:\n            # Exclude the primary key column (where pk is 1)\n            # Return just the names of the other columns in their defined order\n            return [row[1] for row in rows if row[5] == 0] # row[1] is name, row[5] is pk (0 for not PK, 1 for PK)\n        return None # Table might not exist or have no columns\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table (TEXT).\n        :param key2: str, the name of the second column in the table (INTEGER).\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n        # Note: Using f-strings for table/column names is generally safe only if the names\n        # are controlled internally and not derived from arbitrary user input, to prevent SQL injection.\n        # For this task, we assume key1 and key2 are safe identifiers.\n        query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        self._execute_query(query, commit=True)\n        print(f\"Table '{table_name}' created or already exists.\")\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        Assumes the dictionary keys in data correspond to the column names (excluding 'id')\n        defined during table creation (key1 and key2).\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n        if not data:\n            print(\"No data provided for insertion.\")\n            return\n\n        # Get the column names from the table schema (excluding 'id')\n        # This determines the expected keys in the input dictionaries\n        column_names = self._get_column_names(table_name)\n        if not column_names:\n            print(f\"Error: Table '{table_name}' not found or structure is unexpected for insertion.\")\n            return\n\n        # Prepare the data for executemany. Values must be in the order of column_names.\n        values_to_insert = []\n        for row_dict in data:\n            try:\n                # Extract values from the dictionary based on the discovered column names\n                row_values = tuple(row_dict[col_name] for col_name in column_names)\n                values_to_insert.append(row_values)\n            except KeyError as e:\n                print(f\"Skipping row due to missing key: '{e}' in dictionary {row_dict}. Expected keys: {column_names}\")\n                continue # Skip this row and process the next\n            except Exception as e:\n                 print(f\"Skipping row due to unexpected error: {e} with dictionary {row_dict}\")\n                 continue\n\n        if not values_to_insert:\n             print(\"No valid data rows to insert after processing input.\")\n             return\n\n        placeholders = ', '.join(['?'] * len(column_names))\n        cols = ', '.join(column_names)\n        query = f\"INSERT INTO {table_name} ({cols}) VALUES ({placeholders})\"\n\n        conn = None\n        cursor = None\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.executemany(query, values_to_insert)\n            conn.commit()\n            print(f\"Successfully inserted {len(values_to_insert)} rows into '{table_name}'.\")\n        except sqlite3.Error as e:\n            print(f\"Database error during insertion: {e}\")\n            if conn:\n                conn.rollback()\n        finally:\n            if cursor:\n                cursor.close()\n            if conn:\n                conn.close()\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        Assumes the 'name' search criterion applies to the first column defined\n        after the primary key (i.e., corresponds to key1 from create_table).\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n        # Get the column names from the table schema (excluding 'id')\n        column_names = self._get_column_names(table_name)\n        if not column_names:\n            print(f\"Error: Table '{table_name}' not found or structure is unexpected for search.\")\n            return None # Adhere to docstring returning None\n\n        # The 'name' search is assumed to be on the first column defined after the PK\n        # which corresponds to key1 from create_table. This is column_names[0].\n        if not column_names: # Double check in case _get_column_names returned empty list for some reason\n            print(f\"Error: No searchable columns found in table '{table_name}'.\")\n            return None\n\n        search_column_name = column_names[0] # Assuming key1 is the search column\n\n        query = f\"SELECT * FROM {table_name} WHERE {search_column_name} = ?\"\n        result = self._execute_query(query, (name,), fetchall=True)\n\n        # _execute_query returns None on database error.\n        # fetchall() returns an empty list if no rows match.\n        if result is not None and len(result) > 0:\n            return result\n        else:\n            # Adhere to docstring requirement to return None if no results or error\n            if result is not None: # It was an empty list, not an error\n                 print(f\"No rows found in '{table_name}' with {search_column_name} = '{name}'.\")\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        Assumes the 'name' deletion criterion applies to the first column defined\n        after the primary key (i.e., corresponds to key1 from create_table).\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n        # Get the column names from the table schema (excluding 'id')\n        column_names = self._get_column_names(table_name)\n        if not column_names:\n            print(f\"Error: Table '{table_name}' not found or structure is unexpected for deletion.\")\n            return\n\n        # The 'name' deletion is assumed to be on the first column defined after the PK\n        # which corresponds to key1 from create_table. This is column_names[0].\n        if not column_names: # Double check in case _get_column_names returned empty list\n            print(f\"Error: No deletable columns found in table '{table_name}'.\")\n            return\n\n        delete_column_name = column_names[0] # Assuming key1 is the deletion criterion\n\n        query = f\"DELETE FROM {table_name} WHERE {delete_column_name} = ?\"\n        # Use _execute_query with commit=True\n        # _execute_query returns None on error, but we don't need the result here.\n        success = self._execute_query(query, (name,), commit=True)\n\n        if success is not None: # _execute_query returns None on database error\n             print(f\"Executed delete command for rows in '{table_name}' with {delete_column_name} = '{name}'.\")\n             # Note: Getting the exact number of deleted rows requires inspecting cursor.rowcount\n             # after execute, which is not directly exposed by the current helper structure.\n             # The current print confirms the command was sent and committed without DB error.\n\n\n# Example Usage (optional, uncomment to run)\nif __name__ == '__main__':\n    db_name = 'my_database.db'\n    db = DatabaseProcessor(db_name)\n\n    # Clean up previous runs\n    import os\n    if os.path.exists(db_name):\n        os.remove(db_name)\n        print(f\"Removed existing database '{db_name}'.\")\n\n    # 1. Create table\n    db.create_table('users', 'username', 'score')\n    db.create_table('products', 'product_name', 'price')\n    db.create_table('empty_table', 'colA', 'colB')\n\n\n    # 2. Insert data\n    user_data = [\n        {'username': 'Alice', 'score': 100},\n        {'username': 'Bob', 'score': 75},\n        {'username': 'Charlie', 'score': 120},\n        {'username': 'Alice', 'score': 90}, # Another Alice\n        {'username': 'David', 'score': 'invalid'}, # Example of invalid data type\n        {'username': 'Eve'}, # Example of missing key\n        {'username_typo': 'Frank', 'score': 50} # Example of wrong key\n    ]\n    db.insert_into_database('users', user_data)\n\n    product_data = [\n        {'product_name': 'Laptop', 'price': 1200},\n        {'product_name': 'Keyboard', 'price': 75},\n    ]\n    db.insert_into_database('products', product_data)\n\n    db.insert_into_database('non_existent_table', [{'a':1, 'b':2}]) # Example of inserting into non-existent table\n\n    # 3. Search data\n    print(\"\\n--- Searching Data ---\")\n    print(\"Searching for 'Alice' in 'users':\")\n    alice_rows = db.search_database('users', 'Alice')\n    if alice_rows:\n        for row in alice_rows:\n            print(row)\n    else:\n        print(\"No users found named Alice.\")\n\n    print(\"\\nSearching for 'David' in 'users':\")\n    david_rows = db.search_database('users', 'David')\n    if david_rows:\n         for row in david_rows:\n            print(row)\n    else:\n        print(\"No users found named David.\") # Should print this\n\n    print(\"\\nSearching for 'Laptop' in 'products':\")\n    laptop_rows = db.search_database('products', 'Laptop')\n    if laptop_rows:\n        for row in laptop_rows:\n            print(row)\n    else:\n        print(\"No products found named Laptop.\")\n\n    print(\"\\nSearching in 'empty_table':\")\n    empty_search = db.search_database('empty_table', 'something')\n    if empty_search:\n         for row in empty_search:\n            print(row)\n    else:\n        print(\"No results from empty_table search (correctly returned None).\") # Should print this\n\n    print(\"\\nSearching in 'non_existent_table':\")\n    non_existent_search = db.search_database('non_existent_table', 'test') # Should print error\n    if non_existent_search:\n         for row in non_existent_search:\n            print(row)\n    else:\n        print(\"Search in non_existent_table returned None (correct).\") # Should print this\n\n\n    # 4. Delete data\n    print(\"\\n--- Deleting Data ---\")\n    print(\"Deleting 'Bob' from 'users':\")\n    db.delete_from_database('users', 'Bob')\n\n    print(\"\\nSearching for 'Bob' in 'users' after deletion:\")\n    bob_rows_after_delete = db.search_database('users', 'Bob')\n    if bob_rows_after_delete:\n        for row in bob_rows_after_delete:\n            print(row)\n    else:\n        print(\"No users found named Bob after deletion.\") # Should print this\n\n    print(\"\\nDeleting 'Alice' from 'users':\")\n    db.delete_from_database('users', 'Alice') # Deletes both remaining Alices\n\n    print(\"\\nSearching for 'Alice' in 'users' after deletion:\")\n    alice_rows_after_delete = db.search_database('users', 'Alice')\n    if alice_rows_after_delete:\n        for row in alice_rows_after_delete:\n            print(row)\n    else:\n        print(\"No users found named Alice after deletion.\") # Should print this\n\n    print(\"\\nDeleting from 'non_existent_table':\")\n    db.delete_from_database('non_existent_table', 'test') # Should print error\n```",
      "```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table (TEXT).\n        :param key2: str, the name of the second column in the table (INTEGER).\n        >>> db = DatabaseProcessor('mydatabase.db')\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                # Use AUTOINCREMENT to ensure unique IDs\n                cursor.execute(f'''\n                    CREATE TABLE IF NOT EXISTS {table_name} (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        {key1} TEXT,\n                        {key2} INTEGER\n                    )\n                ''')\n                conn.commit()\n                print(f\"Table '{table_name}' created or already exists.\")\n        except sqlite3.Error as e:\n            print(f\"Error creating table {table_name}: {e}\")\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        Assumes data is a list of dictionaries where keys match column names (excluding 'id').\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n                        E.g., [{'name': 'John', 'age': 25}, {'name': 'Alice', 'age': 30}]\n        >>> db = DatabaseProcessor('mydatabase.db')\n        >>> db.create_table('user', 'name', 'age') # Assume table is created\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n        if not data:\n            print(\"No data provided for insertion.\")\n            return\n\n        try:\n            # Get column names from the first dictionary (excluding 'id')\n            # Ensure keys in data match the expected columns (key1, key2)\n            # This assumes all dicts in data have the same keys corresponding to columns.\n            # We need to know the column names used when creating the table (key1, key2)\n            # A more robust approach would be to store key1 and key2 in the class\n            # or retrieve schema, but based on the examples, we assume the dict keys\n            # correspond to the non-id columns. Let's assume the dictionary keys ARE key1 and key2.\n\n            # We'll need to dynamically get the column names other than 'id'\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                # Retrieve column names from the schema (excluding 'id')\n                cursor.execute(f\"PRAGMA table_info({table_name});\")\n                columns_info = cursor.fetchall()\n                # Filter out the 'id' column and get column names\n                column_names = [info[1] for info in columns_info if info[1] != 'id']\n\n                if not column_names:\n                    print(f\"Error: Could not retrieve column names for table '{table_name}'.\")\n                    return\n\n                # Prepare the list of tuples for executemany\n                # Extract values from each dictionary in the order of column_names\n                values_to_insert = []\n                for row_dict in data:\n                    try:\n                        # Ensure dictionary keys match column names before extracting values\n                        row_values = [row_dict[col_name] for col_name in column_names]\n                        values_to_insert.append(row_values)\n                    except KeyError as e:\n                        print(f\"Error: Data dictionary missing expected column '{e}'. Data: {row_dict}\")\n                        return # Or skip the row and continue\n\n                if not values_to_insert:\n                     print(\"No valid data rows to insert.\")\n                     return\n\n                # Create the SQL query string\n                placeholders = ', '.join(['?' for _ in column_names])\n                columns_sql = ', '.join(column_names)\n                sql = f\"INSERT INTO {table_name} ({columns_sql}) VALUES ({placeholders})\"\n\n                cursor.executemany(sql, values_to_insert)\n                conn.commit()\n                print(f\"Successfully inserted {len(values_to_insert)} rows into '{table_name}'.\")\n\n        except sqlite3.Error as e:\n            print(f\"Error inserting data into table {table_name}: {e}\")\n        except Exception as e:\n             print(f\"An unexpected error occurred during insertion: {e}\")\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        Assumes the column corresponding to 'name' is the second column (index 1) after 'id'.\n        This assumes key1 is always the 'name' column used for searching.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None if no results are found.\n        >>> db = DatabaseProcessor('mydatabase.db')\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n\n                # Find the column name for searching ('name' equivalent, which is key1)\n                # This requires knowing which column is key1. Let's assume the search is always on the *first* TEXT column after 'id'.\n                # A better design would store key1 and key2 in the class upon table creation\n                # or pass the column name to search on. Based on the docstring ('name'),\n                # we assume we search on the column defined by 'key1'.\n\n                # Retrieve column names from the schema\n                cursor.execute(f\"PRAGMA table_info({table_name});\")\n                columns_info = cursor.fetchall()\n                # Find the column name that is TEXT and not 'id'. Assume the first one found is key1.\n                search_column = None\n                for info in columns_info:\n                    col_name, col_type = info[1], info[2]\n                    if col_name != 'id' and col_type.upper() == 'TEXT':\n                        search_column = col_name\n                        break # Assume the first TEXT column after id is the one to search\n\n                if not search_column:\n                     print(f\"Error: Could not find a TEXT column to search in table '{table_name}'.\")\n                     return None\n\n\n                sql = f\"SELECT * FROM {table_name} WHERE {search_column} = ?\"\n                cursor.execute(sql, (name,))\n                results = cursor.fetchall()\n\n                if results:\n                    print(f\"Found {len(results)} rows matching name '{name}'.\")\n                    return results\n                else:\n                    print(f\"No rows found matching name '{name}'.\")\n                    return None\n\n        except sqlite3.Error as e:\n            print(f\"Error searching table {table_name}: {e}\")\n            return None\n        except Exception as e:\n             print(f\"An unexpected error occurred during search: {e}\")\n             return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        Assumes the column corresponding to 'name' is the second column (index 1) after 'id'.\n        This assumes key1 is always the 'name' column used for deletion.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db = DatabaseProcessor('mydatabase.db')\n        >>> # Assume table exists and data is inserted\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n\n                 # Find the column name for deletion ('name' equivalent, which is key1)\n                # Assume we delete based on the first TEXT column after 'id', similar to search.\n                cursor.execute(f\"PRAGMA table_info({table_name});\")\n                columns_info = cursor.fetchall()\n                delete_column = None\n                for info in columns_info:\n                    col_name, col_type = info[1], info[2]\n                    if col_name != 'id' and col_type.upper() == 'TEXT':\n                        delete_column = col_name\n                        break # Assume the first TEXT column after id is the one to delete by\n\n                if not delete_column:\n                     print(f\"Error: Could not find a TEXT column to delete by in table '{table_name}'.\")\n                     return\n\n                sql = f\"DELETE FROM {table_name} WHERE {delete_column} = ?\"\n                cursor.execute(sql, (name,))\n                conn.commit()\n                print(f\"Deleted rows matching name '{name}' from '{table_name}'. Rows affected: {cursor.rowcount}\")\n\n        except sqlite3.Error as e:\n            print(f\"Error deleting data from table {table_name}: {e}\")\n        except Exception as e:\n             print(f\"An unexpected error occurred during deletion: {e}\")\n\n# Example Usage (optional, can be placed outside the class)\nif __name__ == '__main__':\n    db = DatabaseProcessor('test_database.db')\n\n    # Create table\n    print(\"--- Creating Table ---\")\n    db.create_table('people', 'person_name', 'person_age')\n    db.create_table('products', 'product_name', 'product_price') # Example with different names\n\n    # Insert data\n    print(\"\\n--- Inserting Data ---\")\n    people_data = [\n        {'person_name': 'Alice', 'person_age': 30},\n        {'person_name': 'Bob', 'person_age': 25},\n        {'person_name': 'Charlie', 'person_age': 35},\n        {'person_name': 'Alice', 'person_age': 32} # Another Alice\n    ]\n    db.insert_into_database('people', people_data)\n\n    product_data = [\n        {'product_name': 'Laptop', 'product_price': 1200},\n        {'product_name': 'Mouse', 'product_price': 25}\n    ]\n    db.insert_into_database('products', product_data)\n\n    # Search data\n    print(\"\\n--- Searching Data ---\")\n    alice_rows = db.search_database('people', 'Alice')\n    print(f\"Search results for Alice: {alice_rows}\")\n\n    bob_rows = db.search_database('people', 'Bob')\n    print(f\"Search results for Bob: {bob_rows}\")\n\n    david_rows = db.search_database('people', 'David')\n    print(f\"Search results for David: {david_rows}\") # Should return None\n\n    laptop_rows = db.search_database('products', 'Laptop')\n    print(f\"Search results for Laptop: {laptop_rows}\")\n\n\n    # Delete data\n    print(\"\\n--- Deleting Data ---\")\n    db.delete_from_database('people', 'Bob')\n\n    # Verify deletion by searching again\n    print(\"\\n--- Verifying Deletion ---\")\n    bob_rows_after_delete = db.search_database('people', 'Bob')\n    print(f\"Search results for Bob after deletion: {bob_rows_after_delete}\") # Should return None\n\n    alice_rows_after_delete = db.search_database('people', 'Alice')\n    print(f\"Search results for Alice after deletion: {alice_rows_after_delete}\") # Should still find Alice\n\n    db.delete_from_database('people', 'Alice')\n    alice_rows_after_all_delete = db.search_database('people', 'Alice')\n    print(f\"Search results for Alice after second deletion: {alice_rows_after_all_delete}\") # Should return None\n\n    # Clean up the test database file (optional)\n    # import os\n    # if os.path.exists('test_database.db'):\n    #     os.remove('test_database.db')\n    #     print(\"\\nTest database file 'test_database.db' removed.\")\n```",
      "```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def _connect(self):\n        \"\"\"Helper method to establish a database connection.\"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            conn.row_factory = sqlite3.Row # Optional: Allows accessing columns by name\n            return conn\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            return None\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column (TEXT).\n        :param key2: str, the name of the second column (INTEGER).\n        >>> db = DatabaseProcessor(':memory:') # Use in-memory database for example\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n        conn = self._connect()\n        if conn:\n            cursor = conn.cursor()\n            try:\n                # Using IF NOT EXISTS prevents errors if the table already exists\n                cursor.execute(f'''\n                    CREATE TABLE IF NOT EXISTS {table_name} (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        {key1} TEXT,\n                        {key2} INTEGER\n                    )\n                ''')\n                conn.commit()\n                print(f\"Table '{table_name}' created or already exists.\")\n            except sqlite3.Error as e:\n                print(f\"Error creating table '{table_name}': {e}\")\n            finally:\n                conn.close()\n        else:\n            print(\"Failed to connect to database.\")\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        Assumes the keys in the data dictionaries match the column names (excluding 'id').\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db = DatabaseProcessor(':memory:')\n        >>> db.create_table('user', 'name', 'age')\n        >>> db.insert_into_database('user', [\n        ...         {'name': 'John', 'age': 25},\n        ...         {'name': 'Alice', 'age': 30}\n        ...     ])\n        \"\"\"\n        if not data:\n            print(\"No data provided for insertion.\")\n            return\n\n        conn = self._connect()\n        if conn:\n            cursor = conn.cursor()\n            try:\n                # Assume all dictionaries in data have the same keys as columns\n                columns = data[0].keys()\n                # Prepare the INSERT statement dynamically\n                # e.g., INSERT INTO user (name, age) VALUES (?, ?)\n                placeholders = ', '.join(['?'] * len(columns))\n                column_names = ', '.join(columns)\n                sql = f\"INSERT INTO {table_name} ({column_names}) VALUES ({placeholders})\"\n\n                # Prepare data values\n                values = [tuple(d.values()) for d in data]\n\n                # Execute the insertion\n                cursor.executemany(sql, values)\n                conn.commit()\n                print(f\"{len(data)} rows inserted into '{table_name}'.\")\n            except sqlite3.Error as e:\n                print(f\"Error inserting data into table '{table_name}': {e}\")\n            except Exception as e:\n                 print(f\"An unexpected error occurred during insertion: {e}\")\n            finally:\n                conn.close()\n        else:\n            print(\"Failed to connect to database.\")\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        Assumes the 'name' parameter corresponds to the column named 'name' or the first TEXT column (key1).\n        For this implementation, we assume the column to search is explicitly named 'name'.\n        If the table was created with different column names (key1, key2), you might need to adjust.\n        Assuming 'name' search is always on the 'name' column based on the docstring examples.\n        \n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for in the 'name' column.\n        :return: list, a list of sqlite3.Row objects representing the rows with matching name, if any;\n                    returns an empty list [] if no match; returns None if an error occurs.\n        >>> db = DatabaseProcessor(':memory:')\n        >>> db.create_table('user', 'name', 'age')\n        >>> db.insert_into_database('user', [{'name': 'John', 'age': 25}, {'name': 'Alice', 'age': 30}])\n        >>> results = db.search_database('user', 'John')\n        >>> print(results) # Output similar to [<sqlite3.Row object at ...>] containing (1, 'John', 25)\n        >>> print(db.search_database('user', 'Bob'))\n        []\n        \"\"\"\n        conn = self._connect()\n        if conn:\n            cursor = conn.cursor()\n            try:\n                # Assuming the search is always on a column named 'name' based on the docstring\n                # If your create_table used different names for key1/key2, you might need\n                # to retrieve schema or pass the column name explicitly.\n                sql = f\"SELECT id, name, age FROM {table_name} WHERE name = ?\" # Adjust column names if necessary\n                cursor.execute(sql, (name,))\n                rows = cursor.fetchall()\n                return rows # Returns list of sqlite3.Row objects or empty list []\n            except sqlite3.OperationalError as e:\n                 print(f\"Error searching table '{table_name}': {e}. Make sure the table and 'name' column exist.\")\n                 return None\n            except sqlite3.Error as e:\n                print(f\"Error searching table '{table_name}': {e}\")\n                return None\n            finally:\n                conn.close()\n        else:\n            print(\"Failed to connect to database.\")\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        Assumes the 'name' parameter corresponds to the column named 'name' or the first TEXT column (key1).\n        For this implementation, we assume the column to search is explicitly named 'name'.\n        \n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion in the 'name' column.\n        >>> db = DatabaseProcessor(':memory:')\n        >>> db.create_table('user', 'name', 'age')\n        >>> db.insert_into_database('user', [{'name': 'John', 'age': 25}, {'name': 'Alice', 'age': 30}])\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n        conn = self._connect()\n        if conn:\n            cursor = conn.cursor()\n            try:\n                # Assuming the deletion is always based on a column named 'name'\n                sql = f\"DELETE FROM {table_name} WHERE name = ?\"\n                cursor.execute(sql, (name,))\n                conn.commit()\n                print(f\"{cursor.rowcount} rows deleted from '{table_name}' with name '{name}'.\")\n            except sqlite3.OperationalError as e:\n                 print(f\"Error deleting from table '{table_name}': {e}. Make sure the table and 'name' column exist.\")\n            except sqlite3.Error as e:\n                print(f\"Error deleting from table '{table_name}': {e}\")\n            finally:\n                conn.close()\n        else:\n            print(\"Failed to connect to database.\")\n\n# Example Usage (requires uncommenting and running the script)\n# if __name__ == '__main__':\n#     # Use an in-memory database for demonstration\n#     db = DatabaseProcessor(':memory:') # Or use 'my_database.db' for a file\n\n#     # 1. Create a table\n#     db.create_table('users', 'name', 'age')\n#     db.create_table('products', 'item', 'price') # Another table\n\n#     # 2. Insert data\n#     user_data = [\n#         {'name': 'Alice', 'age': 30},\n#         {'name': 'Bob', 'age': 22},\n#         {'name': 'Alice', 'age': 31} # Another Alice\n#     ]\n#     db.insert_into_database('users', user_data)\n\n#     product_data = [\n#         {'item': 'Laptop', 'price': 1200},\n#         {'item': 'Mouse', 'price': 25}\n#     ]\n#     db.insert_into_database('products', product_data)\n\n#     # 3. Search data\n#     print(\"\\nSearching for 'Alice' in users:\")\n#     alice_users = db.search_database('users', 'Alice')\n#     if alice_users:\n#         for row in alice_users:\n#             # Access columns by name if using row_factory = sqlite3.Row\n#             print(f\"ID: {row['id']}, Name: {row['name']}, Age: {row['age']}\")\n#             # Or by index if not using row_factory\n#             # print(f\"ID: {row[0]}, Name: {row[1]}, Age: {row[2]}\")\n#     else:\n#         print(\"No users found with the name 'Alice'\")\n\n#     print(\"\\nSearching for 'Charlie' in users:\")\n#     charlie_users = db.search_database('users', 'Charlie')\n#     if charlie_users is not None: # Check if search itself failed\n#         if charlie_users: # Check if results were found\n#             for row in charlie_users:\n#                 print(f\"ID: {row['id']}, Name: {row['name']}, Age: {row['age']}\")\n#         else:\n#             print(\"No users found with the name 'Charlie'\")\n\n\n#     # 4. Delete data\n#     print(\"\\nDeleting 'Bob' from users:\")\n#     db.delete_from_database('users', 'Bob')\n\n#     # Search again to confirm deletion\n#     print(\"\\nSearching for 'Bob' after deletion:\")\n#     bob_users_after_delete = db.search_database('users', 'Bob')\n#     if bob_users_after_delete is not None:\n#          if bob_users_after_delete:\n#             for row in bob_users_after_delete:\n#                 print(f\"ID: {row['id']}, Name: {row['name']}, Age: {row['age']}\")\n#          else:\n#             print(\"No users found with the name 'Bob' after deletion.\")\n\n```",
      "```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n        # Optional: Store table schema if needed for more complex operations,\n        # but for this task, we can rely on the provided keys for search/delete.\n        self._table_schemas = {}\n\n\n    def _execute_query(self, query, params=()):\n        \"\"\"Helper method to execute a SQL query.\"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            conn.commit()\n            conn.close()\n            return True\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return False\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n\n    def _fetch_query(self, query, params=()):\n        \"\"\"Helper method to execute a SQL query and fetch results.\"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return None\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return None\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column (TEXT).\n        :param key2: str, the name of the second column (INTEGER).\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n        query = f\"\"\"\n        CREATE TABLE IF NOT EXISTS {table_name} (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            {key1} TEXT,\n            {key2} INTEGER\n        );\n        \"\"\"\n        if self._execute_query(query):\n            print(f\"Table '{table_name}' created or already exists.\")\n            # Store schema information for later use if needed (e.g., for search/delete based on key1)\n            self._table_schemas[table_name] = {'key1': key1, 'key2': key2}\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        Assumes data dictionaries have keys matching the table column names (excluding id).\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n        if not data:\n            print(\"No data provided for insertion.\")\n            return\n\n        # Infer columns from the first dictionary\n        # Ensure table exists and schema is known if possible, or rely on data keys\n        # For this simple case, we assume data keys match table column names (key1, key2)\n        # A more robust implementation might retrieve schema from DB or store it\n        if table_name not in self._table_schemas:\n             # Attempt to infer schema from first data item if not stored\n             # This is fragile, better to rely on create_table storing schema\n             if isinstance(data[0], dict):\n                 keys = list(data[0].keys())\n                 if len(keys) == 2:\n                     self._table_schemas[table_name] = {'key1': keys[0], 'key2': keys[1]}\n                 else:\n                     print(f\"Cannot infer table schema for '{table_name}'. Please ensure create_table was called first.\")\n                     return\n             else:\n                  print(f\"Cannot infer table schema for '{table_name}'. Data format unexpected.\")\n                  return\n\n        key1_col = self._table_schemas[table_name]['key1']\n        key2_col = self._table_schemas[table_name]['key2']\n\n        # Ensure data dictionaries contain the required keys\n        for item in data:\n            if not (key1_col in item and key2_col in item):\n                print(f\"Skipping item due to missing keys ({key1_col}, {key2_col}): {item}\")\n                continue\n\n            # Construct the query using the actual column names\n            query = f\"\"\"\n            INSERT INTO {table_name} ({key1_col}, {key2_col})\n            VALUES (?, ?);\n            \"\"\"\n            params = (item[key1_col], item[key2_col])\n\n            if not self._execute_query(query, params):\n                 print(f\"Failed to insert data: {item}\")\n\n        print(f\"Insertion attempt finished for table '{table_name}'.\")\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        Assumes 'name' corresponds to the column specified as key1 during table creation.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the value to search for in the key1 column.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns an empty list. Returns None on error.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n        if table_name not in self._table_schemas:\n             print(f\"Unknown table '{table_name}'. Please ensure create_table was called first.\")\n             return None\n\n        key1_col = self._table_schemas[table_name]['key1']\n\n        query = f\"\"\"\n        SELECT id, {key1_col}, {self._table_schemas[table_name]['key2']}\n        FROM {table_name}\n        WHERE {key1_col} = ?;\n        \"\"\"\n        results = self._fetch_query(query, (name,))\n\n        # Return empty list if no results found, as per typical query behavior,\n        # or None if _fetch_query returned None (indicating an error).\n        if results is None:\n            return None\n        elif not results:\n             print(f\"No records found for name '{name}' in table '{table_name}'.\")\n             return []\n        else:\n            print(f\"Found {len(results)} records for name '{name}' in table '{table_name}'.\")\n            return results\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        Assumes 'name' corresponds to the column specified as key1 during table creation.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the value to match for deletion in the key1 column.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n        if table_name not in self._table_schemas:\n             print(f\"Unknown table '{table_name}'. Please ensure create_table was called first.\")\n             return\n\n        key1_col = self._table_schemas[table_name]['key1']\n\n        query = f\"\"\"\n        DELETE FROM {table_name}\n        WHERE {key1_col} = ?;\n        \"\"\"\n        if self._execute_query(query, (name,)):\n            print(f\"Attempted to delete records with {key1_col} = '{name}' from table '{table_name}'.\")\n\n# Example Usage (optional, for testing)\nif __name__ == '__main__':\n    db_name = 'test_database.db'\n    db = DatabaseProcessor(db_name)\n\n    # Clean up previous test run\n    import os\n    if os.path.exists(db_name):\n        os.remove(db_name)\n        print(f\"Removed existing database file: {db_name}\")\n\n    # 1. Create table\n    db.create_table('users', 'username', 'score')\n\n    # 2. Insert data\n    user_data = [\n        {'username': 'Alice', 'score': 100},\n        {'username': 'Bob', 'score': 75},\n        {'username': 'Alice', 'score': 120},\n        {'username': 'Charlie', 'score': 90},\n        # Test with missing key\n        {'username': 'David'},\n        {'score': 50},\n        {'username': 'Eve', 'score': 110}\n    ]\n    db.insert_into_database('users', user_data)\n\n    # Insert into a non-existent table (should fail gracefully if schema not stored)\n    # db.insert_into_database('scores', [{'player': 'Frank', 'points': 200}]) # This would fail if create_table wasn't called for 'scores'\n\n    # 3. Search database\n    print(\"\\n--- Searching ---\")\n    alice_records = db.search_database('users', 'Alice')\n    print(f\"Search results for 'Alice': {alice_records}\")\n\n    bob_records = db.search_database('users', 'Bob')\n    print(f\"Search results for 'Bob': {bob_records}\")\n\n    non_existent_records = db.search_database('users', 'Zack')\n    print(f\"Search results for 'Zack': {non_existent_records}\") # Should return []\n\n    search_unknown_table = db.search_database('products', 'Apple') # Should return None\n    print(f\"Search results for 'Apple' in 'products': {search_unknown_table}\")\n\n    # 4. Delete data\n    print(\"\\n--- Deleting ---\")\n    db.delete_from_database('users', 'Bob')\n    print(\"After deleting Bob:\")\n    bob_records_after_delete = db.search_database('users', 'Bob')\n    print(f\"Search results for 'Bob': {bob_records_after_delete}\") # Should return []\n\n    db.delete_from_database('users', 'Alice')\n    print(\"After deleting Alice:\")\n    alice_records_after_delete = db.search_database('users', 'Alice')\n    print(f\"Search results for 'Alice': {alice_records_after_delete}\") # Should return []\n\n    db.delete_from_database('users', 'NonExistent') # Should run without error but delete 0 rows\n    print(\"Attempted to delete 'NonExistent'\")\n\n    delete_unknown_table = db.delete_from_database('products', 'Orange') # Should print warning\n    print(\"Attempted to delete from 'products'\")\n\n    # Verify remaining data\n    print(\"\\n--- Final Search ---\")\n    all_records_query = \"SELECT id, username, score FROM users;\"\n    remaining_records = db._fetch_query(all_records_query)\n    print(f\"Remaining records in 'users': {remaining_records}\") # Should only show Charlie and Eve\n\n    # Clean up the database file after tests\n    # os.remove(db_name)\n    # print(f\"\\nCleaned up database file: {db_name}\")\n```",
      "```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n    def _connect(self):\n        \"\"\"Internal helper to connect to the database.\"\"\"\n        return sqlite3.connect(self.database_name)\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n        try:\n            with self._connect() as conn:\n                cursor = conn.cursor()\n                # Use parameter substitution for table and column names (less common but safer if names come from user input, though direct f-strings are typical for fixed schema)\n                # Let's use f-string for schema definition as it's common, but be mindful of potential SQL injection if table/key names are user-supplied and not validated.\n                # For this example, assuming key1 and key2 are valid column names.\n                create_table_sql = f\"\"\"\n                CREATE TABLE IF NOT EXISTS {table_name} (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    {key1} TEXT,\n                    {key2} INTEGER\n                );\n                \"\"\"\n                cursor.execute(create_table_sql)\n                conn.commit()\n                print(f\"Table '{table_name}' created or already exists.\")\n        except sqlite3.Error as e:\n            print(f\"Error creating table '{table_name}': {e}\")\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        Assumes data dictionaries have keys matching the table column names (excluding 'id').\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n        if not data:\n            print(\"No data provided to insert.\")\n            return\n\n        try:\n            # Infer column names from the first dictionary's keys (excluding 'id')\n            # Assumes all dictionaries have the same keys matching the table columns\n            columns = [k for k in data[0].keys() if k != 'id']\n            if not columns:\n                print(\"Data dictionaries must contain keys matching table columns.\")\n                return\n\n            # Prepare the INSERT statement\n            cols_str = ', '.join(columns)\n            placeholders = ', '.join(['?'] * len(columns))\n            insert_sql = f\"INSERT INTO {table_name} ({cols_str}) VALUES ({placeholders})\"\n\n            # Prepare the data for insertion\n            rows_to_insert = [[row[col] for col in columns] for row in data]\n\n            with self._connect() as conn:\n                cursor = conn.cursor()\n                cursor.executemany(insert_sql, rows_to_insert)\n                conn.commit()\n                print(f\"Inserted {len(data)} rows into '{table_name}'.\")\n        except sqlite3.Error as e:\n            print(f\"Error inserting data into table '{table_name}': {e}\")\n        except KeyError as e:\n             print(f\"Error: Missing key in data dictionary: {e}. Ensure keys match table columns.\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during insertion: {e}\")\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        Assumes the 'name' column exists and is the one specified as key1 during table creation.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n        try:\n            with self._connect() as conn:\n                cursor = conn.cursor()\n                # Need to know the actual column name for 'name'.\n                # A robust solution would store key1/key2 names or query schema.\n                # For this example, we'll assume 'name' is the column used for searching,\n                # which implies it must match key1 provided in create_table.\n                # We need the actual column name from the table. Let's try to fetch it or assume it's passed/known.\n                # A practical implementation might require passing the column name to search in,\n                # or the class could store the key1/key2 names.\n                # Let's assume for this exercise that the `name` parameter maps to the *first* data column created (key1).\n                # We can query the schema to find the column name.\n                # Simpler approach: Rely on the user providing the correct column name or assuming a convention.\n                # Let's assume the search is always on the column named 'name'. If the user created a table with key1='username', this would fail.\n                # Let's modify slightly to accept the column name to search in.\n                # Or, let's stick to the prompt: search based on 'name', which likely implies the column storing names.\n                # We will assume the column name corresponding to the 'name' search parameter is actually named 'name' in the table.\n                # If create_table used ('user', 'fullname', 'age'), searching for 'name' would fail.\n                # Let's improve this by searching based on the *column name* that holds the name,\n                # assuming key1 is the name column. We need key1 from create_table. This requires storing key1/key2.\n                # Let's modify the class to store key1 and key2.\n\n                # --- Refactoring: Store key1 and key2 ---\n                # To do this properly, __init__ would need key1 and key2, or create_table would set instance variables.\n                # Let's proceed assuming the search is always on a column named 'name' for simplicity,\n                # matching the example `db.search_database('user', 'John')` which implies a 'name' column.\n                # A better design would link key1/key2 names from create_table to search/delete.\n\n                # Assuming the column to search by name is simply named 'name'\n                search_column = 'name' # This is a major assumption based on the example\n\n                search_sql = f\"SELECT id, {search_column}, key2 FROM {table_name} WHERE {search_column} = ?\" # This is still problematic as 'key2' isn't known.\n                # Okay, the SELECT should just get all columns *except* maybe id if not needed.\n                # Let's get all columns: SELECT * FROM table_name WHERE name_column = ?\n                # We need the name of the column that holds the 'name' value.\n                # Let's assume the first created column (key1) is the name column.\n                # We still need the actual name of key1.\n                # Let's query the table info to find the second column's name (index 1 after 'id').\n\n                cursor.execute(f\"PRAGMA table_info({table_name});\")\n                columns_info = cursor.fetchall()\n                if len(columns_info) < 2:\n                     print(f\"Error: Table '{table_name}' does not exist or has insufficient columns.\")\n                     return None\n\n                # Assuming the second column (index 1, after 'id' at index 0) is the 'name' column (key1)\n                name_column_info = columns_info[1]\n                name_column_name = name_column_info[1] # The column name is at index 1 in pragma output\n\n                search_sql = f\"SELECT * FROM {table_name} WHERE {name_column_name} = ?\"\n\n                cursor.execute(search_sql, (name,))\n                results = cursor.fetchall()\n\n                if results:\n                    return results\n                else:\n                    print(f\"No results found for name '{name}' in table '{table_name}'.\")\n                    return None # Return None as per docstring\n        except sqlite3.Error as e:\n            print(f\"Error searching database: {e}\")\n            return None\n        except Exception as e:\n             print(f\"An unexpected error occurred during search: {e}\")\n             return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        Assumes the 'name' column exists and is the one specified as key1 during table creation.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n        try:\n            with self._connect() as conn:\n                cursor = conn.cursor()\n\n                # Similar issue as search_database: Need the actual column name for 'name'.\n                # Assuming the second column (key1) is the name column based on create_table structure.\n                cursor.execute(f\"PRAGMA table_info({table_name});\")\n                columns_info = cursor.fetchall()\n                if len(columns_info) < 2:\n                     print(f\"Error: Cannot delete. Table '{table_name}' does not exist or has insufficient columns.\")\n                     return\n\n                # Assuming the second column (index 1) is the 'name' column (key1)\n                name_column_info = columns_info[1]\n                name_column_name = name_column_info[1]\n\n                delete_sql = f\"DELETE FROM {table_name} WHERE {name_column_name} = ?\"\n\n                cursor.execute(delete_sql, (name,))\n                rows_deleted = cursor.rowcount\n                conn.commit()\n                print(f\"Deleted {rows_deleted} row(s) with name '{name}' from '{table_name}'.\")\n\n        except sqlite3.Error as e:\n            print(f\"Error deleting from database: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during deletion: {e}\")\n\n\n# Example Usage (Optional, for testing)\nif __name__ == '__main__':\n    db_name = 'my_test_database.db'\n    db = DatabaseProcessor(db_name)\n\n    # Clean up previous run\n    import os\n    if os.path.exists(db_name):\n        os.remove(db_name)\n        print(f\"Removed existing database file '{db_name}'.\")\n\n    # 1. Create Table\n    db.create_table('users', 'name', 'age') # key1='name', key2='age'\n    db.create_table('products', 'item', 'price') # key1='item', key2='price'\n\n    # 2. Insert Data\n    user_data = [\n        {'name': 'John', 'age': 25},\n        {'name': 'Alice', 'age': 30},\n        {'name': 'Bob', 'age': 22},\n        {'name': 'Alice', 'age': 28} # Test duplicate name\n    ]\n    db.insert_into_database('users', user_data)\n\n    product_data = [\n        {'item': 'Laptop', 'price': 1200},\n        {'item': 'Keyboard', 'price': 75}\n    ]\n    db.insert_into_database('products', product_data)\n\n    db.insert_into_database('users', []) # Test empty data\n\n    # 3. Search Data\n    print(\"\\nSearching for 'John':\")\n    john_data = db.search_database('users', 'John')\n    print(john_data) # Expected: [(1, 'John', 25)] (IDs might vary based on insertions)\n\n    print(\"\\nSearching for 'Alice':\")\n    alice_data = db.search_database('users', 'Alice')\n    print(alice_data) # Expected: [(2, 'Alice', 30), (4, 'Alice', 28)] (IDs might vary)\n\n    print(\"\\nSearching for 'Charlie':\")\n    charlie_data = db.search_database('users', 'Charlie')\n    print(charlie_data) # Expected: None (and \"No results found...\")\n\n    print(\"\\nSearching for 'Laptop':\")\n    laptop_data = db.search_database('products', 'Laptop')\n    print(laptop_data) # Expected: [(?, 'Laptop', 1200)]\n\n    # Search in a non-existent table\n    print(\"\\nSearching in 'nonexistent_table':\")\n    non_existent_data = db.search_database('nonexistent_table', 'test')\n    print(non_existent_data) # Expected: None (and error message)\n\n\n    # 4. Delete Data\n    print(\"\\nDeleting 'John':\")\n    db.delete_from_database('users', 'John')\n\n    print(\"\\nSearching for 'John' after deletion:\")\n    john_data_after_delete = db.search_database('users', 'John')\n    print(john_data_after_delete) # Expected: None\n\n    print(\"\\nDeleting 'Alice':\")\n    db.delete_from_database('users', 'Alice') # Should delete both Alices\n\n    print(\"\\nSearching for 'Alice' after deletion:\")\n    alice_data_after_delete = db.search_database('users', 'Alice')\n    print(alice_data_after_delete) # Expected: None\n\n    print(\"\\nDeleting 'NonExistentName':\")\n    db.delete_from_database('users', 'NonExistentName') # Should report 0 rows deleted\n\n    # Delete from a non-existent table\n    print(\"\\nDeleting from 'nonexistent_table':\")\n    db.delete_from_database('nonexistent_table', 'test') # Expected: Error message\n\n    # Verify remaining data\n    print(\"\\nVerifying remaining data in 'users':\")\n    with db._connect() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM users\")\n        print(cursor.fetchall()) # Expected: [(3, 'Bob', 22)] (ID might vary)\n\n    # Clean up the database file after examples\n    # import os\n    # os.remove(db_name)\n    # print(f\"\\nRemoved database file '{db_name}'.\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_60",
    "skeleton": "import sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"",
    "test": "import unittest\nimport os\n\n\nclass MovieTicketDBTestInsertTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_insert_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_insert_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_insert_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_insert_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_insert_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')\n\n\nclass MovieTicketDBTestSearchTicketsByCustomer(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_search_tickets_by_customer_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_search_tickets_by_customer_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_search_tickets_by_customer_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_search_tickets_by_customer_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_search_tickets_by_customer_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')\n\n\nclass MovieTicketDBTestDeleteTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_delete_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 0)\n\n\nclass MovieTicketDBTest(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_MovieTicketDB(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)",
    "solution_code": "import sqlite3\n\n\nclass MovieTicketDB:\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        ''')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n",
    "class_name": "MovieTicketDB",
    "test_classes": [
      "MovieTicketDBTestInsertTicket",
      "MovieTicketDBTestSearchTicketsByCustomer",
      "MovieTicketDBTestDeleteTicket",
      "MovieTicketDBTest"
    ],
    "class_constructor": "class MovieTicketDB: \n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n",
    "fields": [
      "self.connection",
      "self.cursor"
    ],
    "methods_info": [
      {
        "method_name": "create_table",
        "method_description": "def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"",
        "test_class": "MovieTicketDBTestInsertTicket",
        "test_code": "class MovieTicketDBTestInsertTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_insert_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_insert_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_insert_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_insert_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_insert_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')",
        "solution_code": "def create_table(self):\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        ''')\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert_ticket",
        "method_description": "def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"",
        "test_class": "MovieTicketDBTestSearchTicketsByCustomer",
        "test_code": "class MovieTicketDBTestSearchTicketsByCustomer(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_search_tickets_by_customer_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n\n    def test_search_tickets_by_customer_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'aaa')\n\n    def test_search_tickets_by_customer_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'bbb')\n\n    def test_search_tickets_by_customer_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ccc')\n\n    def test_search_tickets_by_customer_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'ddd')",
        "solution_code": "def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_tickets_by_customer",
        "method_description": "def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"",
        "test_class": "MovieTicketDBTestDeleteTicket",
        "test_code": "class MovieTicketDBTestDeleteTicket(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_delete_ticket_1(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_2(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'aaa')\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('aaa')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_3(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'bbb')\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('bbb')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_4(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ccc')\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ccc')\n        self.assertEqual(len(tickets), 0)\n\n    def test_delete_ticket_5(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'ddd')\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 1)\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('ddd')\n        self.assertEqual(len(tickets), 0)",
        "solution_code": "def search_tickets_by_customer(self, customer_name):\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_ticket",
        "method_description": "def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"",
        "test_class": "MovieTicketDBTest",
        "test_code": "class MovieTicketDBTest(unittest.TestCase):\n    def setUp(self):\n        self.db_name = 'test_database.db'\n        self.db = MovieTicketDB(self.db_name)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.remove(self.db_name)\n\n    def test_MovieTicketDB(self):\n        self.db.insert_ticket('Avengers: Endgame', 'Cinema 1', 'A1', 'John Doe')\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 1)\n        ticket = tickets[0]\n        self.assertEqual(ticket[1], 'Avengers: Endgame')\n        self.assertEqual(ticket[2], 'Cinema 1')\n        self.assertEqual(ticket[3], 'A1')\n        self.assertEqual(ticket[4], 'John Doe')\n        ticket_id = tickets[0][0]\n        self.db.delete_ticket(ticket_id)\n        tickets = self.db.search_tickets_by_customer('John Doe')\n        self.assertEqual(len(tickets), 0)",
        "solution_code": "def delete_ticket(self, ticket_id):\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS tickets (\n                    ID INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n            print(\"Table 'tickets' created successfully (or already exists).\")\n        except sqlite3.Error as e:\n            print(f\"An error occurred while creating the table: {e}\")\n            # Optionally rollback if creation failed mid-way, though IF NOT EXISTS handles most cases\n            # self.connection.rollback()\n\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            ''', (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n            print(f\"Ticket for {movie_name} ({seat_number}) inserted successfully.\")\n        except sqlite3.Error as e:\n            print(f\"An error occurred while inserting the ticket: {e}\")\n            self.connection.rollback()\n\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\":memory:\") # Use in-memory db for tests\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> ticket_db.insert_ticket(\"Movie B\", \"Theater 2\", \"B2\", \"Jane Smith\")\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A2\", \"John Doe\")\n        >>> result_john = ticket_db.search_tickets_by_customer(\"John Doe\")\n        >>> len(result_john)\n        2\n        >>> result_jane = ticket_db.search_tickets_by_customer(\"Jane Smith\")\n        >>> len(result_jane)\n        1\n        >>> result_nonexistent = ticket_db.search_tickets_by_customer(\"Peter Pan\")\n        >>> len(result_nonexistent)\n        0\n        >>> ticket_db.close() # Clean up connection\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT * FROM tickets WHERE customer_name = ?\", (customer_name,))\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"An error occurred while searching for tickets: {e}\")\n            return []\n\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        >>> ticket_db = MovieTicketDB(\":memory:\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie X\", \"Theater 3\", \"C3\", \"Customer 1\")\n        >>> ticket_db.insert_ticket(\"Movie Y\", \"Theater 4\", \"D4\", \"Customer 2\")\n        >>> initial_count = len(ticket_db.search_tickets_by_customer(\"Customer 1\"))\n        >>> initial_count\n        1\n        >>> # Assuming ID 1 was assigned to the first ticket\n        >>> ticket_db.delete_ticket(1)\n        Ticket with ID 1 deleted successfully (if it existed).\n        >>> updated_count = len(ticket_db.search_tickets_by_customer(\"Customer 1\"))\n        >>> updated_count\n        0\n        >>> ticket_db.delete_ticket(999) # Try deleting non-existent ID\n        Ticket with ID 999 deleted successfully (if it existed).\n        >>> ticket_db.close()\n\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM tickets WHERE ID = ?\", (ticket_id,))\n            self.connection.commit()\n            # print(f\"Ticket with ID {ticket_id} deleted successfully.\") # Can't know if it actually deleted one row without checking rowcount\n            # A more accurate message could check rowcount:\n            # if self.cursor.rowcount > 0:\n            #     print(f\"Ticket with ID {ticket_id} deleted successfully.\")\n            # else:\n            #     print(f\"No ticket found with ID {ticket_id}.\")\n            # Keeping original print for simplicity as requested by structure\n            print(f\"Ticket with ID {ticket_id} deleted successfully (if it existed).\")\n        except sqlite3.Error as e:\n            print(f\"An error occurred while deleting the ticket: {e}\")\n            self.connection.rollback()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            print(\"Database connection closed.\")\n\n# Example usage (optional - for testing the class)\nif __name__ == '__main__':\n    # Create a database in memory for testing\n    db = MovieTicketDB(\":memory:\")\n\n    # Insert tickets\n    db.insert_ticket(\"Inception\", \"AMC 12\", \"D10\", \"Alice Wonderland\")\n    db.insert_ticket(\"The Matrix\", \"Regal Cinema\", \"A5\", \"Bob Builder\")\n    db.insert_ticket(\"Inception\", \"AMC 12\", \"D11\", \"Alice Wonderland\")\n    db.insert_ticket(\"Parasite\", \"Arthouse Theater\", \"G7\", \"Charlie Chaplin\")\n\n    # Search for tickets\n    print(\"\\nSearching for tickets for Alice Wonderland:\")\n    alice_tickets = db.search_tickets_by_customer(\"Alice Wonderland\")\n    if alice_tickets:\n        for ticket in alice_tickets:\n            print(ticket)\n    else:\n        print(\"No tickets found for Alice Wonderland.\")\n\n    print(\"\\nSearching for tickets for Bob Builder:\")\n    bob_tickets = db.search_tickets_by_customer(\"Bob Builder\")\n    if bob_tickets:\n        for ticket in bob_tickets:\n            print(ticket)\n    else:\n        print(\"No tickets found for Bob Builder.\")\n\n    print(\"\\nSearching for tickets for David:\")\n    david_tickets = db.search_tickets_by_customer(\"David\")\n    if david_tickets:\n        for ticket in david_tickets:\n            print(ticket)\n    else:\n        print(\"No tickets found for David.\")\n\n    # Get all tickets to find an ID to delete\n    print(\"\\nAll tickets before deletion:\")\n    db.cursor.execute(\"SELECT * FROM tickets\")\n    all_tickets = db.cursor.fetchall()\n    for ticket in all_tickets:\n        print(ticket)\n\n    # Assuming the first ticket (Inception for Alice) has ID 1\n    if all_tickets:\n        ticket_id_to_delete = all_tickets[0][0] # Get the ID of the first ticket\n        print(f\"\\nDeleting ticket with ID {ticket_id_to_delete}...\")\n        db.delete_ticket(ticket_id_to_delete)\n\n        print(\"\\nAll tickets after deletion:\")\n        db.cursor.execute(\"SELECT * FROM tickets\")\n        all_tickets_after_delete = db.cursor.fetchall()\n        for ticket in all_tickets_after_delete:\n            print(ticket)\n\n    # Close the connection\n    db.close()\n\n    # Demonstrate the docstring examples (requires doctest)\n    # import doctest\n    # print(\"\\nRunning doctests...\")\n    # doctest.testmod()\n```",
      "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include ID of type integer, movie name of type text, theater name of type text,\n        seat number of type text, and customer name of type text. ID is the primary key and auto-increments.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS tickets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n            print(\"Table 'tickets' created or already exists.\")\n        except sqlite3.Error as e:\n            print(f\"Database error during table creation: {e}\")\n\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            ''', (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n            print(f\"Ticket inserted for {customer_name} for movie {movie_name}.\")\n        except sqlite3.Error as e:\n            print(f\"Database error during ticket insertion: {e}\")\n            self.connection.rollback() # Rollback changes if insertion fails\n\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria. Returns an empty list if no tickets found or an error occurs.\n        >>> # Example usage (requires a running instance and data)\n        >>> # ticket_db = MovieTicketDB(\":memory:\") # Use in-memory DB for testing\n        >>> # ticket_db.create_table()\n        >>> # ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> # ticket_db.insert_ticket(\"Movie B\", \"Theater 2\", \"B5\", \"Jane Doe\")\n        >>> # ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A2\", \"John Doe\")\n        >>> # result_john = ticket_db.search_tickets_by_customer(\"John Doe\")\n        >>> # print(f\"Tickets for John Doe: {result_john}\")\n        >>> # assert len(result_john) == 2\n        >>> # result_jane = ticket_db.search_tickets_by_customer(\"Jane Doe\")\n        >>> # print(f\"Tickets for Jane Doe: {result_jane}\")\n        >>> # assert len(result_jane) == 1\n        >>> # result_nobody = ticket_db.search_tickets_by_customer(\"Nobody\")\n        >>> # print(f\"Tickets for Nobody: {result_nobody}\")\n        >>> # assert len(result_nobody) == 0\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                SELECT id, movie_name, theater_name, seat_number, customer_name\n                FROM tickets\n                WHERE customer_name = ?\n            ''', (customer_name,))\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"Database error during ticket search: {e}\")\n            return []\n\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                DELETE FROM tickets\n                WHERE id = ?\n            ''', (ticket_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                 print(f\"Ticket with ID {ticket_id} deleted successfully.\")\n            else:\n                 print(f\"No ticket found with ID {ticket_id}.\")\n        except sqlite3.Error as e:\n            print(f\"Database error during ticket deletion: {e}\")\n            self.connection.rollback()\n\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            print(\"Database connection closed.\")\n\n# Example Usage (Optional - uncomment to test)\n# if __name__ == \"__main__\":\n#     # Use an in-memory database for quick testing\n#     db = MovieTicketDB(\":memory:\")\n#\n#     # Insert tickets\n#     db.insert_ticket(\"Inception\", \"AMC\", \"H10\", \"Alice\")\n#     db.insert_ticket(\"The Matrix\", \"Regal\", \"C5\", \"Bob\")\n#     db.insert_ticket(\"Inception\", \"AMC\", \"H11\", \"Alice\")\n#     db.insert_ticket(\"Parasite\", \"Independent\", \"Row 3 Seat 7\", \"Charlie\")\n#\n#     # Search tickets\n#     print(\"\\nSearching for Alice's tickets:\")\n#     alice_tickets = db.search_tickets_by_customer(\"Alice\")\n#     if alice_tickets:\n#         for ticket in alice_tickets:\n#             print(ticket)\n#     else:\n#         print(\"No tickets found for Alice.\")\n#\n#     print(\"\\nSearching for Bob's tickets:\")\n#     bob_tickets = db.search_tickets_by_customer(\"Bob\")\n#     if bob_tickets:\n#         for ticket in bob_tickets:\n#             print(ticket)\n#     else:\n#         print(\"No tickets found for Bob.\")\n#\n#     print(\"\\nSearching for David's tickets:\")\n#     david_tickets = db.search_tickets_by_customer(\"David\")\n#     if david_tickets:\n#         for ticket in david_tickets:\n#             print(ticket)\n#     else:\n#         print(\"No tickets found for David.\")\n#\n#     # Assume Alice's first ticket ID is the first one found\n#     if alice_tickets:\n#         ticket_id_to_delete = alice_tickets[0][0] # Get the ID from the first result tuple\n#         print(f\"\\nDeleting ticket with ID: {ticket_id_to_delete}\")\n#         db.delete_ticket(ticket_id_to_delete)\n#\n#         # Verify deletion\n#         print(\"\\nSearching for Alice's tickets after deletion:\")\n#         alice_tickets_after_delete = db.search_tickets_by_customer(\"Alice\")\n#         if alice_tickets_after_delete:\n#              for ticket in alice_tickets_after_delete:\n#                  print(ticket)\n#         else:\n#              print(\"No tickets found for Alice after deletion.\") # Should show only one ticket left\n#\n#     # Attempt to delete a non-existent ticket\n#     print(\"\\nAttempting to delete ticket with ID 999:\")\n#     db.delete_ticket(999)\n#\n#     # Close the connection\n#     db.close()\n```",
      "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = None\n        self.cursor = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            self.create_table()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            # Depending on the application, you might want to raise the exception\n            # raise\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        if not self.connection or not self.cursor:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS tickets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        if not self.connection or not self.cursor:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute('''\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            ''', (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error inserting ticket: {e}\")\n            if self.connection:\n                self.connection.rollback() # Rollback changes if insertion fails\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        if not self.connection or not self.cursor:\n            print(\"Database connection not established.\")\n            return []\n\n        try:\n            self.cursor.execute('''\n                SELECT id, movie_name, theater_name, seat_number, customer_name\n                FROM tickets\n                WHERE customer_name = ?\n            ''', (customer_name,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Error searching for tickets: {e}\")\n            return []\n\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        if not self.connection or not self.cursor:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute('''\n                DELETE FROM tickets WHERE id = ?\n            ''', (ticket_id,))\n            self.connection.commit()\n            # Optional: check if any row was actually deleted\n            # if self.cursor.rowcount == 0:\n            #     print(f\"No ticket found with ID {ticket_id}\")\n            # else:\n            #     print(f\"Ticket with ID {ticket_id} deleted successfully.\")\n        except sqlite3.Error as e:\n            print(f\"Error deleting ticket: {e}\")\n            if self.connection:\n                self.connection.rollback()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n\n    def __del__(self):\n        \"\"\"\n        Ensures the connection is closed when the object is garbage collected.\n        (Less reliable than explicit close or context manager)\n        \"\"\"\n        self.close()\n\n# Example usage (optional, for testing purposes):\nif __name__ == '__main__':\n    # Use an in-memory database for simple testing\n    db = MovieTicketDB(\":memory:\")\n\n    if db.connection: # Check if connection was successful\n        print(\"Database connected successfully.\")\n\n        # Insert some tickets\n        db.insert_ticket(\"Inception\", \"CinemaPlus\", \"C10\", \"Alice Wonderland\")\n        db.insert_ticket(\"The Matrix\", \"MovieWorld\", \"A5\", \"Bob The Builder\")\n        db.insert_ticket(\"Inception\", \"CinemaPlus\", \"C11\", \"Alice Wonderland\")\n        db.insert_ticket(\"Pulp Fiction\", \"GrandCinema\", \"F1\", \"Charlie Chaplin\")\n\n        print(\"\\nInserted tickets.\")\n\n        # Search for tickets by customer name\n        alice_tickets = db.search_tickets_by_customer(\"Alice Wonderland\")\n        print(\"\\nTickets for Alice Wonderland:\")\n        for ticket in alice_tickets:\n            print(ticket)\n\n        bob_tickets = db.search_tickets_by_customer(\"Bob The Builder\")\n        print(\"\\nTickets for Bob The Builder:\")\n        for ticket in bob_tickets:\n            print(ticket)\n\n        # Search for a non-existent customer\n        nonexistent_tickets = db.search_tickets_by_customer(\"David\")\n        print(\"\\nTickets for David:\")\n        print(nonexistent_tickets)\n\n        # Delete a ticket\n        if alice_tickets:\n            ticket_to_delete_id = alice_tickets[0][0] # Get the ID of the first ticket found for Alice\n            print(f\"\\nDeleting ticket with ID: {ticket_to_delete_id}\")\n            db.delete_ticket(ticket_to_delete_id)\n\n            # Search again for Alice to see the change\n            print(\"\\nTickets for Alice Wonderland after deletion:\")\n            alice_tickets_after_delete = db.search_tickets_by_customer(\"Alice Wonderland\")\n            for ticket in alice_tickets_after_delete:\n                print(ticket)\n\n        # Close the connection\n        db.close()\n        print(\"\\nDatabase connection closed.\")\n    else:\n        print(\"\\nFailed to connect to the database.\")\n```",
      "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS tickets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            ''', (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error inserting ticket: {e}\")\n            self.connection.rollback() # Rollback changes if insertion fails\n\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\":memory:\") # Use in-memory DB for test\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        >>> len(result)\n        1\n        >>> ticket_db.insert_ticket(\"Movie B\", \"Theater 2\", \"B5\", \"Jane Smith\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        >>> len(result)\n        1\n        >>> ticket_db.insert_ticket(\"Movie C\", \"Theater 3\", \"C10\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        >>> len(result)\n        2\n        >>> ticket_db.close() # Clean up test DB connection\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                SELECT id, movie_name, theater_name, seat_number, customer_name\n                FROM tickets\n                WHERE customer_name = ?\n            ''', (customer_name,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Error searching tickets: {e}\")\n            return []\n\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                DELETE FROM tickets\n                WHERE id = ?\n            ''', (ticket_id,))\n            self.connection.commit()\n            # Optionally, check if any row was deleted\n            if self.cursor.rowcount == 0:\n                print(f\"No ticket found with ID {ticket_id}\")\n        except sqlite3.Error as e:\n            print(f\"Error deleting ticket: {e}\")\n            self.connection.rollback() # Rollback changes if deletion fails\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        try:\n            self.connection.close()\n        except sqlite3.Error as e:\n            print(f\"Error closing connection: {e}\")\n\n# Example Usage (Optional - you can add this to test the class)\nif __name__ == \"__main__\":\n    db_file = \"movie_tickets.db\"\n    ticket_db = MovieTicketDB(db_file)\n\n    # Insert some tickets\n    print(\"Inserting tickets...\")\n    ticket_db.insert_ticket(\"Inception\", \"Grand Cinema\", \"D5\", \"Alice Wonderland\")\n    ticket_db.insert_ticket(\"Matrix\", \"IMAX Dome\", \"F10\", \"Bob Thebuilder\")\n    ticket_db.insert_ticket(\"Inception\", \"Grand Cinema\", \"D6\", \"Alice Wonderland\")\n\n    # Search for tickets by customer\n    print(\"\\nSearching for tickets for Alice Wonderland:\")\n    alice_tickets = ticket_db.search_tickets_by_customer(\"Alice Wonderland\")\n    for ticket in alice_tickets:\n        print(ticket)\n\n    print(\"\\nSearching for tickets for Bob Thebuilder:\")\n    bob_tickets = ticket_db.search_tickets_by_customer(\"Bob Thebuilder\")\n    for ticket in bob_tickets:\n        print(ticket)\n\n    print(\"\\nSearching for tickets for Charlie Brown:\")\n    charlie_tickets = ticket_db.search_tickets_by_customer(\"Charlie Brown\")\n    print(charlie_tickets) # Should be empty list\n\n    # Delete a ticket (need to get an ID first, e.g., from search results)\n    if alice_tickets:\n        ticket_id_to_delete = alice_tickets[0][0] # Get ID of the first ticket for Alice\n        print(f\"\\nDeleting ticket with ID: {ticket_id_to_delete}\")\n        ticket_db.delete_ticket(ticket_id_to_delete)\n\n        # Verify deletion\n        print(\"\\nSearching for tickets for Alice Wonderland after deletion:\")\n        alice_tickets_after_delete = ticket_db.search_tickets_by_customer(\"Alice Wonderland\")\n        for ticket in alice_tickets_after_delete:\n             print(ticket)\n        if not alice_tickets_after_delete:\n             print(\"No tickets found for Alice Wonderland (after deleting one).\")\n\n\n    # Delete a non-existent ticket\n    print(\"\\nAttempting to delete non-existent ticket (ID 999):\")\n    ticket_db.delete_ticket(999)\n\n\n    # Close the connection\n    ticket_db.close()\n    print(\"\\nDatabase connection closed.\")\n\n    # To verify the data persists, you could uncomment these lines and run again\n    # ticket_db_reload = MovieTicketDB(db_file)\n    # print(\"\\nSearching after reopening DB:\")\n    # alice_tickets_reloaded = ticket_db_reload.search_tickets_by_customer(\"Alice Wonderland\")\n    # for ticket in alice_tickets_reloaded:\n    #      print(ticket)\n    # ticket_db_reload.close()\n```",
      "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = None\n        self.cursor = None\n        self.connect()\n        self.create_table()\n\n    def connect(self):\n        \"\"\"Establishes a connection to the database.\"\"\"\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n            self.cursor = self.connection.cursor()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            self.connection = None\n            self.cursor = None\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS tickets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute('''\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            ''', (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n            print(f\"Ticket inserted for {customer_name} for movie '{movie_name}'.\")\n        except sqlite3.Error as e:\n            print(f\"Error inserting ticket: {e}\")\n\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> # Example Usage (requires running this script or similar setup)\n        >>> # ticket_db = MovieTicketDB(\":memory:\") # Use in-memory db for testing\n        >>> # ticket_db.create_table() # ensure table exists\n        >>> # ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> # result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        >>> # print(len(result)) # Expected output: 1\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return []\n\n        try:\n            self.cursor.execute('''\n                SELECT id, movie_name, theater_name, seat_number, customer_name\n                FROM tickets\n                WHERE customer_name = ?\n            ''', (customer_name,))\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"Error searching tickets: {e}\")\n            return []\n\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        if not self.connection:\n            print(\"Database connection not established.\")\n            return\n\n        try:\n            self.cursor.execute('DELETE FROM tickets WHERE id = ?', (ticket_id,))\n            self.connection.commit()\n            if self.cursor.rowcount > 0:\n                print(f\"Ticket with ID {ticket_id} deleted successfully.\")\n            else:\n                print(f\"No ticket found with ID {ticket_id}.\")\n        except sqlite3.Error as e:\n            print(f\"Error deleting ticket: {e}\")\n\n    def close(self):\n        \"\"\"Closes the database connection.\"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n            print(\"Database connection closed.\")\n\n    def __del__(self):\n        \"\"\"Ensures the connection is closed when the object is garbage collected.\"\"\"\n        self.close()\n\n\n# Example usage (optional - uncomment to run)\nif __name__ == \"__main__\":\n    # Create a database in memory for testing\n    ticket_db = MovieTicketDB(\":memory:\")\n\n    # Insert some tickets\n    ticket_db.insert_ticket(\"Inception\", \"AMC 10\", \"D15\", \"Alice Smith\")\n    ticket_db.insert_ticket(\"The Matrix\", \"Regal Cinema\", \"B7\", \"Bob Johnson\")\n    ticket_db.insert_ticket(\"Inception\", \"AMC 10\", \"D16\", \"Bob Johnson\")\n    ticket_db.insert_ticket(\"Parasite\", \"Local Theater\", \"C3\", \"Alice Smith\")\n\n    # Search for tickets by customer name\n    print(\"\\nSearching for Alice Smith's tickets:\")\n    alice_tickets = ticket_db.search_tickets_by_customer(\"Alice Smith\")\n    if alice_tickets:\n        for ticket in alice_tickets:\n            print(ticket) # Output format: (id, movie_name, theater_name, seat_number, customer_name)\n    else:\n        print(\"No tickets found for Alice Smith.\")\n\n    print(\"\\nSearching for Bob Johnson's tickets:\")\n    bob_tickets = ticket_db.search_tickets_by_customer(\"Bob Johnson\")\n    if bob_tickets:\n        for ticket in bob_tickets:\n            print(ticket)\n    else:\n        print(\"No tickets found for Bob Johnson.\")\n\n    # Search for a customer with no tickets\n    print(\"\\nSearching for Charlie Brown's tickets:\")\n    charlie_tickets = ticket_db.search_tickets_by_customer(\"Charlie Brown\")\n    if charlie_tickets:\n        for ticket in charlie_tickets:\n            print(ticket)\n    else:\n        print(\"No tickets found for Charlie Brown.\")\n\n    # Delete a ticket (let's assume the first ticket inserted had ID 1)\n    # We need to search first to get an ID\n    print(\"\\nDeleting a ticket...\")\n    first_alice_ticket = ticket_db.search_tickets_by_customer(\"Alice Smith\")\n    if first_alice_ticket:\n         ticket_id_to_delete = first_alice_ticket[0][0] # Get the ID of the first result\n         print(f\"Attempting to delete ticket with ID: {ticket_id_to_delete}\")\n         ticket_db.delete_ticket(ticket_id_to_delete)\n\n    # Verify deletion\n    print(\"\\nSearching for Alice Smith's tickets after deletion:\")\n    alice_tickets_after_delete = ticket_db.search_tickets_by_customer(\"Alice Smith\")\n    if alice_tickets_after_delete:\n        for ticket in alice_tickets_after_delete:\n            print(ticket)\n    else:\n        print(\"No tickets found for Alice Smith (or the one was deleted).\")\n\n\n    # Delete a non-existent ticket\n    print(\"\\nAttempting to delete non-existent ticket ID 99:\")\n    ticket_db.delete_ticket(99)\n\n\n    # Close the connection explicitly\n    ticket_db.close()\n```"
    ]
  },
  {
    "task_id": "ClassEval_79",
    "skeleton": "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"",
    "test": "import unittest\n\nclass SQLGeneratorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1;\")\n\n    def test_select_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1', 'field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1, field4 = value2\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1, field4 = value2;\")\n\n    def test_select_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1, field3 = value2\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1, field3 = value2;\")\n\n    def test_select_6(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'])\n        self.assertEqual(result, \"SELECT field1 FROM table1;\")\n\n\n\nclass SQLGeneratorTestInsert(unittest.TestCase):\n    def test_insert(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2) VALUES ('value1', 'value2');\")\n\n    def test_insert_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2, field3) VALUES ('value1', 'value2', 'value3');\")\n\n    def test_insert_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4) VALUES ('value1', 'value2', 'value3', 'value4');\")\n\n    def test_insert_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5) VALUES ('value1', 'value2', 'value3', 'value4', 'value5');\")\n\n    def test_insert_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5', 'field6': 'value6'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5, field6) VALUES ('value1', 'value2', 'value3', 'value4', 'value5', 'value6');\")\n\nclass SQLGeneratorTestUpdate(unittest.TestCase):\n    def test_update(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\")\n\n    def test_update_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3'},\n                            \"field4 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3' WHERE field4 = value1;\")\n\n    def test_update_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4'}, \"field5 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4' WHERE field5 = value1;\")\n\n    def test_update_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5'}, \"field6 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5' WHERE field6 = value1;\")\n\n    def test_update_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5', 'field6': 'new_value6'},\n                            \"field7 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5', field6 = 'new_value6' WHERE field7 = value1;\")\n\nclass SQLGeneratorTestDelete(unittest.TestCase):\n    def test_delete(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1;\")\n\n    def test_delete_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2;\")\n\n    def test_delete_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3;\")\n\n    def test_delete_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4;\")\n\n    def test_delete_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5;\")\n\nclass SQLGeneratorTestSelectFemaleUnderAge(unittest.TestCase):\n    def test_select_female_under_age(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\")\n\n    def test_select_female_under_age_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(40)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 40 AND gender = 'female';\")\n\n    def test_select_female_under_age_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(20)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 20 AND gender = 'female';\")\n\n    def test_select_female_under_age_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(10)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 10 AND gender = 'female';\")\n\n    def test_select_female_under_age_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(50)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 50 AND gender = 'female';\")\n\nclass SQLGeneratorTestSelectByAgeRange(unittest.TestCase):\n    def test_select_by_age_range(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(20, 30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\")\n\n    def test_select_by_age_range_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(10, 20)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 10 AND 20;\")\n\n    def test_select_by_age_range_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(30, 40)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 30 AND 40;\")\n\n    def test_select_by_age_range_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(40, 50)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 40 AND 50;\")\n\n    def test_select_by_age_range_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(50, 60)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 50 AND 60;\")\n\n\nclass SQLGeneratorTestMain(unittest.TestCase):\n    def test_main(self):\n        sql = SQLGenerator('table1')\n        self.assertEqual(sql.select(['field1', 'field2'], \"field3 = value1\"),\n                         \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n        self.assertEqual(sql.insert({'field1': 'value1', 'field2': 'value2'}),\n                         \"INSERT INTO table1 (field1, field2) VALUES ('value1', 'value2');\")\n        self.assertEqual(sql.update({'field1': 'new_value1', 'field2': 'new_value2'},\n                                    \"field3 = value1\"),\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\")\n        self.assertEqual(sql.delete(\"field1 = value1\"),\n                         \"DELETE FROM table1 WHERE field1 = value1;\")\n        self.assertEqual(sql.select_female_under_age(30),\n                         \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\")\n        self.assertEqual(sql.select_by_age_range(20, 30),\n                         \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\")",
    "solution_code": "class SQLGenerator:\n    def __init__(self, table_name):\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition):\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n",
    "class_name": "SQLGenerator",
    "test_classes": [
      "SQLGeneratorTestSelect",
      "SQLGeneratorTestInsert",
      "SQLGeneratorTestUpdate",
      "SQLGeneratorTestDelete",
      "SQLGeneratorTestSelectFemaleUnderAge",
      "SQLGeneratorTestSelectByAgeRange",
      "SQLGeneratorTestMain"
    ],
    "class_constructor": "class SQLGenerator: \n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n",
    "fields": [
      "self.table_name"
    ],
    "methods_info": [
      {
        "method_name": "select",
        "method_description": "def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"",
        "test_class": "SQLGeneratorTestSelect",
        "test_code": "class SQLGeneratorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1;\")\n\n    def test_select_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1', 'field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1;\")\n\n    def test_select_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1, field2'], \"field3 = value1, field4 = value2\")\n        self.assertEqual(result, \"SELECT field1, field2 FROM table1 WHERE field3 = value1, field4 = value2;\")\n\n    def test_select_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'], \"field2 = value1, field3 = value2\")\n        self.assertEqual(result, \"SELECT field1 FROM table1 WHERE field2 = value1, field3 = value2;\")\n\n    def test_select_6(self):\n        sql = SQLGenerator('table1')\n        result = sql.select(['field1'])\n        self.assertEqual(result, \"SELECT field1 FROM table1;\")",
        "solution_code": "def select(self, fields=None, condition=None):\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert",
        "method_description": "def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"",
        "test_class": "SQLGeneratorTestInsert",
        "test_code": "class SQLGeneratorTestInsert(unittest.TestCase):\n    def test_insert(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2) VALUES ('value1', 'value2');\")\n\n    def test_insert_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3'})\n        self.assertEqual(result, \"INSERT INTO table1 (field1, field2, field3) VALUES ('value1', 'value2', 'value3');\")\n\n    def test_insert_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4) VALUES ('value1', 'value2', 'value3', 'value4');\")\n\n    def test_insert_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5) VALUES ('value1', 'value2', 'value3', 'value4', 'value5');\")\n\n    def test_insert_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.insert({'field1': 'value1', 'field2': 'value2', 'field3': 'value3', 'field4': 'value4',\n                             'field5': 'value5', 'field6': 'value6'})\n        self.assertEqual(result,\n                         \"INSERT INTO table1 (field1, field2, field3, field4, field5, field6) VALUES ('value1', 'value2', 'value3', 'value4', 'value5', 'value6');\")",
        "solution_code": "def insert(self, data):\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "update",
        "method_description": "def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"",
        "test_class": "SQLGeneratorTestUpdate",
        "test_code": "class SQLGeneratorTestUpdate(unittest.TestCase):\n    def test_update(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\")\n\n    def test_update_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3'},\n                            \"field4 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3' WHERE field4 = value1;\")\n\n    def test_update_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4'}, \"field5 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4' WHERE field5 = value1;\")\n\n    def test_update_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5'}, \"field6 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5' WHERE field6 = value1;\")\n\n    def test_update_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.update({'field1': 'new_value1', 'field2': 'new_value2', 'field3': 'new_value3',\n                             'field4': 'new_value4', 'field5': 'new_value5', 'field6': 'new_value6'},\n                            \"field7 = value1\")\n        self.assertEqual(result,\n                         \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2', field3 = 'new_value3', field4 = 'new_value4', field5 = 'new_value5', field6 = 'new_value6' WHERE field7 = value1;\")",
        "solution_code": "def update(self, data, condition):\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete",
        "method_description": "def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"",
        "test_class": "SQLGeneratorTestDelete",
        "test_code": "class SQLGeneratorTestDelete(unittest.TestCase):\n    def test_delete(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1;\")\n\n    def test_delete_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2;\")\n\n    def test_delete_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3\")\n        self.assertEqual(result, \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3;\")\n\n    def test_delete_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4;\")\n\n    def test_delete_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.delete(\"field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5\")\n        self.assertEqual(result,\n                         \"DELETE FROM table1 WHERE field1 = value1 AND field2 = value2 AND field3 = value3 AND field4 = value4 AND field5 = value5;\")",
        "solution_code": "def delete(self, condition):\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.table_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "select_female_under_age",
        "method_description": "def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"",
        "test_class": "SQLGeneratorTestSelectFemaleUnderAge",
        "test_code": "class SQLGeneratorTestSelectFemaleUnderAge(unittest.TestCase):\n    def test_select_female_under_age(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\")\n\n    def test_select_female_under_age_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(40)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 40 AND gender = 'female';\")\n\n    def test_select_female_under_age_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(20)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 20 AND gender = 'female';\")\n\n    def test_select_female_under_age_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(10)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 10 AND gender = 'female';\")\n\n    def test_select_female_under_age_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_female_under_age(50)\n        self.assertEqual(result,\"SELECT * FROM table1 WHERE age < 50 AND gender = 'female';\")",
        "solution_code": "def select_female_under_age(self, age):\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "select"
          ]
        }
      },
      {
        "method_name": "select_by_age_range",
        "method_description": "def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"",
        "test_class": "SQLGeneratorTestSelectByAgeRange",
        "test_code": "class SQLGeneratorTestSelectByAgeRange(unittest.TestCase):\n    def test_select_by_age_range(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(20, 30)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;\")\n\n    def test_select_by_age_range_2(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(10, 20)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 10 AND 20;\")\n\n    def test_select_by_age_range_3(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(30, 40)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 30 AND 40;\")\n\n    def test_select_by_age_range_4(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(40, 50)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 40 AND 50;\")\n\n    def test_select_by_age_range_5(self):\n        sql = SQLGenerator('table1')\n        result = sql.select_by_age_range(50, 60)\n        self.assertEqual(result, \"SELECT * FROM table1 WHERE age BETWEEN 50 AND 60;\")",
        "solution_code": "def select_by_age_range(self, min_age, max_age):\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "select"
          ]
        }
      }
    ],
    "predict": [
      "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        if not isinstance(table_name, str) or not table_name:\n            raise ValueError(\"Table name must be a non-empty string.\")\n        self.table_name = table_name\n\n    def _quote_value(self, value):\n        \"\"\"\n        Helper method to appropriately quote values for SQL statements.\n        Handles strings by adding single quotes. Does not handle complex types or escaping\n        of quotes within strings (a limitation for simplicity as per examples).\n        \"\"\"\n        if isinstance(value, str):\n            # Simple quoting for strings. Does not handle escaping internal quotes.\n            return f\"'{value}'\"\n        elif value is None:\n            return 'NULL'\n        else:\n            # Assume numbers, booleans, etc., don't need quotes (or DB handles bool mapping)\n            return str(value)\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        >>> sql.select(condition='id = 1')\n        'SELECT * FROM table1 WHERE id = 1;'\n        >>> sql.select(['field1'])\n        'SELECT field1 FROM table1;'\n        >>> sql.select()\n        'SELECT * FROM table1;'\n        \"\"\"\n        fields_str = \"*\" if fields is None else \", \".join(fields)\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Added for test case\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        >>> sql.insert({'id': 123, 'name': 'Test'})\n        \"INSERT INTO table1 (id, name) VALUES (123, 'Test');\"\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for INSERT.\")\n\n        fields = data.keys()\n        values = [self._quote_value(data[field]) for field in fields]\n\n        fields_str = \", \".join(fields)\n        values_str = \", \".join(values)\n\n        sql = f\"INSERT INTO {self.table_name} ({fields_str}) VALUES ({values_str});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Added for test case\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        >>> sql.update({'count': 10, 'status': 'active'}, \"id = 5\")\n        \"UPDATE table1 SET count = 10, status = 'active' WHERE id = 5;\"\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for UPDATE.\")\n        if not condition:\n             raise ValueError(\"Condition cannot be empty for UPDATE.\")\n\n        set_parts = [f\"{field} = {self._quote_value(value)}\" for field, value in data.items()]\n        set_str = \", \".join(set_parts)\n\n        sql = f\"UPDATE {self.table_name} SET {set_str} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Added for test case\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        >>> sql.delete(\"id > 100\")\n        'DELETE FROM table1 WHERE id > 100;'\n        \"\"\"\n        if not condition:\n             raise ValueError(\"Condition cannot be empty for DELETE.\")\n\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Added for test case\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        >>> sql.select_female_under_age(25)\n        \"SELECT * FROM table1 WHERE age < 25 AND gender = 'female';\"\n        \"\"\"\n        if not isinstance(age, int) or age < 0:\n             raise ValueError(\"Age must be a non-negative integer.\")\n\n        # Note: 'female' is quoted as per the example\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition) # Re-use the select method\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Added for test case\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        >>> sql.select_by_age_range(18, 65)\n        'SELECT * FROM table1 WHERE age BETWEEN 18 AND 65;'\n        \"\"\"\n        if not isinstance(min_age, int) or not isinstance(max_age, int) or min_age < 0 or max_age < min_age:\n             raise ValueError(\"min_age and max_age must be non-negative integers and min_age <= max_age.\")\n\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition) # Re-use the select method\n\n```",
      "```python\nimport json\n\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    Note: This generator produces raw SQL strings. For production environments, consider using parameterized queries or ORMs to prevent SQL injection vulnerabilities.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        if not isinstance(table_name, str) or not table_name:\n             raise ValueError(\"Table name must be a non-empty string.\")\n        self.table_name = table_name\n\n    def _format_value(self, value):\n        \"\"\"\n        Formats a value for inclusion in a SQL string, adding quotes around strings.\n        Handles basic types. More complex types might require database-specific handling.\n        \"\"\"\n        if isinstance(value, str):\n            # Basic escaping for single quotes within strings\n            escaped_value = value.replace(\"'\", \"''\")\n            return f\"'{escaped_value}'\"\n        elif isinstance(value, (int, float)):\n            return str(value)\n        elif isinstance(value, bool):\n            # Represent booleans appropriately (e.g., 1/0, TRUE/FALSE) - here using common representation\n            return 'TRUE' if value else 'FALSE'\n        elif value is None:\n            return 'NULL'\n        # Add more type handling as needed (e.g., date, time)\n        else:\n             # Attempt a generic string representation, quoting it\n             return f\"'{str(value).replace(\"'\", \"''\")}'\"\n\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'field3 = value1') # Fixed example typo 'filed3' -> 'field3'\n        'SELECT field1, field2 FROM table1 WHERE field3 = value1;'\n        >>> sql.select()\n        'SELECT * FROM table1;'\n        >>> sql.select(condition=\"id > 10\")\n        'SELECT * FROM table1 WHERE id > 10;'\n        \"\"\"\n        fields_str = \", \".join(fields) if fields else \"*\"\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Re-initialize sql for independent example\n        >>> sql.insert({'key1': 'value1', 'key2': 123, 'key3': None})\n        \"INSERT INTO table1 (key1, key2, key3) VALUES ('value1', 123, NULL);\"\n        >>> sql.insert({}) # Example with empty data\n        \"INSERT INTO table1 () VALUES ();\"\n        \"\"\"\n        if not isinstance(data, dict):\n             raise TypeError(\"Data for INSERT must be a dictionary.\")\n\n        fields = list(data.keys())\n        values = [self._format_value(data[field]) for field in fields]\n\n        fields_str = \", \".join(fields)\n        values_str = \", \".join(values)\n\n        sql = f\"INSERT INTO {self.table_name} ({fields_str}) VALUES ({values_str});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Re-initialize sql for independent example\n        >>> sql.update({'field1': 'new_value1', 'field2': 456, 'field3': True}, \"field_id = 7\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 456, field3 = TRUE WHERE field_id = 7;\"\n        >>> sql.update({}, \"id = 5\") # Example with empty data - results in no SET clause\n        \"UPDATE table1 WHERE id = 5;\"\n        \"\"\"\n        if not isinstance(data, dict):\n             raise TypeError(\"Data for UPDATE must be a dictionary.\")\n        if not isinstance(condition, str) or not condition:\n             raise ValueError(\"Condition for UPDATE must be a non-empty string.\")\n\n        set_parts = [f\"{field} = {self._format_value(value)}\" for field, value in data.items()]\n        set_clause = \", \".join(set_parts)\n\n        sql = f\"UPDATE {self.table_name}\"\n        if set_clause: # Only add SET clause if there's data to update\n             sql += f\" SET {set_clause}\"\n        sql += f\" WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Re-initialize sql for independent example\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        >>> sql.delete(\"status = 'inactive'\")\n        \"DELETE FROM table1 WHERE status = 'inactive';\"\n        \"\"\"\n        if not isinstance(condition, str) or not condition:\n             raise ValueError(\"Condition for DELETE must be a non-empty string.\")\n\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        Assumes table has 'age' and 'gender' columns.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('users') # Re-initialize sql for independent example\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM users WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        if not isinstance(age, int) or age < 0:\n             raise ValueError(\"Age must be a non-negative integer.\")\n\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        Assumes table has an 'age' column.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('users') # Re-initialize sql for independent example\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM users WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        if not isinstance(min_age, int) or not isinstance(max_age, int) or min_age < 0 or max_age < min_age:\n             raise ValueError(\"Ages must be non-negative integers, and min_age cannot be greater than max_age.\")\n\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n\n# Example usage and doctests execution (optional, for testing)\nif __name__ == '__main__':\n    import doctest\n    # Fix the typo in the first example within the docstring for select\n    # The original was: >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n    # Correcting it for the doctest to pass if run directly on the file\n    SQLGenerator.select.__doc__ = SQLGenerator.select.__doc__.replace(\"'filed3\", \"'field3\")\n\n    doctest.testmod(verbose=True)\n\n    # Additional manual tests\n    print(\"\\n--- Manual Tests ---\")\n    sql = SQLGenerator('products')\n\n    print(sql.select())\n    print(sql.select(['name', 'price']))\n    print(sql.select(condition=\"price > 100\"))\n    print(sql.select(['name'], condition=\"category = 'electronics'\"))\n\n    print(sql.insert({'name': 'Laptop', 'price': 1200.50, 'in_stock': True, 'description': \"15.6' screen\"}))\n    print(sql.insert({'product_id': 101}))\n\n    print(sql.update({'price': 1150.00, 'in_stock': False}, \"name = 'Laptop'\"))\n    print(sql.update({'description': 'Updated info'}, \"product_id = 101\"))\n\n    print(sql.delete(\"price < 50\"))\n    print(sql.delete(\"in_stock = FALSE\"))\n\n    user_sql = SQLGenerator('users')\n    print(user_sql.select_female_under_age(25))\n    print(user_sql.select_by_age_range(18, 65))\n\n    # Example with special characters in string values\n    product_sql = SQLGenerator('products')\n    print(product_sql.insert({'name': \"O'Reilly Book\", 'description': \"It's a good read\"}))\n    print(product_sql.update({'name': \"O''Malley's Item\"}, \"product_id = 201\"))\n```",
      "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def _format_value(self, value):\n        \"\"\"\n        Formats a Python value into its SQL string representation.\n        Handles strings, numbers, booleans, and None.\n        \"\"\"\n        if isinstance(value, str):\n            # Escape single quotes within the string\n            escaped_value = value.replace(\"'\", \"''\")\n            return f\"'{escaped_value}'\"\n        elif isinstance(value, (int, float)):\n            return str(value)\n        elif isinstance(value, bool):\n            # SQL boolean representation can vary (TRUE/FALSE, 1/0). Using standard.\n            return 'TRUE' if value else 'FALSE'\n        elif value is None:\n            return 'NULL'\n        else:\n            # Fallback for other types, treat as string and quote\n            escaped_value = str(value).replace(\"'\", \"''\")\n            return f\"'{escaped_value}'\"\n\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n        if fields is None or not fields:\n            fields_str = \"*\"\n        else:\n            fields_str = \", \".join(fields)\n\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n\n        if condition:\n            sql += f\" WHERE {condition}\"\n\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Assuming this was missing in the original docstring example\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        >>> sql.insert({'id': 123, 'name': 'O''Reilly'}) # Example with integer and escaped quote\n        \"INSERT INTO table1 (id, name) VALUES (123, 'O''Reilly');\"\n        >>> sql.insert({'active': True, 'score': 95.5, 'description': None}) # Example with bool, float, None\n        \"INSERT INTO table1 (active, score, description) VALUES (TRUE, 95.5, NULL);\"\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for INSERT statement.\")\n\n        fields = data.keys()\n        values = [self._format_value(data[field]) for field in fields]\n\n        fields_str = \", \".join(fields)\n        values_str = \", \".join(values)\n\n        sql = f\"INSERT INTO {self.table_name} ({fields_str}) VALUES ({values_str});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Assuming this was missing in the original docstring example\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        >>> sql.update({'count': 10, 'status': 'processed'}, \"id = 5\") # Example with integer value\n        \"UPDATE table1 SET count = 10, status = 'processed' WHERE id = 5;\"\n        >>> sql.update({'is_valid': False, 'data': None}, \"name = 'test'\") # Example with boolean and None values\n        \"UPDATE table1 SET is_valid = FALSE, data = NULL WHERE name = 'test';\"\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for UPDATE statement.\")\n        if not condition:\n             raise ValueError(\"Condition cannot be empty for UPDATE statement.\")\n\n        set_parts = [f\"{field} = {self._format_value(value)}\" for field, value in data.items()]\n        set_str = \", \".join(set_parts)\n\n        sql = f\"UPDATE {self.table_name} SET {set_str} WHERE {condition};\"\n        return sql\n\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1') # Assuming this was missing in the original docstring example\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        >>> sql.delete(\"id > 100\") # Example with numeric condition\n        'DELETE FROM table1 WHERE id > 100;'\n        \"\"\"\n        if not condition:\n             raise ValueError(\"Condition cannot be empty for DELETE statement.\")\n\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('users') # Example using a more relevant table name\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM users WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        # Note: This assumes 'age' is numeric and 'gender' is a string field.\n        sql = f\"SELECT * FROM {self.table_name} WHERE age < {self._format_value(age)} AND gender = 'female';\"\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('users') # Example using a more relevant table name\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM users WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        # Note: This assumes 'age' is a numeric field.\n        sql = f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {self._format_value(min_age)} AND {self._format_value(max_age)};\"\n        return sql\n\n```",
      "```python\nimport json\n\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        if not isinstance(table_name, str) or not table_name:\n            raise ValueError(\"table_name must be a non-empty string\")\n        self.table_name = table_name\n\n    def _format_value(self, value):\n        \"\"\"\n        Formats a value for inclusion in a SQL statement.\n        Strings are quoted and escaped. None becomes NULL. Numbers are used directly.\n        This is a basic implementation and may need refinement for specific data types or SQL dialects.\n        \"\"\"\n        if value is None:\n            return \"NULL\"\n        elif isinstance(value, str):\n            # Escape single quotes by doubling them\n            escaped_value = value.replace(\"'\", \"''\")\n            return f\"'{escaped_value}'\"\n        elif isinstance(value, (int, float)):\n            return str(value)\n        # Add handling for other types like booleans, dates, etc. if needed\n        # For simplicity, treating other types as strings (can be problematic)\n        # A more robust solution might raise an error or handle specific types\n        else:\n             # Attempt to represent other types reasonably, maybe as strings or JSON?\n             # This is a point of potential weakness depending on the SQL dialect and data type.\n             # Let's default to string representation, but be aware this isn't universally safe.\n             try:\n                 # Try JSON encoding for complex types\n                 return f\"'{json.dumps(value).replace(\"'\", \"''\")}'\"\n             except TypeError:\n                  # Fallback to string representation if JSON encoding fails\n                  return f\"'{str(value).replace(\"'\", \"''\")}'\"\n\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'field3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE field3 = value1;'\n        >>> sql.select()\n        'SELECT * FROM table1;'\n        >>> sql.select(condition='id > 10')\n        'SELECT * FROM table1 WHERE id > 10;'\n        \"\"\"\n        select_fields = \"*\"\n        if fields:\n            if not isinstance(fields, list):\n                 raise TypeError(\"fields must be a list or None\")\n            select_fields = \", \".join(fields)\n\n        sql = f\"SELECT {select_fields} FROM {self.table_name}\"\n\n        if condition:\n            if not isinstance(condition, str):\n                 raise TypeError(\"condition must be a string or None\")\n            sql += f\" WHERE {condition}\"\n\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.insert({'key1': 'value1', 'key2': 123, 'key3': None})\n        \"INSERT INTO table1 (key1, key2, key3) VALUES ('value1', 123, NULL);\"\n        >>> sql.insert({})\n        Traceback (most recent call last):\n        ...\n        ValueError: Data dictionary cannot be empty for INSERT statement.\n        \"\"\"\n        if not isinstance(data, dict):\n             raise TypeError(\"data must be a dictionary\")\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for INSERT statement.\")\n\n        fields = \", \".join(data.keys())\n        values = \", \".join(self._format_value(v) for v in data.values())\n\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values});\"\n        return sql\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.update({'field1': 'new_value1', 'field2': 999}, \"field3 = 'some_id'\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 999 WHERE field3 = 'some_id';\"\n        >>> sql.update({}, \"field3 = 'some_id'\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Data dictionary cannot be empty for UPDATE statement.\n        >>> sql.update({'field1': 'value'}, None)\n        Traceback (most recent call last):\n        ...\n        ValueError: Condition cannot be empty or None for UPDATE statement to prevent unintended full table updates.\n        \"\"\"\n        if not isinstance(data, dict):\n             raise TypeError(\"data must be a dictionary\")\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for UPDATE statement.\")\n        if not isinstance(condition, str) or not condition.strip():\n            raise ValueError(\"Condition cannot be empty or None for UPDATE statement to prevent unintended full table updates.\")\n\n        set_clauses = \", \".join(f\"{k} = {self._format_value(v)}\" for k, v in data.items())\n\n        sql = f\"UPDATE {self.table_name} SET {set_clauses} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.delete(\"field1 = 'value1'\")\n        \"DELETE FROM table1 WHERE field1 = 'value1';\"\n        >>> sql.delete(None)\n        Traceback (most recent call last):\n        ...\n        ValueError: Condition cannot be empty or None for DELETE statement to prevent unintended full table deletions.\n        \"\"\"\n        if not isinstance(condition, str) or not condition.strip():\n            raise ValueError(\"Condition cannot be empty or None for DELETE statement to prevent unintended full table deletions.\")\n\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('users')\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM users WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        if not isinstance(age, int) or age < 0:\n            raise ValueError(\"age must be a non-negative integer\")\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(fields=None, condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('employees')\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM employees WHERE age BETWEEN 20 AND 30;'\n        >>> sql.select_by_age_range(30, 20)\n        Traceback (most recent call last):\n        ...\n        ValueError: min_age must be less than or equal to max_age\n        \"\"\"\n        if not isinstance(min_age, int) or min_age < 0:\n             raise ValueError(\"min_age must be a non-negative integer\")\n        if not isinstance(max_age, int) or max_age < 0:\n             raise ValueError(\"max_age must be a non-negative integer\")\n        if min_age > max_age:\n            raise ValueError(\"min_age must be less than or equal to max_age\")\n\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(fields=None, condition=condition)\n\n# Example Usage (as shown in docstrings)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n    # Manual Examples\n    sql = SQLGenerator('products')\n    print(\"\\nManual Examples:\")\n    print(sql.select(['product_name', 'price'], \"category = 'Electronics' AND price > 100\"))\n    print(sql.select())\n    print(sql.insert({'product_name': 'Laptop', 'price': 1200.50, 'in_stock': True, 'description': \"15.6'' screen\"}))\n    print(sql.update({'price': 1150, 'in_stock': False}, \"product_id = 101\"))\n    print(sql.delete(\"status = 'inactive'\"))\n\n    sql_users = SQLGenerator('users')\n    print(sql_users.select_female_under_age(25))\n    print(sql_users.select_by_age_range(18, 65))\n\n    # Example with None and special characters in value\n    print(sql.insert({'name': \"O'Malley\", 'description': \"It's null\", 'details': None}))\n```",
      "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def _format_value(self, value):\n        \"\"\"\n        Formats a Python value into its SQL string representation.\n        Adds single quotes around strings, handles None as NULL.\n        Does not handle complex types or SQL injection robustly.\n        \"\"\"\n        if isinstance(value, str):\n            # Simple quoting - WARNING: Does not handle internal quotes or escaping properly\n            return f\"'{value}'\"\n        elif isinstance(value, (int, float)):\n            return str(value)\n        elif value is None:\n            return 'NULL'\n        else:\n            # Default for other types, might need refinement based on database specifics\n            return str(value)\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        >>> sql.select()\n        'SELECT * FROM table1;'\n        >>> sql.select(condition='id = 5')\n        'SELECT * FROM table1 WHERE id = 5;'\n        \"\"\"\n        fields_str = '*'\n        if fields:\n            fields_str = ', '.join(fields)\n\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n\n        if condition:\n            sql += f\" WHERE {condition}\"\n\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.insert({'key1': 'value1', 'key2': 123, 'key3': None})\n        \"INSERT INTO table1 (key1, key2, key3) VALUES ('value1', 123, NULL);\"\n        \"\"\"\n        if not data:\n            # Cannot generate insert without data\n            return \"\"\n\n        fields = list(data.keys())\n        values = [self._format_value(data[field]) for field in fields]\n\n        fields_str = ', '.join(fields)\n        values_str = ', '.join(values)\n\n        sql = f\"INSERT INTO {self.table_name} ({fields_str}) VALUES ({values_str});\"\n        return sql\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.update({'field1': 'new_value1', 'field2': 456}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 456 WHERE field3 = value1;\"\n        \"\"\"\n        if not data or not condition:\n            # Need data and a condition for an update\n            return \"\"\n\n        set_parts = [f\"{field} = {self._format_value(value)}\" for field, value in data.items()]\n        set_str = ', '.join(set_parts)\n\n        sql = f\"UPDATE {self.table_name} SET {set_str} WHERE {condition};\"\n        return sql\n\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n        if not condition:\n            # Condition is usually required for delete to avoid deleting all records\n            # Returning empty string or raising error could be options.\n            # For this exercise, we'll assume condition is provided.\n             return \"\"\n\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        # Assuming 'age' and 'gender' are columns in the table\n        sql = f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        # Assuming 'age' is a column in the table\n        sql = f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n        return sql\n\n# Example Usage (based on docstrings)\nif __name__ == '__main__':\n    sql = SQLGenerator('users')\n\n    # Select examples\n    print(sql.select(['id', 'name'], \"status = 'active'\"))\n    print(sql.select())\n    print(sql.select(condition=\"registered_date > '2023-01-01'\"))\n\n    # Insert example\n    print(sql.insert({'name': 'Alice', 'age': 25, 'status': 'active', 'email': None}))\n\n    # Update example\n    print(sql.update({'status': 'inactive', 'age': 26}, \"name = 'Alice'\"))\n\n    # Delete example\n    print(sql.delete(\"status = 'inactive' AND age > 60\"))\n\n    # Specific select examples\n    print(sql.select_female_under_age(40))\n    print(sql.select_by_age_range(18, 65))\n\n    # Adding doctests for verification (can be run with `python -m doctest your_file_name.py`)\n    import doctest\n    doctest.testmod()\n```"
    ]
  },
  {
    "task_id": "ClassEval_80",
    "skeleton": "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"",
    "test": "import unittest\n\n\nclass SQLQueryBuilderTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\", \"name\"], {'age': 30}),\n            \"SELECT id, name FROM users WHERE age='30'\"\n        )\n\n    def test_select_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('students', [\"id\", \"name\"], {'age': 18}),\n            \"SELECT id, name FROM students WHERE age='18'\"\n        )\n\n    def test_select_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('items', [\"id\", \"name\"], {'price': 1.0}),\n            \"SELECT id, name FROM items WHERE price='1.0'\"\n        )\n\n    def test_select_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\"], {'age': 30}),\n            \"SELECT id FROM users WHERE age='30'\"\n        )\n\n    def test_select_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"], {'age': 30}),\n            \"SELECT name FROM users WHERE age='30'\"\n        )\n\n    def test_select_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"]),\n            \"SELECT name FROM users\"\n        )\n\n    def test_select_7(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', \"*\"),\n            \"SELECT * FROM users\"\n        )\n\n\nclass SQLQueryBuilderTestInsert(unittest.TestCase):\n    def test_insert_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30}),\n            \"INSERT INTO users (name, age) VALUES ('Tom', '30')\"\n        )\n\n    def test_insert_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('students', {'name': 'Tom', 'age': 18}),\n            \"INSERT INTO students (name, age) VALUES ('Tom', '18')\"\n        )\n\n    def test_insert_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('items', {'name': 'apple', 'price': 1.0}),\n            \"INSERT INTO items (name, price) VALUES ('apple', '1.0')\"\n        )\n\n    def test_insert_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom'}),\n            \"INSERT INTO users (name) VALUES ('Tom')\"\n        )\n\n    def test_insert_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30, 'region': 'USA'}),\n            \"INSERT INTO users (name, age, region) VALUES ('Tom', '30', 'USA')\"\n        )\n\n\nclass SQLQueryBuilderTestDetele(unittest.TestCase):\n    def test_delete_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('users', {'name': 'Tom'}),\n            \"DELETE FROM users WHERE name='Tom'\"\n        )\n\n    def test_delete_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('students', {'name': 'Tom'}),\n            \"DELETE FROM students WHERE name='Tom'\"\n        )\n\n    def test_delete_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'apple'}),\n            \"DELETE FROM items WHERE name='apple'\"\n        )\n\n    def test_delete_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'aaa'}),\n            \"DELETE FROM items WHERE name='aaa'\"\n        )\n\n    def test_delete_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'bbb'}),\n            \"DELETE FROM items WHERE name='bbb'\"\n        )\n\n    def test_delete_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items'),\n            \"DELETE FROM items\"\n        )\n\n\nclass SQLQueryBuilderTestUpdate(unittest.TestCase):\n    def test_update_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('users', {'age': 35}, {'name': 'Tom'}),\n            \"UPDATE users SET age='35' WHERE name='Tom'\"\n        )\n\n    def test_update_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('students', {'age': 18}, {'name': 'Tom'}),\n            \"UPDATE students SET age='18' WHERE name='Tom'\"\n        )\n\n    def test_update_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'apple'}),\n            \"UPDATE items SET price='1.0' WHERE name='apple'\"\n        )\n\n    def test_update_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'aaa'}),\n            \"UPDATE items SET price='1.0' WHERE name='aaa'\"\n        )\n\n    def test_update_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'bbb'}),\n            \"UPDATE items SET price='1.0' WHERE name='bbb'\"\n        )\n\n    def test_update_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}),\n            \"UPDATE items SET price='1.0'\"\n        )\n\n\nclass SQLQueryBuilderTestMain(unittest.TestCase):\n    def test_main(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\", \"name\"], {'age': 30}),\n            \"SELECT id, name FROM users WHERE age='30'\"\n        )\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30}),\n            \"INSERT INTO users (name, age) VALUES ('Tom', '30')\"\n        )\n        self.assertEqual(\n            SQLQueryBuilder.delete('users', {'name': 'Tom'}),\n            \"DELETE FROM users WHERE name='Tom'\"\n        )\n        self.assertEqual(\n            SQLQueryBuilder.update('users', {'age': 35}, {'name': 'Tom'}),\n            \"UPDATE users SET age='35' WHERE name='Tom'\"\n        )",
    "solution_code": "class SQLQueryBuilder:\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        if columns != '*':\n            columns = ', '.join(columns)\n        query = f\"SELECT {columns} FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        query = f\"DELETE FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        query = f\"UPDATE {table} SET {update_str}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
    "import_statement": [],
    "class_description": "    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n",
    "class_name": "SQLQueryBuilder",
    "test_classes": [
      "SQLQueryBuilderTestSelect",
      "SQLQueryBuilderTestInsert",
      "SQLQueryBuilderTestDetele",
      "SQLQueryBuilderTestUpdate",
      "SQLQueryBuilderTestMain"
    ],
    "class_constructor": "class SQLQueryBuilder: \n",
    "fields": [],
    "methods_info": [
      {
        "method_name": "select",
        "method_description": "def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestSelect",
        "test_code": "class SQLQueryBuilderTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\", \"name\"], {'age': 30}),\n            \"SELECT id, name FROM users WHERE age='30'\"\n        )\n\n    def test_select_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('students', [\"id\", \"name\"], {'age': 18}),\n            \"SELECT id, name FROM students WHERE age='18'\"\n        )\n\n    def test_select_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('items', [\"id\", \"name\"], {'price': 1.0}),\n            \"SELECT id, name FROM items WHERE price='1.0'\"\n        )\n\n    def test_select_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"id\"], {'age': 30}),\n            \"SELECT id FROM users WHERE age='30'\"\n        )\n\n    def test_select_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"], {'age': 30}),\n            \"SELECT name FROM users WHERE age='30'\"\n        )\n\n    def test_select_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', [\"name\"]),\n            \"SELECT name FROM users\"\n        )\n\n    def test_select_7(self):\n        self.assertEqual(\n            SQLQueryBuilder.select('users', \"*\"),\n            \"SELECT * FROM users\"\n        )",
        "solution_code": "def select(table, columns='*', where=None):\n        if columns != '*':\n            columns = ', '.join(columns)\n        query = f\"SELECT {columns} FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert",
        "method_description": "@staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestInsert",
        "test_code": "class SQLQueryBuilderTestInsert(unittest.TestCase):\n    def test_insert_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30}),\n            \"INSERT INTO users (name, age) VALUES ('Tom', '30')\"\n        )\n\n    def test_insert_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('students', {'name': 'Tom', 'age': 18}),\n            \"INSERT INTO students (name, age) VALUES ('Tom', '18')\"\n        )\n\n    def test_insert_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('items', {'name': 'apple', 'price': 1.0}),\n            \"INSERT INTO items (name, price) VALUES ('apple', '1.0')\"\n        )\n\n    def test_insert_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom'}),\n            \"INSERT INTO users (name) VALUES ('Tom')\"\n        )\n\n    def test_insert_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.insert('users', {'name': 'Tom', 'age': 30, 'region': 'USA'}),\n            \"INSERT INTO users (name, age, region) VALUES ('Tom', '30', 'USA')\"\n        )",
        "solution_code": "@staticmethod\n    def insert(table, data):\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete",
        "method_description": "@staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestDetele",
        "test_code": "class SQLQueryBuilderTestDetele(unittest.TestCase):\n    def test_delete_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('users', {'name': 'Tom'}),\n            \"DELETE FROM users WHERE name='Tom'\"\n        )\n\n    def test_delete_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('students', {'name': 'Tom'}),\n            \"DELETE FROM students WHERE name='Tom'\"\n        )\n\n    def test_delete_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'apple'}),\n            \"DELETE FROM items WHERE name='apple'\"\n        )\n\n    def test_delete_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'aaa'}),\n            \"DELETE FROM items WHERE name='aaa'\"\n        )\n\n    def test_delete_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items', {'name': 'bbb'}),\n            \"DELETE FROM items WHERE name='bbb'\"\n        )\n\n    def test_delete_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.delete('items'),\n            \"DELETE FROM items\"\n        )",
        "solution_code": "@staticmethod\n    def delete(table, where=None):\n        query = f\"DELETE FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      },
      {
        "method_name": "update",
        "method_description": "@staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"",
        "test_class": "SQLQueryBuilderTestUpdate",
        "test_code": "class SQLQueryBuilderTestUpdate(unittest.TestCase):\n    def test_update_1(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('users', {'age': 35}, {'name': 'Tom'}),\n            \"UPDATE users SET age='35' WHERE name='Tom'\"\n        )\n\n    def test_update_2(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('students', {'age': 18}, {'name': 'Tom'}),\n            \"UPDATE students SET age='18' WHERE name='Tom'\"\n        )\n\n    def test_update_3(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'apple'}),\n            \"UPDATE items SET price='1.0' WHERE name='apple'\"\n        )\n\n    def test_update_4(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'aaa'}),\n            \"UPDATE items SET price='1.0' WHERE name='aaa'\"\n        )\n\n    def test_update_5(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}, {'name': 'bbb'}),\n            \"UPDATE items SET price='1.0' WHERE name='bbb'\"\n        )\n\n    def test_update_6(self):\n        self.assertEqual(\n            SQLQueryBuilder.update('items', {'price': 1.0}),\n            \"UPDATE items SET price='1.0'\"\n        )",
        "solution_code": "@staticmethod\n    def update(table, data, where=None):\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        query = f\"UPDATE {table} SET {update_str}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query",
        "dependencies": {
          "Standalone": true,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def _format_value(value):\n        \"\"\"Formats a value for SQL, quoting strings and converting others to string.\"\"\"\n        # For simplicity based on examples, convert everything to string and quote it.\n        # A more robust builder would handle None, numbers, booleans differently.\n        return f\"'{str(value)}'\"\n\n    @staticmethod\n    def _build_where_clause(where):\n        \"\"\"Builds the WHERE clause string from a dictionary.\"\"\"\n        if not where:\n            return \"\"\n        conditions = []\n        for key, value in where.items():\n            formatted_value = SQLQueryBuilder._format_value(value)\n            conditions.append(f\"{key}={formatted_value}\")\n        return \" WHERE \" + \" AND \".join(conditions)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2']. Or '*' for all columns.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        >>> SQLQueryBuilder.select('table1', where = {\"id\": 1})\n        \"SELECT * FROM table1 WHERE id='1'\"\n        >>> SQLQueryBuilder.select('table1')\n        \"SELECT * FROM table1\"\n        \"\"\"\n        if isinstance(columns, list):\n            columns_str = \", \".join(columns)\n        else: # Assume '*' or other string\n            columns_str = str(columns)\n\n        query = f\"SELECT {columns_str} FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n        if not data:\n            # Or raise an error, depending on desired behavior for empty data\n            return f\"INSERT INTO {table} () VALUES ()\"\n\n        columns = \", \".join(data.keys())\n        values = \", \".join([SQLQueryBuilder._format_value(v) for v in data.values()])\n\n        query = f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition. If None, deletes all rows.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        >>> SQLQueryBuilder.delete('table1')\n        \"DELETE FROM table1\"\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        >>> SQLQueryBuilder.update('table1', {'status':'active'})\n        \"UPDATE table1 SET status='active'\"\n        \"\"\"\n        if not data:\n             # Or raise an error, nothing to update\n             return \"\" # Or maybe just \"UPDATE {table}\" if that's valid in context? Sticking to common UPDATE syntax requiring SET.\n\n        set_parts = []\n        for key, value in data.items():\n            formatted_value = SQLQueryBuilder._format_value(value)\n            set_parts.append(f\"{key}={formatted_value}\")\n\n        set_clause = \", \".join(set_parts)\n\n        query = f\"UPDATE {table} SET {set_clause}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n# Example Usage (optional, for testing)\nif __name__ == '__main__':\n    print(SQLQueryBuilder.select('table1', columns=[\"col1\", \"col2\"], where={\"age\": 15}))\n    print(SQLQueryBuilder.select('table1', where={\"id\": 1}))\n    print(SQLQueryBuilder.select('table1'))\n    print(SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14}))\n    print(SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14}))\n    print(SQLQueryBuilder.delete('table1'))\n    print(SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where={'name': 'Test'}))\n    print(SQLQueryBuilder.update('table1', {'status': 'active'}))\n```",
      "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def _format_value(value):\n        \"\"\"\n        Helper method to format a value for inclusion in an SQL query.\n        Simple implementation: quote strings, convert None to NULL.\n        Assuming numbers are also quoted as strings for simplicity based on examples.\n        \"\"\"\n        if value is None:\n            return \"NULL\"\n        # For simplicity, treat all other values as strings and quote them\n        return f\"'{str(value)}'\"\n\n    @staticmethod\n    def _build_where_clause(where):\n        \"\"\"\n        Helper method to build the WHERE clause from a dictionary.\n        \"\"\"\n        if not where:\n            return \"\"\n        conditions = []\n        for key, value in where.items():\n            formatted_value = SQLQueryBuilder._format_value(value)\n            conditions.append(f\"{key}={formatted_value}\")\n        return \" WHERE \" + \" AND \".join(conditions)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2']. Can also be '*'.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        >>> SQLQueryBuilder.select('table1', where = {\"name\": \"Test\"})\n        \"SELECT * FROM table1 WHERE name='Test'\"\n        >>> SQLQueryBuilder.select('table1')\n        \"SELECT * FROM table1\"\n        \"\"\"\n        if isinstance(columns, list):\n            columns_str = \", \".join(columns)\n        else: # Assume '*' or similar string\n            columns_str = columns\n\n        query = f\"SELECT {columns_str} FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        >>> SQLQueryBuilder.insert('users', {'username': 'admin', 'email': 'admin@example.com', 'active': None})\n        \"INSERT INTO users (username, email, active) VALUES ('admin', 'admin@example.com', NULL)\"\n        \"\"\"\n        if not data:\n            # Or raise an error, depending on desired behavior for empty data\n            return f\"INSERT INTO {table} () VALUES ()\"\n\n        columns = data.keys()\n        values = data.values()\n\n        columns_str = \", \".join(columns)\n        values_str = \", \".join([SQLQueryBuilder._format_value(v) for v in values])\n\n        query = f\"INSERT INTO {table} ({columns_str}) VALUES ({values_str})\"\n\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        >>> SQLQueryBuilder.delete('users', {'active': None})\n        \"DELETE FROM users WHERE active=NULL\"\n        >>> SQLQueryBuilder.delete('table1')\n        \"DELETE FROM table1\"\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        >>> SQLQueryBuilder.update('users', {'active': 0}, where = {'username':'admin'})\n        \"UPDATE users SET active='0' WHERE username='admin'\"\n        >>> SQLQueryBuilder.update('config', {'value': None}, where = {'key':'temp_setting'})\n        \"UPDATE config SET value=NULL WHERE key='temp_setting'\"\n        >>> SQLQueryBuilder.update('table1', {'column1': 'new_value'})\n        \"UPDATE table1 SET column1='new_value'\"\n        \"\"\"\n        if not data:\n            # Or raise an error, depending on desired behavior for empty data\n             return f\"UPDATE {table} SET \" # This is likely an invalid query without SET values\n\n        set_parts = []\n        for key, value in data.items():\n             formatted_value = SQLQueryBuilder._format_value(value)\n             set_parts.append(f\"{key}={formatted_value}\")\n\n        set_clause = \", \".join(set_parts)\n\n        query = f\"UPDATE {table} SET {set_clause}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\nif __name__ == '__main__':\n    # Example Usage:\n    print(SQLQueryBuilder.select('users', columns=['id', 'username'], where={'status': 'active'}))\n    print(SQLQueryBuilder.select('products'))\n    print(SQLQueryBuilder.insert('logs', {'message': 'system started', 'level': 'INFO'}))\n    print(SQLQueryBuilder.insert('tasks', {'description': 'Clean up', 'completed': False, 'due_date': None}))\n    print(SQLQueryBuilder.update('settings', {'value': 'enabled'}, where={'key': 'feature_flag'}))\n    print(SQLQueryBuilder.update('users', {'last_login': '2023-10-27'}, where={'username': 'test_user'}))\n    print(SQLQueryBuilder.delete('temp_data', where={'created_at': '2023-01-01'}))\n    print(SQLQueryBuilder.delete('all_records'))\n\n    # Run Doctests\n    import doctest\n    doctest.testmod()\n\n```",
      "```python\nimport shlex # Use shlex for safer quoting, although the examples are simpler.\n             # Let's stick to the simple quoting shown in examples first,\n             # but acknowledge real-world SQL needs better handling of types and escaping.\n\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def _quote_value(value):\n        \"\"\"Quotes a value for use in a SQL query. Handles None. Assumes simple quoting for strings/numbers as shown in examples.\"\"\"\n        if value is None:\n            return 'NULL'\n        # Simple quoting assuming all values are treated as strings in examples\n        return f\"'{value}'\"\n\n    @staticmethod\n    def _build_where_clause(where):\n        \"\"\"Builds the WHERE clause string from a dictionary.\"\"\"\n        if not where:\n            return \"\"\n        conditions = []\n        for key, value in where.items():\n            # Basic sanitization for key (column name) - assuming valid identifier\n            quoted_value = SQLQueryBuilder._quote_value(value)\n            conditions.append(f\"{key}={quoted_value}\")\n        return \" WHERE \" + \" AND \".join(conditions)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or '*', ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        >>> SQLQueryBuilder.select('table1', where = {\"id\": 1})\n        \"SELECT * FROM table1 WHERE id='1'\"\n        >>> SQLQueryBuilder.select('table1')\n        \"SELECT * FROM table1\"\n        \"\"\"\n        if isinstance(columns, list):\n            columns_str = \", \".join(columns)\n        elif columns == '*':\n            columns_str = \"*\"\n        else:\n             raise TypeError(\"columns must be a list of strings or '*'\")\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n\n        return f\"SELECT {columns_str} FROM {table}{where_clause}\"\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        >>> SQLQueryBuilder.insert('users', {'username': 'admin', 'active': True, 'login_count': 0, 'notes': None})\n        \"INSERT INTO users (username, active, login_count, notes) VALUES ('admin', 'True', '0', NULL)\"\n        \"\"\"\n        if not data:\n            raise ValueError(\"data dictionary cannot be empty for INSERT\")\n\n        columns = list(data.keys())\n        values = [SQLQueryBuilder._quote_value(data[col]) for col in columns]\n\n        columns_str = \", \".join(columns)\n        values_str = \", \".join(values)\n\n        return f\"INSERT INTO {table} ({columns_str}) VALUES ({values_str})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        >>> SQLQueryBuilder.delete('logs', {'timestamp': '2023-01-01'})\n        \"DELETE FROM logs WHERE timestamp='2023-01-01'\"\n        >>> SQLQueryBuilder.delete('temp_table')\n        \"DELETE FROM temp_table\"\n        \"\"\"\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n\n        return f\"DELETE FROM {table}{where_clause}\"\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        >>> SQLQueryBuilder.update('users', {'active': False, 'login_count': 0}, {'username': 'admin'})\n        \"UPDATE users SET active='False', login_count='0' WHERE username='admin'\"\n        >>> SQLQueryBuilder.update('settings', {'value': 'new_setting'})\n        \"UPDATE settings SET value='new_setting'\"\n        \"\"\"\n        if not data:\n             # Although SQL allows SET nothing, it's usually an error condition in building\n             raise ValueError(\"data dictionary cannot be empty for UPDATE\")\n\n        set_parts = []\n        for key, value in data.items():\n             # Basic sanitization for key (column name)\n             quoted_value = SQLQueryBuilder._quote_value(value)\n             set_parts.append(f\"{key}={quoted_value}\")\n        set_clause = \", \".join(set_parts)\n\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n\n        return f\"UPDATE {table} SET {set_clause}{where_clause}\"\n\n# Example Usage (optional, for testing)\nif __name__ == '__main__':\n    # Running the doctests\n    import doctest\n    doctest.testmod()\n\n    # Additional manual tests\n    print(\"\\nManual Tests:\")\n    print(SQLQueryBuilder.select('users', columns=['id', 'username'], where={'status': 'active', 'login_count': '> 10'}))\n    print(SQLQueryBuilder.insert('products', {'name': 'Laptop', 'price': 1200.50, 'in_stock': True}))\n    print(SQLQueryBuilder.delete('orders', where={'status': 'cancelled'}))\n    print(SQLQueryBuilder.update('inventory', {'quantity': 50}, where={'product_id': 101}))\n    print(SQLQueryBuilder.select('all_data'))\n    print(SQLQueryBuilder.delete('temp_data'))\n```",
      "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def _format_value(value):\n        \"\"\"Helper to format values for SQL, quoting strings.\"\"\"\n        # For simplicity, we'll treat all values as requiring quoting\n        # as shown in the examples, even if they are numerically intended.\n        # A more robust builder would handle types properly.\n        return f\"'{str(value)}'\"\n\n    @staticmethod\n    def _build_where_clause(where):\n        \"\"\"Helper to build the WHERE part of a SQL query.\"\"\"\n        if not where:\n            return \"\"\n        conditions = []\n        for key, value in where.items():\n            conditions.append(f\"{key}={SQLQueryBuilder._format_value(value)}\")\n        return \" WHERE \" + \" AND \".join(conditions)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or str, ['col1', 'col2'] or '*'.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        >>> SQLQueryBuilder.select('table2')\n        \"SELECT * FROM table2\"\n        >>> SQLQueryBuilder.select('table3', where = {\"id\": 1})\n        \"SELECT * FROM table3 WHERE id='1'\"\n        \"\"\"\n        if isinstance(columns, list):\n            columns_str = \", \".join(columns)\n        else: # Assume '*' or other string\n            columns_str = str(columns)\n\n        query = f\"SELECT {columns_str} FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n        if not data:\n            # Handle cases where data is empty, although a valid INSERT usually requires data\n            return f\"INSERT INTO {table} () VALUES ()\"\n\n        columns = data.keys()\n        values = [SQLQueryBuilder._format_value(v) for v in data.values()]\n\n        columns_str = \", \".join(columns)\n        values_str = \", \".join(values)\n\n        query = f\"INSERT INTO {table} ({columns_str}) VALUES ({values_str})\"\n\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition. If None, deletes all rows.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        >>> SQLQueryBuilder.delete('table2')\n        \"DELETE FROM table2\"\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        >>> SQLQueryBuilder.update('table2', {'status': 'active'})\n        \"UPDATE table2 SET status='active'\"\n        \"\"\"\n        if not data:\n            # Cannot perform an UPDATE without SET data\n            # A more robust builder might raise an error\n            return f\"UPDATE {table} SET\" # This is invalid SQL, but follows structure\n\n        set_parts = []\n        for key, value in data.items():\n            set_parts.append(f\"{key}={SQLQueryBuilder._format_value(value)}\")\n\n        set_clause = \", \".join(set_parts)\n\n        query = f\"UPDATE {table} SET {set_clause}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n# Example Usage:\nif __name__ == '__main__':\n    print(SQLQueryBuilder.select('users', columns=['id', 'name'], where={'age': 30, 'city': 'New York'}))\n    # Expected: SELECT id, name FROM users WHERE age='30' AND city='New York'\n\n    print(SQLQueryBuilder.select('products'))\n    # Expected: SELECT * FROM products\n\n    print(SQLQueryBuilder.insert('orders', {'user_id': 101, 'product_id': 5, 'quantity': 2}))\n    # Expected: INSERT INTO orders (user_id, product_id, quantity) VALUES ('101', '5', '2')\n\n    print(SQLQueryBuilder.delete('users', where={'status': 'inactive'}))\n    # Expected: DELETE FROM users WHERE status='inactive'\n\n    print(SQLQueryBuilder.delete('temp_data'))\n    # Expected: DELETE FROM temp_data\n\n    print(SQLQueryBuilder.update('products', {'price': 25.50, 'stock': 100}, where={'product_id': 5}))\n    # Expected: UPDATE products SET price='25.5', stock='100' WHERE product_id='5'\n\n    print(SQLQueryBuilder.update('settings', {'value': 'enabled'}))\n    # Expected: UPDATE settings SET value='enabled'\n\n    # Test cases from docstrings\n    print(SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15}))\n    print(SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14}))\n    print(SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14}))\n    print(SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'}))\n```",
      "```python\nimport warnings\n\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n\n    WARNING: This class constructs SQL queries using basic string formatting.\n    This approach is vulnerable to SQL injection attacks if input parameters\n    (especially values in data or where clauses) come from untrusted sources\n    like user input without proper sanitization.\n    For production applications, it is strongly recommended to use database\n    connectors that support parameterized queries (prepared statements)\n    instead of building SQL strings directly.\n    \"\"\"\n\n    @staticmethod\n    def _format_value(value):\n        \"\"\"Helper to format values for SQL string inclusion (simple quoting).\"\"\"\n        # Basic handling: treats all values as strings and quotes them.\n        # Real implementation would need to handle numbers, booleans, NULL, dates etc.\n        return f\"'{value}'\"\n\n    @staticmethod\n    def _build_where_clause(where):\n        \"\"\"Helper to build the WHERE clause.\"\"\"\n        if not where:\n            return \"\"\n        conditions = []\n        for key, value in where.items():\n            formatted_value = SQLQueryBuilder._format_value(value)\n            conditions.append(f\"{key}={formatted_value}\")\n        return \" WHERE \" + \" AND \".join(conditions)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or str, ['col1', 'col2'] or '*'.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        >>> SQLQueryBuilder.select('table2', where = {\"status\": \"active\"})\n        \"SELECT * FROM table2 WHERE status='active'\"\n        >>> SQLQueryBuilder.select('table3')\n        \"SELECT * FROM table3\"\n        \"\"\"\n        if isinstance(columns, list):\n            columns_str = \", \".join(columns)\n        elif isinstance(columns, str):\n             columns_str = columns\n        else:\n             raise TypeError(\"columns must be a list of strings or a string ('*')\")\n\n        query = f\"SELECT {columns_str} FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty for INSERT\")\n\n        columns = data.keys()\n        values = [SQLQueryBuilder._format_value(value) for value in data.values()]\n\n        columns_str = \", \".join(columns)\n        values_str = \", \".join(values)\n\n        query = f\"INSERT INTO {table} ({columns_str}) VALUES ({values_str})\"\n        return query\n\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        >>> SQLQueryBuilder.delete('table2') # Dangerous: Deletes all rows!\n        \"DELETE FROM table2\"\n        \"\"\"\n        if not where:\n            warnings.warn(\n                f\"DELETE statement without WHERE clause generated for table '{table}'. \"\n                \"This will delete ALL rows in the table.\",\n                UserWarning\n            )\n\n        query = f\"DELETE FROM {table}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        >>> SQLQueryBuilder.update('table2', {'status': 'inactive'}) # Dangerous: Updates all rows!\n        \"UPDATE table2 SET status='inactive'\"\n        \"\"\"\n        if not data:\n             raise ValueError(\"Data dictionary cannot be empty for UPDATE SET clause\")\n\n        set_parts = []\n        for key, value in data.items():\n            formatted_value = SQLQueryBuilder._format_value(value)\n            set_parts.append(f\"{key}={formatted_value}\")\n\n        set_clause = \", \".join(set_parts)\n\n        if not where:\n             warnings.warn(\n                f\"UPDATE statement without WHERE clause generated for table '{table}'. \"\n                \"This will update ALL rows in the table.\",\n                UserWarning\n            )\n\n        query = f\"UPDATE {table} SET {set_clause}\"\n\n        where_clause = SQLQueryBuilder._build_where_clause(where)\n        query += where_clause\n\n        return query\n\n# Example Usage (based on doctests):\nif __name__ == '__main__':\n    print(SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15}))\n    print(SQLQueryBuilder.select('table2', where = {\"status\": \"active\"}))\n    print(SQLQueryBuilder.select('table3'))\n\n    print(SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14}))\n\n    print(SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14}))\n    # Example of dangerous DELETE (will print a warning)\n    print(SQLQueryBuilder.delete('table_to_empty'))\n\n    print(SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'}))\n    # Example of dangerous UPDATE (will print a warning)\n    print(SQLQueryBuilder.update('table_to_update_all', {'status': 'processed'}))\n\n```"
    ]
  },
  {
    "task_id": "ClassEval_83",
    "skeleton": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"",
    "test": "import unittest\n\n\nclass StudentDatabaseProcessorTestInsertStudent(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_student_1(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_insert_student_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_insert_student_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_insert_student_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_insert_student_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')\n\n\nclass StudentDatabaseProcessorTestSearchStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_search_student_by_name_1(self):\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n    def test_search_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('aaa')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_search_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('bbb')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_search_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ccc')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_search_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ddd')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')\n\n\nclass StudentDatabaseProcessorTestDeleteStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_student_by_name_1(self):\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('aaa')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('bbb')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ccc')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ddd')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n\nclass StudentDatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_StudentDatabaseProcessor(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
    "solution_code": "import sqlite3\n\n\nclass StudentDatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result\n\n    def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n",
    "class_name": "StudentDatabaseProcessor",
    "test_classes": [
      "StudentDatabaseProcessorTestInsertStudent",
      "StudentDatabaseProcessorTestSearchStudentByName",
      "StudentDatabaseProcessorTestDeleteStudentByName",
      "StudentDatabaseProcessorTest"
    ],
    "class_constructor": "class StudentDatabaseProcessor: \n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n",
    "fields": [
      "self.database_name"
    ],
    "methods_info": [
      {
        "method_name": "create_student_table",
        "method_description": "def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTestInsertStudent",
        "test_code": "class StudentDatabaseProcessorTestInsertStudent(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_student_1(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_insert_student_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_insert_student_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_insert_student_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_insert_student_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')",
        "solution_code": "def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "insert_student",
        "method_description": "def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTestSearchStudentByName",
        "test_code": "class StudentDatabaseProcessorTestSearchStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_search_student_by_name_1(self):\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n    def test_search_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('aaa')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_search_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('bbb')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_search_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ccc')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_search_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ddd')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')",
        "solution_code": "def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_student_by_name",
        "method_description": "def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTestDeleteStudentByName",
        "test_code": "class StudentDatabaseProcessorTestDeleteStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_student_by_name_1(self):\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('aaa')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('bbb')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ccc')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ddd')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
        "solution_code": "def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_student_by_name",
        "method_description": "def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"",
        "test_class": "StudentDatabaseProcessorTest",
        "test_code": "class StudentDatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_StudentDatabaseProcessor(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
        "solution_code": "def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [
            "sqlite3"
          ],
          "field_dependencies": [
            "self.database_name"
          ],
          "method_dependencies": []
        }
      }
    ],
    "predict": [
      "```python\nimport sqlite3\nimport os # Import os for potential cleanup in examples if needed, though not strictly required by the prompt\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n        # Ensure the database file exists or can be created\n        try:\n            conn = sqlite3.connect(self.database_name)\n            conn.close()\n        except sqlite3.Error as e:\n            print(f\"Error connecting to database {self.database_name}: {e}\")\n\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> db_name = \"test_students_create.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up previous run\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> # Verify table exists (optional check)\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='students';\")\n        >>> table_exists = cursor.fetchone() is not None\n        >>> conn.close()\n        >>> # print(table_exists) # Should be True\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up\n        \"\"\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                # SQL statement to create the table\n                cursor.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS students (\n                        ID INTEGER PRIMARY KEY AUTOINCREMENT,\n                        name TEXT NOT NULL,\n                        age INTEGER,\n                        gender TEXT,\n                        grade INTEGER\n                    )\n                \"\"\")\n                # The 'with' statement automatically commits if no exception occurs\n                print(f\"Table 'students' created or already exists in {self.database_name}\")\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n                             Expected keys: 'name', 'age', 'gender', 'grade'.\n        :return: None\n        >>> db_name = \"test_students_insert.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up previous run\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John Doe', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> # Verify insertion (optional check)\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name, age, gender, grade FROM students WHERE name = ?\", ('John Doe',))\n        >>> row = cursor.fetchone()\n        >>> conn.close()\n        >>> # print(row) # Should be ('John Doe', 15, 'Male', 9)\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up\n        \"\"\"\n        sql = \"INSERT INTO students (name, age, gender, grade) VALUES (?, ?, ?, ?)\"\n        try:\n            # Prepare the data tuple from the dictionary\n            data = (\n                student_data.get('name'),\n                student_data.get('age'),\n                student_data.get('gender'),\n                student_data.get('grade')\n            )\n            # Basic validation: ensure name is provided\n            if data[0] is None:\n                print(\"Error: 'name' is a required field for insertion.\")\n                return\n\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(sql, data)\n                # The 'with' statement automatically commits if no exception occurs\n                print(f\"Successfully inserted student: {student_data.get('name')}\")\n        except KeyError as e:\n            print(f\"Error: Missing key in student_data dictionary - {e}\")\n        except sqlite3.Error as e:\n            print(f\"Error inserting student: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during insertion: {e}\")\n\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n                 Returns an empty list if no student is found or an error occurs.\n        >>> db_name = \"test_students_search.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up previous run\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> student_data1 = {'name': 'Alice Smith', 'age': 16, 'gender': 'Female', 'grade': 10}\n        >>> student_data2 = {'name': 'Bob Johnson', 'age': 14, 'gender': 'Male', 'grade': 8}\n        >>> processor.insert_student(student_data1)\n        >>> processor.insert_student(student_data2)\n        >>> result1 = processor.search_student_by_name(\"Alice Smith\")\n        >>> # print(result1) # Should be like [(1, 'Alice Smith', 16, 'Female', 10)] (ID might vary)\n        >>> result2 = processor.search_student_by_name(\"Charlie Brown\")\n        >>> # print(result2) # Should be []\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up\n        \"\"\"\n        sql = \"SELECT ID, name, age, gender, grade FROM students WHERE name = ?\"\n        results = []\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(sql, (name,)) # Use a tuple for the parameter\n                results = cursor.fetchall()\n                if results:\n                    print(f\"Found {len(results)} student(s) with the name '{name}'.\")\n                else:\n                     print(f\"No student found with the name '{name}'.\")\n        except sqlite3.Error as e:\n            print(f\"Error searching for student by name: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during search: {e}\")\n\n        return results\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> db_name = \"test_students_delete.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up previous run\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'Peter Pan', 'age': 10, 'gender': 'Male', 'grade': 4}\n        >>> processor.insert_student(student_data)\n        >>> # Verify insertion (optional check)\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT count(*) FROM students WHERE name = ?\", ('Peter Pan',))\n        >>> count_before = cursor.fetchone()[0]\n        >>> conn.close()\n        >>> # print(f\"Before deletion: {count_before} rows\") # Should be 1\n        >>> processor.delete_student_by_name(\"Peter Pan\")\n        >>> # Verify deletion (optional check)\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT count(*) FROM students WHERE name = ?\", ('Peter Pan',))\n        >>> count_after = cursor.fetchone()[0]\n        >>> conn.close()\n        >>> # print(f\"After deletion: {count_after} rows\") # Should be 0\n        >>> if os.path.exists(db_name): os.remove(db_name) # Clean up\n        \"\"\"\n        sql = \"DELETE FROM students WHERE name = ?\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(sql, (name,)) # Use a tuple for the parameter\n                # The 'with' statement automatically commits the deletion\n                print(f\"Successfully deleted student(s) with the name '{name}'. Rows affected: {cursor.rowcount}\")\n        except sqlite3.Error as e:\n            print(f\"Error deleting student by name: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred during deletion: {e}\")\n\n# Example Usage (optional, uncomment to run)\n# if __name__ == \"__main__\":\n#     db_file = \"school_database.db\"\n#     processor = StudentDatabaseProcessor(db_file)\n\n#     # Create table\n#     processor.create_student_table()\n\n#     # Insert students\n#     students_to_insert = [\n#         {'name': 'Alice Wonderland', 'age': 16, 'gender': 'Female', 'grade': 10},\n#         {'name': 'Bob TheBuilder', 'age': 14, 'gender': 'Male', 'grade': 8},\n#         {'name': 'Charlie Chaplin', 'age': 15, 'gender': 'Male', 'grade': 9},\n#         {'name': 'Alice Wonderland', 'age': 17, 'gender': 'Female', 'grade': 11}, # Another Alice\n#     ]\n#     for student_data in students_to_insert:\n#         processor.insert_student(student_data)\n\n#     # Search for a student\n#     search_name = \"Alice Wonderland\"\n#     found_students = processor.search_student_by_name(search_name)\n#     print(f\"\\nSearch results for '{search_name}':\")\n#     for student in found_students:\n#         print(student)\n\n#     search_name = \"David Copperfield\"\n#     found_students = processor.search_student_by_name(search_name)\n#     print(f\"\\nSearch results for '{search_name}':\")\n#     for student in found_students:\n#          print(student) # This loop won't run as no students found\n\n#     # Delete a student\n#     delete_name = \"Bob TheBuilder\"\n#     processor.delete_student_by_name(delete_name)\n\n#     # Verify deletion\n#     found_students_after_delete = processor.search_student_by_name(delete_name)\n#     print(f\"\\nSearch results for '{delete_name}' after deletion:\")\n#     for student in found_students_after_delete:\n#         print(student) # This loop won't run\n\n#     # Clean up the database file (optional)\n#     # if os.path.exists(db_file):\n#     #     os.remove(db_file)\n#     #     print(f\"\\nCleaned up {db_file}\")\n\n```",
      "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name: str):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include ID of type int (primary key, auto-increment), name of type str,\n        age of type int, gender of type str, and grade of type int.\n        :return: None\n        >>> import os\n        >>> db_name = \"test_students_create.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='students';\")\n        >>> table_exists = cursor.fetchone() is not None\n        >>> conn.close()\n        >>> table_exists\n        True\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        \"\"\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute('''\n                    CREATE TABLE IF NOT EXISTS students (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        name TEXT NOT NULL,\n                        age INTEGER,\n                        gender TEXT,\n                        grade INTEGER\n                    );\n                ''')\n                conn.commit()\n            # print(f\"Table 'students' created or already exists in {self.database_name}\")\n        except sqlite3.Error as e:\n            print(f\"Database error during table creation: {e}\")\n        except Exception as e:\n            print(f\"An error occurred during table creation: {e}\")\n\n\n    def insert_student(self, student_data: dict):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n               Expected keys: 'name' (required), 'age', 'gender', 'grade'.\n        :return: None\n        >>> import os\n        >>> db_name = \"test_students_insert.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John Doe', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name, age, gender, grade FROM students WHERE name=?\", ('John Doe',))\n        >>> row = cursor.fetchone()\n        >>> conn.close()\n        >>> row\n        ('John Doe', 15, 'Male', 9)\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        \"\"\"\n        if not student_data or 'name' not in student_data:\n            print(\"Error: Student data must be a dictionary and include 'name'.\")\n            return\n\n        sql = '''\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (?, ?, ?, ?)\n        '''\n        # Use .get() to handle missing optional keys gracefully\n        values = (\n            student_data.get('name'),\n            student_data.get('age'),\n            student_data.get('gender'),\n            student_data.get('grade')\n        )\n\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(sql, values)\n                conn.commit()\n            # print(f\"Student '{student_data.get('name')}' inserted successfully.\")\n        except sqlite3.Error as e:\n            print(f\"Database error during insertion: {e}\")\n        except Exception as e:\n            print(f\"An error occurred during insertion: {e}\")\n\n    def search_student_by_name(self, name: str):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n                 Each tuple represents a row: (id, name, age, gender, grade).\n        >>> import os\n        >>> db_name = \"test_students_search.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> processor.insert_student({'name': 'Alice', 'age': 16, 'gender': 'Female', 'grade': 10})\n        >>> processor.insert_student({'name': 'Bob', 'age': 14, 'gender': 'Male', 'grade': 8})\n        >>> processor.insert_student({'name': 'Alice', 'age': 17, 'gender': 'Female', 'grade': 11})\n        >>> result_alice = processor.search_student_by_name(\"Alice\")\n        >>> result_bob = processor.search_student_by_name(\"Bob\")\n        >>> result_charlie = processor.search_student_by_name(\"Charlie\")\n        >>> # Check if the results contain the expected data (ignore ID as it's auto-increment)\n        >>> expected_alice = [('Alice', 16, 'Female', 10), ('Alice', 17, 'Female', 11)]\n        >>> expected_bob = [('Bob', 14, 'Male', 8)]\n        >>> processed_alice = [(r[1], r[2], r[3], r[4]) for r in result_alice]\n        >>> processed_bob = [(r[1], r[2], r[3], r[4]) for r in result_bob]\n        >>> sorted(processed_alice) == sorted(expected_alice)\n        True\n        >>> processed_bob == expected_bob\n        True\n        >>> result_charlie\n        []\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        \"\"\"\n        sql = \"SELECT id, name, age, gender, grade FROM students WHERE name = ?\"\n        results = []\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(sql, (name,))\n                results = cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error during search: {e}\")\n        except Exception as e:\n            print(f\"An error occurred during search: {e}\")\n\n        return results\n\n    def delete_student_by_name(self, name: str):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> import os\n        >>> db_name = \"test_students_delete.db\"\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        >>> processor = StudentDatabaseProcessor(db_name)\n        >>> processor.create_student_table()\n        >>> processor.insert_student({'name': 'David', 'age': 16, 'gender': 'Male', 'grade': 10})\n        >>> processor.insert_student({'name': 'Eve', 'age': 15, 'gender': 'Female', 'grade': 9})\n        >>> processor.insert_student({'name': 'David', 'age': 17, 'gender': 'Male', 'grade': 11})\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT COUNT(*) FROM students WHERE name=?\", ('David',))\n        >>> initial_count_david = cursor.fetchone()[0]\n        >>> cursor.execute(\"SELECT COUNT(*) FROM students WHERE name=?\", ('Eve',))\n        >>> initial_count_eve = cursor.fetchone()[0]\n        >>> conn.close()\n        >>> initial_count_david\n        2\n        >>> initial_count_eve\n        1\n        >>> processor.delete_student_by_name(\"David\")\n        >>> conn = sqlite3.connect(db_name)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT COUNT(*) FROM students WHERE name=?\", ('David',))\n        >>> final_count_david = cursor.fetchone()[0]\n        >>> cursor.execute(\"SELECT COUNT(*) FROM students WHERE name=?\", ('Eve',))\n        >>> final_count_eve = cursor.fetchone()[0]\n        >>> conn.close()\n        >>> final_count_david\n        0\n        >>> final_count_eve\n        1\n        >>> if os.path.exists(db_name): os.remove(db_name)\n        \"\"\"\n        sql = \"DELETE FROM students WHERE name = ?\"\n        try:\n            with sqlite3.connect(self.database_name) as conn:\n                cursor = conn.cursor()\n                cursor.execute(sql, (name,))\n                rows_deleted = cursor.rowcount\n                conn.commit()\n            # print(f\"{rows_deleted} rows deleted for student name '{name}'.\")\n        except sqlite3.Error as e:\n            print(f\"Database error during deletion: {e}\")\n        except Exception as e:\n            print(f\"An error occurred during deletion: {e}\")\n\n# Example Usage (optional, uncomment to run)\n# if __name__ == \"__main__\":\n#     import os\n#     db_file = \"students.db\"\n#     if os.path.exists(db_file):\n#         os.remove(db_file)\n\n#     processor = StudentDatabaseProcessor(db_file)\n\n#     # Create table\n#     print(\"Creating table...\")\n#     processor.create_student_table()\n\n#     # Insert students\n#     print(\"\\nInserting students...\")\n#     student1 = {'name': 'Alice', 'age': 16, 'gender': 'Female', 'grade': 10}\n#     student2 = {'name': 'Bob', 'age': 15, 'gender': 'Male', 'grade': 9}\n#     student3 = {'name': 'Alice', 'age': 17, 'gender': 'Female', 'grade': 11}\n#     processor.insert_student(student1)\n#     processor.insert_student(student2)\n#     processor.insert_student(student3)\n#     processor.insert_student({'name': 'Charlie'}) # Insert with minimal data\n\n#     # Search for students\n#     print(\"\\nSearching for 'Alice'...\")\n#     alice_students = processor.search_student_by_name(\"Alice\")\n#     if alice_students:\n#         for student in alice_students:\n#             print(student)\n#     else:\n#         print(\"No students found with name 'Alice'.\")\n\n#     print(\"\\nSearching for 'Bob'...\")\n#     bob_students = processor.search_student_by_name(\"Bob\")\n#     if bob_students:\n#         for student in bob_students:\n#             print(student)\n#     else:\n#         print(\"No students found with name 'Bob'.\")\n\n#     print(\"\\nSearching for 'David' (should not exist)...\")\n#     david_students = processor.search_student_by_name(\"David\")\n#     if david_students:\n#         for student in david_students:\n#             print(student)\n#     else:\n#         print(\"No students found with name 'David'.\")\n\n#     # Delete student\n#     print(\"\\nDeleting 'Alice'...\")\n#     processor.delete_student_by_name(\"Alice\")\n\n#     # Verify deletion\n#     print(\"\\nSearching for 'Alice' again...\")\n#     alice_students_after_delete = processor.search_student_by_name(\"Alice\")\n#     if alice_students_after_delete:\n#         for student in alice_students_after_delete:\n#             print(student)\n#     else:\n#         print(\"No students found with name 'Alice' after deletion.\")\n\n#     print(\"\\nSearching for 'Bob' again (should still exist)...\")\n#     bob_students_after_delete = processor.search_student_by_name(\"Bob\")\n#     if bob_students_after_delete:\n#         for student in bob_students_after_delete:\n#             print(student)\n#     else:\n#         print(\"No students found with name 'Bob'.\")\n\n#     # Clean up the database file\n#     # if os.path.exists(db_file):\n#     #     os.remove(db_file)\n#     #     print(f\"\\nDatabase file {db_file} removed.\")\n```",
      "```python\nimport sqlite3\nimport os # Import os for removing the test database file in doctests\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def _execute_query(self, query, params=None, fetchone=False, fetchall=False):\n        \"\"\"\n        Helper method to connect, execute a query, commit (if needed), and close.\n        Uses context managers for safe resource handling.\n        \"\"\"\n        conn = None\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            if params:\n                cursor.execute(query, params)\n            else:\n                cursor.execute(query)\n\n            if fetchone:\n                return cursor.fetchone()\n            elif fetchall:\n                return cursor.fetchall()\n            else:\n                conn.commit() # Only commit for non-SELECT operations\n\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            if conn:\n                conn.rollback() # Rollback changes on error\n            return None # Return None on error for fetch operations\n        finally:\n            if conn:\n                conn.close()\n\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> # Clean up previous test database if it exists\n        >>> db_file = \"students_test_create.db\"\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        >>> processor = StudentDatabaseProcessor(db_file)\n        >>> processor.create_student_table()\n        >>> # Verify table exists (optional, requires querying sqlite_master)\n        >>> conn = sqlite3.connect(db_file)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='students';\")\n        >>> result = cursor.fetchone()\n        >>> conn.close()\n        >>> print(result is not None)\n        True\n        >>> # Clean up the test database file\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        \"\"\"\n        create_table_sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            ID INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        );\n        \"\"\"\n        self._execute_query(create_table_sql)\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> # Clean up previous test database if it exists\n        >>> db_file = \"students_test_insert.db\"\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        >>> processor = StudentDatabaseProcessor(db_file)\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> # Verify insertion\n        >>> conn = sqlite3.connect(db_file)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name, age, gender, grade FROM students WHERE name = 'John';\")\n        >>> result = cursor.fetchone()\n        >>> conn.close()\n        >>> print(result)\n        ('John', 15, 'Male', 9)\n        >>> # Clean up the test database file\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        \"\"\"\n        insert_sql = \"\"\"\n        INSERT INTO students (name, age, gender, grade) VALUES (?, ?, ?, ?);\n        \"\"\"\n        # Ensure all keys are present, provide default None or handle errors if not\n        data_tuple = (\n            student_data.get('name'),\n            student_data.get('age'),\n            student_data.get('gender'),\n            student_data.get('grade')\n        )\n        self._execute_query(insert_sql, data_tuple)\n\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria. Returns an empty list if no student is found or an error occurs.\n        >>> # Clean up previous test database if it exists\n        >>> db_file = \"students_test_search.db\"\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        >>> processor = StudentDatabaseProcessor(db_file)\n        >>> processor.create_student_table()\n        >>> student_data1 = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> student_data2 = {'name': 'Jane', 'age': 16, 'gender': 'Female', 'grade': 10}\n        >>> student_data3 = {'name': 'John', 'age': 17, 'gender': 'Male', 'grade': 11}\n        >>> processor.insert_student(student_data1)\n        >>> processor.insert_student(student_data2)\n        >>> processor.insert_student(student_data3)\n        >>> result_john = processor.search_student_by_name(\"John\")\n        >>> print(len(result_john))\n        2\n        >>> print(result_john[0][1]) # Check name of the first result\n        John\n        >>> result_peter = processor.search_student_by_name(\"Peter\")\n        >>> print(len(result_peter))\n        0\n        >>> # Clean up the test database file\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        \"\"\"\n        search_sql = \"\"\"\n        SELECT ID, name, age, gender, grade FROM students WHERE name = ?;\n        \"\"\"\n        # The parameter needs to be a tuple, even if it's a single item\n        return self._execute_query(search_sql, (name,), fetchall=True) or [] # Return empty list if None is returned by _execute_query\n\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> # Clean up previous test database if it exists\n        >>> db_file = \"students_test_delete.db\"\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        >>> processor = StudentDatabaseProcessor(db_file)\n        >>> processor.create_student_table()\n        >>> student_data1 = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> student_data2 = {'name': 'Jane', 'age': 16, 'gender': 'Female', 'grade': 10}\n        >>> student_data3 = {'name': 'John', 'age': 17, 'gender': 'Male', 'grade': 11}\n        >>> processor.insert_student(student_data1)\n        >>> processor.insert_student(student_data2)\n        >>> processor.insert_student(student_data3)\n        >>> processor.delete_student_by_name(\"John\")\n        >>> # Verify deletion\n        >>> conn = sqlite3.connect(db_file)\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name FROM students WHERE name = 'John';\")\n        >>> result_john = cursor.fetchone()\n        >>> cursor.execute(\"SELECT name FROM students WHERE name = 'Jane';\")\n        >>> result_jane = cursor.fetchone()\n        >>> conn.close()\n        >>> print(result_john is None)\n        True\n        >>> print(result_jane is not None)\n        True\n        >>> # Clean up the test database file\n        >>> if os.path.exists(db_file):\n        ...     os.remove(db_file)\n        \"\"\"\n        delete_sql = \"\"\"\n        DELETE FROM students WHERE name = ?;\n        \"\"\"\n        self._execute_query(delete_sql, (name,))\n\nif __name__ == '__main__':\n    # Example Usage:\n\n    # Clean up previous example database if it exists\n    db_file = \"students.db\"\n    if os.path.exists(db_file):\n        os.remove(db_file)\n\n    # 1. Initialize processor\n    processor = StudentDatabaseProcessor(db_file)\n\n    # 2. Create table\n    print(\"Creating table...\")\n    processor.create_student_table()\n    print(\"Table created.\")\n\n    # 3. Insert students\n    print(\"\\nInserting students...\")\n    student1 = {'name': 'Alice', 'age': 14, 'gender': 'Female', 'grade': 8}\n    student2 = {'name': 'Bob', 'age': 15, 'gender': 'Male', 'grade': 9}\n    student3 = {'name': 'Charlie', 'age': 14, 'gender': 'Male', 'grade': 8}\n    student4 = {'name': 'Alice', 'age': 16, 'gender': 'Female', 'grade': 10} # Another Alice\n\n    processor.insert_student(student1)\n    processor.insert_student(student2)\n    processor.insert_student(student3)\n    processor.insert_student(student4)\n    print(\"Students inserted.\")\n\n    # 4. Search for a student\n    print(\"\\nSearching for 'Alice'...\")\n    alice_students = processor.search_student_by_name(\"Alice\")\n    if alice_students:\n        print(\"Found students named Alice:\")\n        for student in alice_students:\n            print(student)\n    else:\n        print(\"No students found named Alice.\")\n\n    print(\"\\nSearching for 'David'...\")\n    david_students = processor.search_student_by_name(\"David\")\n    if david_students:\n         print(\"Found students named David:\")\n         for student in david_students:\n             print(student)\n    else:\n        print(\"No students found named David.\")\n\n\n    # 5. Delete a student\n    print(\"\\nDeleting students named 'Charlie'...\")\n    processor.delete_student_by_name(\"Charlie\")\n    print(\"Deletion attempted.\")\n\n    # 6. Verify deletion by searching again\n    print(\"\\nSearching for 'Charlie' after deletion...\")\n    charlie_students = processor.search_student_by_name(\"Charlie\")\n    if charlie_students:\n        print(\"Found students named Charlie (should not happen):\")\n        for student in charlie_students:\n            print(student)\n    else:\n        print(\"No students found named Charlie (correct).\")\n\n    # Clean up the example database file\n    if os.path.exists(db_file):\n        os.remove(db_file)\n        print(f\"\\nRemoved database file: {db_file}\")\n\n    # You can also run the doctests by running this file with:\n    # python -m doctest your_file_name.py\n```",
      "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\":memory:\") # Use in-memory database for testing\n        >>> processor.create_student_table()\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS students (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    age INTEGER,\n                    gender TEXT,\n                    grade INTEGER\n                )\n            ''')\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\":memory:\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> result = processor.search_student_by_name(\"John\")\n        >>> len(result)\n        1\n        >>> result[0][1] # Check name\n        'John'\n        \"\"\"\n        sql = '''\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (?, ?, ?, ?)\n        '''\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(sql, (student_data.get('name'), student_data.get('age'), student_data.get('gender'), student_data.get('grade')))\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        except KeyError as e:\n             print(f\"Missing data in student_data dictionary: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria. Returns an empty list if no student is found or an error occurs.\n        >>> processor = StudentDatabaseProcessor(\":memory:\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> result = processor.search_student_by_name(\"John\")\n        >>> len(result)\n        1\n        >>> result[0][1] # Check name\n        'John'\n        >>> result_nonexistent = processor.search_student_by_name(\"Jane\")\n        >>> len(result_nonexistent)\n        0\n        \"\"\"\n        sql = \"SELECT id, name, age, gender, grade FROM students WHERE name = ?\"\n        rows = []\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(sql, (name,))\n            rows = cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        finally:\n            if conn:\n                conn.close()\n        return rows\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\":memory:\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> result_before = processor.search_student_by_name(\"John\")\n        >>> len(result_before)\n        1\n        >>> processor.delete_student_by_name(\"John\")\n        >>> result_after = processor.search_student_by_name(\"John\")\n        >>> len(result_after)\n        0\n        \"\"\"\n        sql = \"DELETE FROM students WHERE name = ?\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(sql, (name,))\n            conn.commit()\n            # print(f\"Deleted {cursor.rowcount} row(s) for name: {name}\") # Optional: confirmation\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\nif __name__ == '__main__':\n    # Example Usage:\n    db_file = \"students.db\"\n    processor = StudentDatabaseProcessor(db_file)\n\n    # Create the table\n    print(\"Creating table...\")\n    processor.create_student_table()\n    print(\"Table created or already exists.\")\n\n    # Insert students\n    print(\"\\nInserting students...\")\n    student1 = {'name': 'Alice', 'age': 16, 'gender': 'Female', 'grade': 10}\n    student2 = {'name': 'Bob', 'age': 15, 'gender': 'Male', 'grade': 9}\n    student3 = {'name': 'Alice', 'age': 17, 'gender': 'Female', 'grade': 11} # Another Alice\n    processor.insert_student(student1)\n    processor.insert_student(student2)\n    processor.insert_student(student3)\n    print(\"Students inserted.\")\n\n    # Search for a student\n    print(\"\\nSearching for 'Alice'...\")\n    alice_students = processor.search_student_by_name(\"Alice\")\n    if alice_students:\n        print(\"Found students named Alice:\")\n        for student in alice_students:\n            print(student)\n    else:\n        print(\"No students found named Alice.\")\n\n    print(\"\\nSearching for 'Charlie'...\")\n    charlie_students = processor.search_student_by_name(\"Charlie\")\n    if charlie_students:\n         print(\"Found students named Charlie:\")\n         for student in charlie_students:\n             print(student)\n    else:\n         print(\"No students found named Charlie.\")\n\n\n    # Delete a student\n    print(\"\\nDeleting students named 'Alice'...\")\n    processor.delete_student_by_name(\"Alice\")\n    print(\"Deletion attempt complete.\")\n\n    # Verify deletion\n    print(\"\\nSearching for 'Alice' after deletion...\")\n    alice_students_after_delete = processor.search_student_by_name(\"Alice\")\n    if alice_students_after_delete:\n        print(\"Found students named Alice:\")\n        for student in alice_students_after_delete:\n            print(student)\n    else:\n        print(\"No students found named Alice.\")\n\n    # Keep the Bob record for next run or manual inspection of students.db\n    print(\"\\nRemaining students:\")\n    try:\n        conn = sqlite3.connect(db_file)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT id, name, age, gender, grade FROM students\")\n        all_students = cursor.fetchall()\n        if all_students:\n            for student in all_students:\n                print(student)\n        else:\n            print(\"No students left in the database.\")\n    except sqlite3.Error as e:\n        print(f\"Database error during final check: {e}\")\n    finally:\n        if conn:\n            conn.close()\n\n    # Note: The doctests use \":memory:\" database, which is temporary\n    import doctest\n    print(\"\\nRunning doctests...\")\n    doctest.testmod()\n\n```",
      "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> import os\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up previous runs for doctest\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> # Verify table creation (manual inspection or query)\n        >>> conn = sqlite3.connect(\"students.db\")\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='students';\")\n        >>> result = cursor.fetchone()\n        >>> print(result is not None)\n        True\n        >>> conn.close()\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS students (\n                    ID INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    age INTEGER,\n                    gender TEXT,\n                    grade INTEGER\n                );\n            \"\"\")\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error during table creation: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> import os\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> # Verify insertion\n        >>> conn = sqlite3.connect(\"students.db\")\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT name, age, gender, grade FROM students WHERE name = ?\", ('John',))\n        >>> result = cursor.fetchone()\n        >>> print(result)\n        ('John', 15, 'Male', 9)\n        >>> conn.close()\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        \"\"\"\n        sql = \"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (?, ?, ?, ?)\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(sql, (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n            conn.commit()\n        except KeyError as e:\n            print(f\"Missing required student data key: {e}\")\n        except sqlite3.IntegrityError as e:\n             print(f\"Database integrity error during insertion: {e}\")\n        except sqlite3.Error as e:\n            print(f\"Database error during insertion: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> import os\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data1 = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> student_data2 = {'name': 'Jane', 'age': 16, 'gender': 'Female', 'grade': 10}\n        >>> student_data3 = {'name': 'John', 'age': 14, 'gender': 'Male', 'grade': 8}\n        >>> processor.insert_student(student_data1)\n        >>> processor.insert_student(student_data2)\n        >>> processor.insert_student(student_data3)\n        >>> result_john = processor.search_student_by_name(\"John\")\n        >>> print(len(result_john))\n        2\n        >>> print(result_john[0][1]) # Check name of first result\n        John\n        >>> result_peter = processor.search_student_by_name(\"Peter\")\n        >>> print(len(result_peter))\n        0\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        \"\"\"\n        sql = \"SELECT ID, name, age, gender, grade FROM students WHERE name = ?;\"\n        results = []\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(sql, (name,))\n            results = cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error during search: {e}\")\n        finally:\n            if conn:\n                conn.close()\n        return results\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> import os\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> conn = sqlite3.connect(\"students.db\") # Verify initial state\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT COUNT(*) FROM students WHERE name = ?\", ('John',))\n        >>> print(cursor.fetchone()[0])\n        1\n        >>> conn.close()\n        >>> processor.delete_student_by_name(\"John\")\n        >>> conn = sqlite3.connect(\"students.db\") # Verify deletion\n        >>> cursor = conn.cursor()\n        >>> cursor.execute(\"SELECT COUNT(*) FROM students WHERE name = ?\", ('John',))\n        >>> print(cursor.fetchone()[0])\n        0\n        >>> conn.close()\n        >>> if os.path.exists(\"students.db\"): os.remove(\"students.db\") # Clean up\n        \"\"\"\n        sql = \"DELETE FROM students WHERE name = ?;\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(sql, (name,))\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error during deletion: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n# Example usage (optional, mainly for demonstration beyond doctests)\nif __name__ == '__main__':\n    # Clean up previous run's database if it exists\n    import os\n    if os.path.exists(\"students_example.db\"):\n        os.remove(\"students_example.db\")\n\n    db_processor = StudentDatabaseProcessor(\"students_example.db\")\n\n    # Create table\n    print(\"Creating table...\")\n    db_processor.create_student_table()\n    print(\"Table created.\")\n\n    # Insert students\n    print(\"\\nInserting students...\")\n    student1 = {'name': 'Alice', 'age': 16, 'gender': 'Female', 'grade': 10}\n    student2 = {'name': 'Bob', 'age': 15, 'gender': 'Male', 'grade': 9}\n    student3 = {'name': 'Alice', 'age': 17, 'gender': 'Female', 'grade': 11} # Another Alice\n\n    db_processor.insert_student(student1)\n    db_processor.insert_student(student2)\n    db_processor.insert_student(student3)\n    print(\"Students inserted.\")\n\n    # Search for a student\n    print(\"\\nSearching for 'Alice':\")\n    alice_students = db_processor.search_student_by_name(\"Alice\")\n    if alice_students:\n        for student in alice_students:\n            print(f\"Found: ID={student[0]}, Name={student[1]}, Age={student[2]}, Gender={student[3]}, Grade={student[4]}\")\n    else:\n        print(\"No student named Alice found.\")\n\n    print(\"\\nSearching for 'Charlie':\")\n    charlie_students = db_processor.search_student_by_name(\"Charlie\")\n    if charlie_students:\n         for student in charlie_students:\n            print(f\"Found: ID={student[0]}, Name={student[1]}, Age={student[2]}, Gender={student[3]}, Grade={student[4]}\")\n    else:\n        print(\"No student named Charlie found.\")\n\n\n    # Delete a student\n    print(\"\\nDeleting 'Bob'...\")\n    db_processor.delete_student_by_name(\"Bob\")\n    print(\"'Bob' deleted.\")\n\n    # Verify deletion\n    print(\"\\nSearching for 'Bob' after deletion:\")\n    bob_students_after_delete = db_processor.search_student_by_name(\"Bob\")\n    if bob_students_after_delete:\n        for student in bob_students_after_delete:\n            print(f\"Found: {student}\")\n    else:\n        print(\"No student named Bob found after deletion.\")\n\n    # Clean up the example database\n    # if os.path.exists(\"students_example.db\"):\n    #     os.remove(\"students_example.db\")\n    # print(\"\\nExample database cleaned up.\")\n```"
    ]
  },
  {
    "task_id": "ClassEval_92",
    "skeleton": "class UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"",
    "test": "import unittest\nimport os\nfrom tempfile import gettempdir\n\n\nclass UserLoginDBTestInsertUser(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_insert_user_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_insert_user_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_insert_user_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_insert_user_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_insert_user_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')\n\n\nclass UserLoginDBTestSearchUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_search_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_search_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_search_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_search_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_search_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')\n\n\nclass UserLoginDBTestDeleteUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_delete_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        self.db.delete_user_by_username('user1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        self.db.delete_user_by_username('user2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        self.db.delete_user_by_username('user3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        self.db.delete_user_by_username('user4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        self.db.delete_user_by_username('user5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNone(user)\n\n\nclass UserLoginDBTestValidateUserLogin(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_validate_user_login_1(self):\n        self.db.insert_user('user1', 'pass1')\n        valid = self.db.validate_user_login('user1', 'pass1')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_2(self):\n        self.db.insert_user('user1', 'pass1')\n        invalid = self.db.validate_user_login('user1', 'wrongpass')\n        self.assertFalse(invalid)\n\n    def test_validate_user_login_3(self):\n        valid = self.db.validate_user_login('nonexistentuser', 'somepass')\n        self.assertFalse(valid)\n\n    def test_validate_user_login_4(self):\n        self.db.insert_user('user2', 'pass2')\n        valid = self.db.validate_user_login('user2', 'pass2')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_5(self):\n        self.db.insert_user('user3', 'pass3')\n        valid = self.db.validate_user_login('user3', 'pass3')\n        self.assertTrue(valid)\n\n\nclass UserLoginDBTest(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_UserLoginDB(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n        self.db.delete_user_by_username('user1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNone(user)\n        self.db.insert_user('user1', 'pass1')\n        valid = self.db.validate_user_login('user1', 'pass1')\n        self.assertTrue(valid)",
    "solution_code": "import sqlite3\n\n\nclass UserLoginDB:\n    def __init__(self, db_name):\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        self.cursor.execute('''\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        ''', (username, password))\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        self.cursor.execute('''\n            SELECT * FROM users WHERE username = ?\n        ''', (username,))\n        user = self.cursor.fetchone()\n        return user\n\n    def delete_user_by_username(self, username):\n        self.cursor.execute('''\n            DELETE FROM users WHERE username = ?\n        ''', (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        if user is not None and user[1] == password:\n            return True\n        return False",
    "import_statement": [
      "import sqlite3"
    ],
    "class_description": "    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n",
    "class_name": "UserLoginDB",
    "test_classes": [
      "UserLoginDBTestInsertUser",
      "UserLoginDBTestSearchUserByUsername",
      "UserLoginDBTestDeleteUserByUsername",
      "UserLoginDBTestValidateUserLogin",
      "UserLoginDBTest"
    ],
    "class_constructor": "class UserLoginDB: \n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n",
    "fields": [
      "self.connection",
      "self.cursor"
    ],
    "methods_info": [
      {
        "method_name": "insert_user",
        "method_description": "def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"",
        "test_class": "UserLoginDBTestInsertUser",
        "test_code": "class UserLoginDBTestInsertUser(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_insert_user_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_insert_user_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_insert_user_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_insert_user_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_insert_user_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')",
        "solution_code": "def insert_user(self, username, password):\n        self.cursor.execute('''\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        ''', (username, password))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "search_user_by_username",
        "method_description": "def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"",
        "test_class": "UserLoginDBTestSearchUserByUsername",
        "test_code": "class UserLoginDBTestSearchUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_search_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user1')\n        self.assertEqual(user[1], 'pass1')\n\n    def test_search_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user2')\n        self.assertEqual(user[1], 'pass2')\n\n    def test_search_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user3')\n        self.assertEqual(user[1], 'pass3')\n\n    def test_search_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user4')\n        self.assertEqual(user[1], 'pass4')\n\n    def test_search_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNotNone(user)\n        self.assertEqual(user[0], 'user5')\n        self.assertEqual(user[1], 'pass5')",
        "solution_code": "def search_user_by_username(self, username):\n        self.cursor.execute('''\n            SELECT * FROM users WHERE username = ?\n        ''', (username,))\n        user = self.cursor.fetchone()\n        return user",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "delete_user_by_username",
        "method_description": "def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"",
        "test_class": "UserLoginDBTestDeleteUserByUsername",
        "test_code": "class UserLoginDBTestDeleteUserByUsername(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_delete_user_by_username_1(self):\n        self.db.insert_user('user1', 'pass1')\n        self.db.delete_user_by_username('user1')\n        user = self.db.search_user_by_username('user1')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_2(self):\n        self.db.insert_user('user2', 'pass2')\n        self.db.delete_user_by_username('user2')\n        user = self.db.search_user_by_username('user2')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_3(self):\n        self.db.insert_user('user3', 'pass3')\n        self.db.delete_user_by_username('user3')\n        user = self.db.search_user_by_username('user3')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_4(self):\n        self.db.insert_user('user4', 'pass4')\n        self.db.delete_user_by_username('user4')\n        user = self.db.search_user_by_username('user4')\n        self.assertIsNone(user)\n\n    def test_delete_user_by_username_5(self):\n        self.db.insert_user('user5', 'pass5')\n        self.db.delete_user_by_username('user5')\n        user = self.db.search_user_by_username('user5')\n        self.assertIsNone(user)",
        "solution_code": "def delete_user_by_username(self, username):\n        self.cursor.execute('''\n            DELETE FROM users WHERE username = ?\n        ''', (username,))\n        self.connection.commit()",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [
            "self.connection",
            "self.cursor"
          ],
          "method_dependencies": []
        }
      },
      {
        "method_name": "validate_user_login",
        "method_description": "def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"",
        "test_class": "UserLoginDBTestValidateUserLogin",
        "test_code": "class UserLoginDBTestValidateUserLogin(unittest.TestCase):\n    def setUp(self):\n        self.db_path = os.path.join(gettempdir(), 'test_db.db')\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        create_table_query = \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT,\n                    password TEXT\n                )\n                \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n        self.db = UserLoginDB(self.db_path)\n\n    def tearDown(self):\n        self.db.connection.close()\n        os.unlink(self.db_path)\n\n    def test_validate_user_login_1(self):\n        self.db.insert_user('user1', 'pass1')\n        valid = self.db.validate_user_login('user1', 'pass1')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_2(self):\n        self.db.insert_user('user1', 'pass1')\n        invalid = self.db.validate_user_login('user1', 'wrongpass')\n        self.assertFalse(invalid)\n\n    def test_validate_user_login_3(self):\n        valid = self.db.validate_user_login('nonexistentuser', 'somepass')\n        self.assertFalse(valid)\n\n    def test_validate_user_login_4(self):\n        self.db.insert_user('user2', 'pass2')\n        valid = self.db.validate_user_login('user2', 'pass2')\n        self.assertTrue(valid)\n\n    def test_validate_user_login_5(self):\n        self.db.insert_user('user3', 'pass3')\n        valid = self.db.validate_user_login('user3', 'pass3')\n        self.assertTrue(valid)",
        "solution_code": "def validate_user_login(self, username, password):\n        user = self.search_user_by_username(username)\n        if user is not None and user[1] == password:\n            return True\n        return False",
        "dependencies": {
          "Standalone": false,
          "lib_dependencies": [],
          "field_dependencies": [],
          "method_dependencies": [
            "search_user_by_username"
          ]
        }
      }
    ],
    "predict": [
      "```python\nimport sqlite3\nimport os\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = None\n        self.cursor = None\n        self._connect()\n        self.create_table() # Ensure table exists on initialization\n\n    def _connect(self):\n        \"\"\"Establishes the database connection.\"\"\"\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n            self.cursor = self.connection.cursor()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            # Potentially re-raise or handle more gracefully\n\n    def close(self):\n        \"\"\"Closes the database connection.\"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it doesn't exist.\n        The table has columns: id (INTEGER PRIMARY KEY), username (TEXT UNIQUE), password (TEXT).\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username TEXT UNIQUE NOT NULL,\n                    password TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n            self.connection.rollback() # Rollback changes if table creation fails\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> db_file = \"insert_test.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        >>> print(len(result))\n        1\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        \"\"\"\n        try:\n            self.cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            print(f\"Error: Username '{username}' already exists.\")\n            self.connection.rollback()\n        except sqlite3.Error as e:\n            print(f\"Error inserting user: {e}\")\n            self.connection.rollback()\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> db_file = \"search_test.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        >>> print(len(result))\n        1\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT id, username, password FROM users WHERE username = ?\", (username,))\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"Error searching user: {e}\")\n            return [] # Return empty list on error\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> db_file = \"delete_test.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.insert_user('user2', 'pass2')\n        >>> user_db.delete_user_by_username('user1')\n        >>> result_user1 = user_db.search_user_by_username('user1')\n        >>> result_user2 = user_db.search_user_by_username('user2')\n        >>> print(len(result_user1))\n        0\n        >>> print(len(result_user2))\n        1\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error deleting user: {e}\")\n            self.connection.rollback()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> db_file = \"validate_test.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> print(user_db.validate_user_login('user1', 'pass1'))\n        True\n        >>> print(user_db.validate_user_login('user1', 'wrong_pass'))\n        False\n        >>> print(user_db.validate_user_login('nonexistent_user', 'any_pass'))\n        False\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        \"\"\"\n        try:\n            # Note: Storing passwords in plain text is insecure.\n            # In a real application, passwords should be hashed and salted.\n            self.cursor.execute(\"SELECT id FROM users WHERE username = ? AND password = ?\", (username, password))\n            row = self.cursor.fetchone()\n            return row is not None\n        except sqlite3.Error as e:\n            print(f\"Error validating user: {e}\")\n            return False\n\n# Example usage (outside the class definition, can be used for testing)\nif __name__ == \"__main__\":\n    import doctest\n    # Clean up database files created by doctests before running\n    for f in [\"insert_test.db\", \"search_test.db\", \"delete_test.db\", \"validate_test.db\", \"user_database.db\"]:\n         if os.path.exists(f):\n             os.remove(f)\n\n    print(\"Running doctests...\")\n    # The original doctests are slightly modified to include necessary setup/cleanup\n    # within the test itself, as the original ones assumed a pre-existing table/db state.\n    # Also added print statements to make doctest verification easier.\n    # The provided doctests in the instruction are examples, not executable code blocks.\n    # The doctests below are adjusted to be runnable.\n    # Note: The original doctests implied a create_table() call and potentially cleanup.\n    # The code now includes create_table() in __init__ and adds cleanup to doctests.\n\n    # Test 1: insert_user (modified from original)\n    print(\"Testing insert_user...\")\n    db_file_insert = \"user_database_insert.db\"\n    if os.path.exists(db_file_insert): os.remove(db_file_insert)\n    user_db = UserLoginDB(db_file_insert)\n    user_db.insert_user('user1', 'pass1')\n    # Verify insertion\n    inserted_user = user_db.search_user_by_username('user1')\n    print(f\"Insert Test - User 'user1' found: {len(inserted_user) == 1}\") # Expect True\n    user_db.close()\n    if os.path.exists(db_file_insert): os.remove(db_file_insert)\n\n    # Test 2: search_user_by_username (modified from original)\n    print(\"\\nTesting search_user_by_username...\")\n    db_file_search = \"user_database_search.db\"\n    if os.path.exists(db_file_search): os.remove(db_file_search)\n    user_db = UserLoginDB(db_file_search)\n    user_db.insert_user('user1', 'pass1')\n    result = user_db.search_user_by_username('user1')\n    print(f\"Search Test - Result length for 'user1': {len(result)}\") # Expect 1\n    user_db.close()\n    if os.path.exists(db_file_search): os.remove(db_file_search)\n\n\n    # Test 3: delete_user_by_username (modified from original)\n    print(\"\\nTesting delete_user_by_username...\")\n    db_file_delete = \"user_database_delete.db\"\n    if os.path.exists(db_file_delete): os.remove(db_file_delete)\n    user_db = UserLoginDB(db_file_delete)\n    user_db.insert_user('user1', 'pass1')\n    user_db.delete_user_by_username('user1')\n    result_after_delete = user_db.search_user_by_username('user1')\n    print(f\"Delete Test - Result length for 'user1' after deletion: {len(result_after_delete)}\") # Expect 0\n    user_db.close()\n    if os.path.exists(db_file_delete): os.remove(db_file_delete)\n\n\n    # Test 4: validate_user_login (modified from original)\n    print(\"\\nTesting validate_user_login...\")\n    db_file_validate = \"user_database_validate.db\"\n    if os.path.exists(db_file_validate): os.remove(db_file_validate)\n    user_db = UserLoginDB(db_file_validate)\n    user_db.insert_user('user1', 'pass1')\n    print(f\"Validate Test - 'user1', 'pass1' is valid: {user_db.validate_user_login('user1', 'pass1')}\") # Expect True\n    print(f\"Validate Test - 'user1', 'wrong_pass' is valid: {user_db.validate_user_login('user1', 'wrong_pass')}\") # Expect False\n    user_db.close()\n    if os.path.exists(db_file_validate): os.remove(db_file_validate)\n\n    # You can also run doctest on the actual docstrings if they were written in standard doctest format\n    # import doctest\n    # doctest.testmod()\n\n    print(\"\\nCompleted tests.\")\n\n```",
      "```python\nimport sqlite3\nimport os # Added for cleanup in doctests\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name # Store db_name for potential use (e.g., in doctest cleanup)\n        self.connection = None # Initialize connection as None\n        self.cursor = None     # Initialize cursor as None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            # Automatically create table if it doesn't exist\n            self.create_table()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            # Close connection if it was opened\n            if self.connection:\n                self.connection.close()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it doesn't already exist.\n        The table has 'username' (UNIQUE, NOT NULL) and 'password' (NOT NULL) columns.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT UNIQUE NOT NULL,\n                    password TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n            self.connection.rollback() # Rollback changes on error\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> db_file = \"user_database_insert.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        1\n        >>> result[0][0]\n        'user1'\n        >>> result[0][1]\n        'pass1'\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            self.cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n            self.connection.commit()\n            # print(f\"User '{username}' inserted successfully.\") # Optional feedback\n        except sqlite3.IntegrityError:\n            print(f\"Error: Username '{username}' already exists.\")\n            self.connection.rollback() # Rollback changes\n        except sqlite3.Error as e:\n            print(f\"Error inserting user '{username}': {e}\")\n            self.connection.rollback() # Rollback changes\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> db_file = \"user_database_search.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.insert_user('user2', 'pass2')\n        >>> result1 = user_db.search_user_by_username('user1')\n        >>> len(result1)\n        1\n        >>> result1[0][0]\n        'user1'\n        >>> result2 = user_db.search_user_by_username('user_nonexistent')\n        >>> len(result2)\n        0\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"Error searching for user '{username}': {e}\")\n            return []\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> db_file = \"user_database_delete.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.insert_user('user2', 'pass2')\n        >>> len(user_db.search_user_by_username('user1'))\n        1\n        >>> user_db.delete_user_by_username('user1')\n        >>> len(user_db.search_user_by_username('user1'))\n        0\n        >>> len(user_db.search_user_by_username('user2'))\n        1\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            self.connection.commit()\n            # print(f\"User '{username}' deleted successfully.\") # Optional feedback\n        except sqlite3.Error as e:\n            print(f\"Error deleting user '{username}': {e}\")\n            self.connection.rollback()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        >>> db_file = \"user_database_validate.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        >>> user_db.validate_user_login('user1', 'wrong_pass')\n        False\n        >>> user_db.validate_user_login('nonexistent_user', 'any_pass')\n        False\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT 1 FROM users WHERE username = ? AND password = ?\", (username, password))\n            result = self.cursor.fetchone()\n            return result is not None # Returns True if a row was found, False otherwise\n        except sqlite3.Error as e:\n            print(f\"Error validating login for '{username}': {e}\")\n            return False # Assume login fails on error\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            # print(\"Database connection closed.\") # Optional feedback\n\n# Example Usage (outside the class definition)\nif __name__ == '__main__':\n    db_file = \"my_user_database.db\"\n    # Clean up previous test file if it exists\n    if os.path.exists(db_file):\n        os.remove(db_file)\n        print(f\"Cleaned up existing {db_file}\")\n\n    print(f\"\\nInitializing database '{db_file}'\")\n    user_db = UserLoginDB(db_file)\n\n    # Insert users\n    print(\"\\nInserting users...\")\n    user_db.insert_user(\"alice\", \"securepass123\")\n    user_db.insert_user(\"bob\", \"password456\")\n    user_db.insert_user(\"alice\", \"anotherpass\") # Try inserting existing user\n\n    # Search users\n    print(\"\\nSearching for 'alice'...\")\n    alice_users = user_db.search_user_by_username(\"alice\")\n    print(f\"Found {len(alice_users)} entries for alice: {alice_users}\")\n\n    print(\"\\nSearching for 'charlie'...\")\n    charlie_users = user_db.search_user_by_username(\"charlie\")\n    print(f\"Found {len(charlie_users)} entries for charlie: {charlie_users}\")\n\n    # Validate login\n    print(\"\\nValidating logins...\")\n    print(f\"Login 'alice' with 'securepass123': {user_db.validate_user_login('alice', 'securepass123')}\")\n    print(f\"Login 'bob' with 'password456': {user_db.validate_user_login('bob', 'password456')}\")\n    print(f\"Login 'alice' with 'wrongpass': {user_db.validate_user_login('alice', 'wrongpass')}\")\n    print(f\"Login 'charlie' with 'anypass': {user_db.validate_user_login('charlie', 'anypass')}\")\n\n    # Delete user\n    print(\"\\nDeleting 'bob'...\")\n    user_db.delete_user_by_username(\"bob\")\n\n    # Verify deletion\n    print(\"\\nSearching for 'bob' after deletion...\")\n    bob_users_after_delete = user_db.search_user_by_username(\"bob\")\n    print(f\"Found {len(bob_users_after_delete)} entries for bob after deletion.\")\n\n    # Close connection\n    user_db.close()\n    print(\"\\nDatabase connection closed.\")\n\n    # Optional: Run doctests to verify class functionality\n    # import doctest\n    # print(\"\\nRunning doctests...\")\n    # doctest.testmod()\n```",
      "```python\nimport sqlite3\nimport os\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = None\n        self.cursor = None\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            # Ensure the table exists when the object is initialized\n            self.create_table()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            # Optionally re-raise the exception or handle it appropriately\n            raise\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it does not exist.\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT PRIMARY KEY,\n                    password TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n            # print(\"Table 'users' created or already exists.\")\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n            self.connection.rollback() # Rollback changes if table creation fails\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user. # Note: Passwords should be hashed in a real application!\n        :return: bool, True if insertion was successful, False otherwise (e.g., username already exists).\n        >>> db_file = \"user_database_test_insert.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        True\n        >>> user_db.insert_user('user1', 'pass1') # Try inserting duplicate username\n        False\n        >>> user_db.close()\n        \"\"\"\n        try:\n            # Using INSERT OR IGNORE will fail silently on conflict,\n            # but we want to know if it succeeded, so let's catch the exception.\n            self.cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n            self.connection.commit()\n            # print(f\"User '{username}' inserted successfully.\")\n            return True\n        except sqlite3.IntegrityError:\n            # This error occurs if the PRIMARY KEY (username) is duplicated\n            print(f\"Error: Username '{username}' already exists.\")\n            self.connection.rollback()\n            return False\n        except sqlite3.Error as e:\n            print(f\"Error inserting user: {e}\")\n            self.connection.rollback()\n            return False\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria. Returns an empty list if no user is found.\n        >>> db_file = \"user_database_test_search.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        True\n        >>> user_db.insert_user('user2', 'pass2')\n        True\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        1\n        >>> result[0][0] # Check username\n        'user1'\n        >>> result = user_db.search_user_by_username('user_nonexistent')\n        >>> len(result)\n        0\n        >>> user_db.close()\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n            # fetchall() returns a list of all rows. If no match, it's an empty list.\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"Error searching user: {e}\")\n            return [] # Return empty list on error\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: bool, True if at least one user was deleted, False otherwise.\n        >>> db_file = \"user_database_test_delete.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        True\n        >>> user_db.insert_user('user2', 'pass2')\n        True\n        >>> user_db.delete_user_by_username('user1')\n        True\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        0\n        >>> user_db.delete_user_by_username('user_nonexistent')\n        False\n        >>> user_db.close()\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            # rowcount will be the number of rows deleted\n            rows_deleted = self.cursor.rowcount\n            self.connection.commit()\n            # print(f\"Deleted {rows_deleted} user(s) with username '{username}'.\")\n            return rows_deleted > 0\n        except sqlite3.Error as e:\n            print(f\"Error deleting user: {e}\")\n            self.connection.rollback()\n            return False\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct.\n        Note: This performs a direct password comparison. In a real application, compare hashed passwords.\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly.\n        >>> db_file = \"user_database_test_validate.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.insert_user('user1', 'pass1')\n        True\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        >>> user_db.validate_user_login('user1', 'wrong_pass')\n        False\n        >>> user_db.validate_user_login('user_nonexistent', 'pass1')\n        False\n        >>> user_db.close()\n        \"\"\"\n        try:\n            # We select the username and password where both match the input\n            self.cursor.execute(\"SELECT username FROM users WHERE username = ? AND password = ?\", (username, password))\n            # fetchone() retrieves the next row of a query result set, or None if no more rows are available.\n            row = self.cursor.fetchone()\n            # If a row is returned (not None), it means the user exists and the password matched.\n            return row is not None\n        except sqlite3.Error as e:\n            print(f\"Error validating user login: {e}\")\n            return False # Return False on error\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        It's good practice to call this when the object is no longer needed.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n            # print(f\"Connection to {self.db_name} closed.\")\n\n    def __del__(self):\n        \"\"\"\n        Destructor to ensure the database connection is closed when the object is garbage collected.\n        \"\"\"\n        self.close()\n\n# Example Usage (outside the class definition, just for demonstration)\n# if __name__ == \"__main__\":\n#     # Clean up previous test database files\n#     for f in [\"user_database_test_insert.db\", \"user_database_test_search.db\", \"user_database_test_delete.db\", \"user_database_test_validate.db\"]:\n#         if os.path.exists(f):\n#             os.remove(f)\n\n#     # Run doctests\n#     import doctest\n#     doctest.testmod()\n\n    # # Manual test example\n    # db_file = \"my_user_database.db\"\n    # if os.path.exists(db_file):\n    #      os.remove(db_file) # Start fresh for manual test\n\n    # print(\"\\n--- Manual Test ---\")\n    # user_db = UserLoginDB(db_file)\n\n    # print(\"Inserting users...\")\n    # user_db.insert_user(\"alice\", \"secure_pass\")\n    # user_db.insert_user(\"bob\", \"another_pass\")\n    # user_db.insert_user(\"alice\", \"duplicate_pass\") # Should fail\n\n    # print(\"\\nSearching for users...\")\n    # alice_data = user_db.search_user_by_username(\"alice\")\n    # print(f\"Search 'alice': {alice_data}\")\n    # charlie_data = user_db.search_user_by_username(\"charlie\")\n    # print(f\"Search 'charlie': {charlie_data}\")\n\n    # print(\"\\nValidating logins...\")\n    # print(f\"Validate 'alice'/'secure_pass': {user_db.validate_user_login('alice', 'secure_pass')}\")\n    # print(f\"Validate 'bob'/'another_pass': {user_db.validate_user_login('bob', 'another_pass')}\")\n    # print(f\"Validate 'alice'/'wrong_pass': {user_db.validate_user_login('alice', 'wrong_pass')}\")\n    # print(f\"Validate 'charlie'/'any_pass': {user_db.validate_user_login('charlie', 'any_pass')}\")\n\n    # print(\"\\nDeleting user...\")\n    # print(f\"Delete 'bob': {user_db.delete_user_by_username('bob')}\")\n    # print(f\"Delete 'bob' again: {user_db.delete_user_by_username('bob')}\") # Should fail\n    # print(f\"Delete 'charlie': {user_db.delete_user_by_username('charlie')}\") # Should fail\n\n    # print(\"\\nSearching after deletion...\")\n    # bob_data_after_delete = user_db.search_user_by_username(\"bob\")\n    # print(f\"Search 'bob': {bob_data_after_delete}\")\n\n    # user_db.close()\n    # print(\"\\nManual Test Complete.\")\n```",
      "```python\nimport sqlite3\nimport os # Used for cleaning up database files in doctests\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it doesn't already exist.\n        This table is required for user storage.\n        \"\"\"\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT NOT NULL UNIQUE,\n                    password TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"An error occurred while creating table: {e}\")\n\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: True if insertion was successful, False if username already exists.\n        >>> import os\n        >>> db_file = \"user_database_insert.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        True\n        >>> user_db.insert_user('user1', 'pass1') # Attempt to insert duplicate\n        False\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        1\n        >>> result[0]\n        ('user1', 'pass1')\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            # Using INSERT OR IGNORE will insert if username is unique, otherwise do nothing.\n            # Alternatively, a simple INSERT and catch IntegrityError could be used.\n            # Let's use INSERT and catch the error to indicate failure explicitly.\n            self.cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n            self.connection.commit()\n            return True\n        except sqlite3.IntegrityError:\n            # This error occurs if the UNIQUE constraint on username is violated\n            print(f\"Error: Username '{username}' already exists.\")\n            return False\n        except sqlite3.Error as e:\n            print(f\"An error occurred during user insertion: {e}\")\n            return False\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria. Returns an empty list if no user is found or an error occurs.\n        >>> import os\n        >>> db_file = \"user_database_search.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.insert_user('user2', 'pass2')\n        >>> result1 = user_db.search_user_by_username('user1')\n        >>> len(result1)\n        1\n        >>> result1[0]\n        ('user1', 'pass1')\n        >>> result2 = user_db.search_user_by_username('nonexistent')\n        >>> len(result2)\n        0\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"An error occurred during user search: {e}\")\n            return []\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: True if a user was deleted, False otherwise (e.g., user not found or error).\n        >>> import os\n        >>> db_file = \"user_database_delete.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.insert_user('user2', 'pass2')\n        >>> result_before = user_db.search_user_by_username('user1')\n        >>> len(result_before)\n        1\n        >>> user_db.delete_user_by_username('user1')\n        True\n        >>> user_db.delete_user_by_username('nonexistent')\n        False\n        >>> result_after = user_db.search_user_by_username('user1')\n        >>> len(result_after)\n        0\n        >>> result_other = user_db.search_user_by_username('user2')\n        >>> len(result_other)\n        1\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            deleted_count = self.cursor.rowcount\n            self.connection.commit()\n            return deleted_count > 0\n        except sqlite3.Error as e:\n            print(f\"An error occurred during user deletion: {e}\")\n            return False\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct.\n        Note: Storing plaintext passwords is insecure. Hashing should be used in a real application.\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        >>> import os\n        >>> db_file = \"user_database_validate.db\"\n        >>> if os.path.exists(db_file): os.remove(db_file)\n        >>> user_db = UserLoginDB(db_file)\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.insert_user('user2', 'pass2')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        >>> user_db.validate_user_login('user2', 'pass2')\n        True\n        >>> user_db.validate_user_login('user1', 'wrong_pass')\n        False\n        >>> user_db.validate_user_login('nonexistent_user', 'any_pass')\n        False\n        >>> user_db.close()\n        >>> if os.path.exists(db_file): os.remove(db_file) # Clean up\n        \"\"\"\n        try:\n            # Select any column (like 1) just to check existence\n            self.cursor.execute(\"SELECT 1 FROM users WHERE username = ? AND password = ?\", (username, password))\n            # Fetch one row. If a row is found, it means the username and password matched.\n            result = self.cursor.fetchone()\n            return result is not None\n        except sqlite3.Error as e:\n            print(f\"An error occurred during login validation: {e}\")\n            return False\n\n    def close(self):\n        \"\"\"\n        Closes the database connection. It's important to call this when done.\n        \"\"\"\n        self.connection.close()\n\n# Example Usage (optional, mostly covered by doctests)\nif __name__ == '__main__':\n    # This block demonstrates how to use the class outside of doctests\n    # Create a database in memory for demonstration\n    db_name = \":memory:\" # Use ':memory:' for an in-memory database (doesn't persist)\n    # For a file-based db, use a filename like \"my_users.db\"\n    # db_name = \"my_users.db\"\n\n    user_db = UserLoginDB(db_name)\n    user_db.create_table()\n\n    print(\"Inserting users...\")\n    user_db.insert_user(\"alice\", \"secure_pass_123\")\n    user_db.insert_user(\"bob\", \"another_pass\")\n    user_db.insert_user(\"alice\", \"duplicate_attempt\") # This should fail\n\n    print(\"\\nSearching for 'alice':\")\n    alice_info = user_db.search_user_by_username(\"alice\")\n    print(alice_info)\n\n    print(\"\\nSearching for 'charlie':\")\n    charlie_info = user_db.search_user_by_username(\"charlie\")\n    print(charlie_info)\n\n    print(\"\\nValidating logins:\")\n    print(f\"alice/secure_pass_123: {user_db.validate_user_login('alice', 'secure_pass_123')}\")\n    print(f\"bob/wrong_password: {user_db.validate_user_login('bob', 'wrong_password')}\")\n    print(f\"charlie/any_password: {user_db.validate_user_login('charlie', 'any_password')}\")\n\n    print(\"\\nDeleting 'bob'...\")\n    user_db.delete_user_by_username(\"bob\")\n\n    print(\"\\nSearching for 'bob' after deletion:\")\n    bob_info_after_delete = user_db.search_user_by_username(\"bob\")\n    print(bob_info_after_delete)\n\n    user_db.close()\n    print(\"\\nDatabase connection closed.\")\n\n    # Clean up file-based database if it was created for example\n    # if db_name != \":memory:\" and os.path.exists(db_name):\n    #    os.remove(db_name)\n    #    print(f\"Cleaned up database file: {db_name}\")\n\n```",
      "```python\nimport sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        try:\n            self.connection = sqlite3.connect(db_name)\n            self.cursor = self.connection.cursor()\n            # Ensure the table exists\n            self.create_table()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            self.connection = None # Indicate connection failed\n            self.cursor = None\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it doesn't exist.\n        The table will have 'username' (TEXT, UNIQUE, NOT NULL) and 'password' (TEXT, NOT NULL) columns.\n        \"\"\"\n        if self.connection is None:\n            print(\"Cannot create table: Database connection failed.\")\n            return\n        try:\n            self.cursor.execute('''\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT UNIQUE NOT NULL,\n                    password TEXT NOT NULL\n                )\n            ''')\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error creating table: {e}\")\n\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\":memory:\") # Use in-memory database for doctests\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        1\n        >>> user_db.insert_user('user1', 'anotherpass') # Try inserting duplicate username\n        Username 'user1' already exists.\n        \"\"\"\n        if self.connection is None:\n            print(\"Cannot insert user: Database connection failed.\")\n            return\n\n        try:\n            self.cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            print(f\"Username '{username}' already exists.\")\n        except sqlite3.Error as e:\n            print(f\"Error inserting user: {e}\")\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n                 Returns an empty list if no user is found or if there's a database error.\n        >>> user_db = UserLoginDB(\":memory:\")\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        >>> len(result)\n        1\n        >>> result[0][0] # Check username\n        'user1'\n        >>> result_nonexistent = user_db.search_user_by_username('nonexistent_user')\n        >>> len(result_nonexistent)\n        0\n        \"\"\"\n        if self.connection is None:\n            print(\"Cannot search user: Database connection failed.\")\n            return []\n\n        try:\n            self.cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n            rows = self.cursor.fetchall()\n            return rows\n        except sqlite3.Error as e:\n            print(f\"Error searching for user: {e}\")\n            return []\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\":memory:\")\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result_before = user_db.search_user_by_username('user1')\n        >>> len(result_before)\n        1\n        >>> user_db.delete_user_by_username('user1')\n        >>> result_after = user_db.search_user_by_username('user1')\n        >>> len(result_after)\n        0\n        >>> user_db.delete_user_by_username('nonexistent_user') # Deleting non-existent user should not raise error\n        \"\"\"\n        if self.connection is None:\n            print(\"Cannot delete user: Database connection failed.\")\n            return\n\n        try:\n            self.cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Error deleting user: {e}\")\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct.\n        Note: Storing passwords in plain text is not secure. This implementation is based on the provided structure.\n              For production, always use password hashing (e.g., bcrypt, scrypt).\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\":memory:\")\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        >>> user_db.validate_user_login('user1', 'wrongpass')\n        False\n        >>> user_db.validate_user_login('nonexistent_user', 'anypass')\n        False\n        \"\"\"\n        if self.connection is None:\n            print(\"Cannot validate login: Database connection failed.\")\n            return False\n\n        try:\n            # Search for a user with the exact username AND password\n            self.cursor.execute(\"SELECT username FROM users WHERE username = ? AND password = ?\", (username, password))\n            row = self.cursor.fetchone()\n\n            # If fetchone returns a row, it means a matching user was found\n            return row is not None\n        except sqlite3.Error as e:\n            print(f\"Error validating login: {e}\")\n            return False\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n            self.cursor = None\n            # print(\"Database connection closed.\")\n\n    def __del__(self):\n        \"\"\"\n        Ensures the connection is closed when the object is garbage collected.\n        Using an explicit `close()` method is generally preferred.\n        \"\"\"\n        self.close()\n\n# Example Usage (not part of the class definition itself, but for demonstration)\nif __name__ == \"__main__\":\n    # Using a file-based database for demonstration\n    db = UserLoginDB(\"my_user_database.db\")\n\n    # Clean up previous runs for a clean start\n    print(\"Cleaning up previous data for 'test_user'...\")\n    db.delete_user_by_username(\"test_user\")\n    print(\"-\" * 20)\n\n    # Test Insert\n    print(\"Inserting user 'test_user'...\")\n    db.insert_user(\"test_user\", \"secure_password123\")\n    print(\"-\" * 20)\n\n    # Test Search\n    print(\"Searching for 'test_user'...\")\n    users = db.search_user_by_username(\"test_user\")\n    if users:\n        print(f\"Found user: {users[0][0]}\")\n    else:\n        print(\"User 'test_user' not found.\")\n    print(\"-\" * 20)\n\n    # Test Validation\n    print(\"Validating login for 'test_user'...\")\n    if db.validate_user_login(\"test_user\", \"secure_password123\"):\n        print(\"Login successful for 'test_user'.\")\n    else:\n        print(\"Login failed for 'test_user'.\")\n\n    print(\"Validating login with wrong password...\")\n    if db.validate_user_login(\"test_user\", \"wrong_password\"):\n        print(\"Login successful (unexpected!).\")\n    else:\n        print(\"Login failed (as expected).\")\n    print(\"-\" * 20)\n\n    # Test Delete\n    print(\"Deleting user 'test_user'...\")\n    db.delete_user_by_username(\"test_user\")\n    print(\"-\" * 20)\n\n    # Verify deletion\n    print(\"Searching for 'test_user' after deletion...\")\n    users_after_delete = db.search_user_by_username(\"test_user\")\n    if users_after_delete:\n         print(\"User 'test_user' found (unexpected!).\")\n    else:\n         print(\"User 'test_user' not found (as expected).\")\n    print(\"-\" * 20)\n\n    # Close the database connection\n    db.close()\n    print(\"Database connection closed.\")\n\n    # You can also run the doctests included in the docstrings\n    # import doctest\n    # doctest.testmod()\n```"
    ]
  }
]